{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Automated infrastructure for maintaining long-lived forks</p>"},{"location":"#the-challenge","title":"The Challenge","text":"<p>Managing long-lived forks of OSDU repositories is complex. Organizations need to balance upstream compatibility with proprietary implementations while avoiding integration overhead, release delays, and community divergence.</p> <p>Traditional manual approaches are error-prone and resource-intensive.</p>"},{"location":"#the-solution","title":"The Solution","text":"<p>Complete automation framework for enterprise fork management:</p> <p> Smart Synchronization</p> <p>Automated daily upstream integration with AI-enhanced conflict detection and resolution guidance.   </p> <p> Three-Branch Strategy</p> <p>Proven branching strategy that isolates changes at each stage, preventing cascade failures.   </p> <p> AI-Enhanced Automation</p> <p>Intelligent analysis with automated commit messages, PR descriptions, and conflict categorization.   </p> <p> Enterprise Security</p> <p>Built-in vulnerability scanning, compliance checks, and branch protection rules.   </p>"},{"location":"#key-benefits","title":"Key Benefits","text":"<p> 90% reduction in manual integration work Automated conflict detection with AI guidance Enterprise security and compliance built-in Zero-configuration template deployment  </p>"},{"location":"concepts/","title":"Concepts","text":"<p>The Open Subsurface Data Universe (OSDU) project presents a fundamental architectural challenge for cloud providers who need to maintain both open-source compatibility and proprietary cloud-specific implementations. This challenge centers on the effective separation and management of Service Provider Interface (SPI) code.</p> <p>OSDU defines a structured architecture where community standards must remain separate from cloud-specific implementations. The diagram below illustrates how Microsoft maintains this separation through forking:</p> <pre><code>graph TB\n    subgraph Community[\"OSDU Community Repository - Upstream\"]\n        A1[API] --- B1[Core Code] --- C1[SPI Interface] --- D1[Community Implementation]\n    end\n\n    Community --&gt;|Synced Fork| Fork\n\n    subgraph Fork[\"Azure SPI Repository\"]\n        A2[API] --- B2[Core Code] --- C2[SPI Interface] --- D2[Azure Implementation]\n    end\n\n    style Community fill:#e8f5e9,stroke:#1b5e20,stroke-width:2px\n    style Fork fill:#e3f2fd,stroke:#1565c0,stroke-width:2px\n    style C1 fill:#fff3e0,stroke:#e65100,stroke-width:2px\n    style C2 fill:#fff3e0,stroke:#e65100,stroke-width:2px\n    style D1 fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px\n    style D2 fill:#e3f2fd,stroke:#1565c0,stroke-width:2px</code></pre> <p>The SPI Interface (highlighted in orange) serves as the critical boundary where community-defined standards meet cloud-specific implementations. Everything to the left must stay synchronized with upstream, while only the implementation layer (rightmost) contains Azure-specific code.</p> <p> Open Source Components include OSDU core interfaces, community-validated business logic, standard data models, and reference implementations for testing.</p> <p> Azure-Specific Components encompass Azure SPI layer implementations, Azure-native service integrations, proprietary optimizations, and Microsoft-specific configuration and deployment patterns.</p> <p>The Separation Challenge</p> <p>Microsoft must maintain clear boundaries between open-source OSDU core components and Azure-specific SPI implementations, while ensuring both remain compatible and current with upstream community standards.</p>"},{"location":"concepts/#the-fork-management-problem","title":"The Fork Management Problem","text":"<p>Maintaining long-lived forks of upstream OSDU repositories creates several critical challenges that compound in enterprise environments:</p> <p> Integration Complexity</p> <p>Manual synchronization with upstream changes requires significant engineering effort, particularly when upstream modifications affect interfaces that Azure SPI implementations depend upon.   </p> <p> Divergence Risk</p> <p>Over time, local modifications can diverge significantly from upstream standards, making integration increasingly difficult and potentially compromising compatibility.   </p> <p> Blocking Dependencies</p> <p>Under traditional approaches, compilation or testing failures in any Cloud Provider's SPI implementation could block merging changes to main branches, creating dependencies between unrelated provider implementations.   </p> <p> Release Coordination</p> <p>Correlating fork versions with upstream releases becomes complex without systematic tracking and version management.   </p> <p>Enterprise Compounding Effects</p> <p>These challenges multiply in enterprise environments where quarterly planning cycles cannot accommodate unpredictable upstream changes, teams require different workflows for upstream vs. proprietary code, compliance demands complete audit trails, and multiple downstream systems depend on stable, predictable releases.</p> <p>Traditional vs. Automated Approach</p> Aspect Traditional Fork Management Automated Solution Synchronization Manual, error-prone, weekly/monthly Automated daily with conflict detection Conflict Resolution Ad-hoc, blocking, expertise-dependent AI-enhanced guidance, isolated resolution Release Coordination Manual tracking, version drift risk Automatic correlation with upstream tags Integration Testing After conflicts resolved Continuous validation at each stage Team Productivity 40% time on integration overhead 90% reduction in manual integration work Risk Management Reactive, cascade failures possible Proactive, isolated failure containment"},{"location":"concepts/#the-automation-solution","title":"The Automation Solution","text":"<p>The fork management system implements controlled isolation through a three-branch strategy that separates concerns while maintaining automation throughout the integration process.</p> <p>Success Pattern: Three-Branch Strategy</p> <p>The key insight is controlled isolation - changes flow through <code>fork_upstream</code> \u2192 <code>fork_integration</code> \u2192 <code>main</code> with validation at each stage, preventing cascade failures while enabling systematic integration.</p> <pre><code>graph TD\n    A[OSDU Community Repository - Upstream]\n    A --&gt;|Fork| B\n\n    subgraph Azure[\"Azure SPI Repository\"]\n        B[fork_upstream&lt;br/&gt;Mirror]\n        B --&gt; C[fork_integration&lt;br/&gt;Conflict Resolution]\n        C --&gt; D[main&lt;br/&gt;Azure SPI Ready]\n    end\n\n    style A fill:#e8f5e9,stroke:#1b5e20,stroke-width:2px\n    style Azure fill:#e3f2fd,stroke:#1565c0,stroke-width:2px\n    style B fill:#fff3e0,stroke:#e65100,stroke-width:2px\n    style C fill:#fce4ec,stroke:#c2185b,stroke-width:2px\n    style D fill:#e3f2fd,stroke:#1565c0,stroke-width:2px</code></pre> <p>Automated Workflow Capabilities:</p> <p> Upstream Synchronization</p> <ul> <li>Scheduled pulls from upstream repositories</li> <li>Automated conflict detection and categorization  </li> <li>AI-enhanced analysis of change impacts   </li> </ul> <p> Conflict Management</p> <ul> <li>Isolated resolution environment in <code>fork_integration</code></li> <li>Guided resolution with generated instructions</li> <li>Testing validation before production integration   </li> </ul> <p> Release Coordination</p> <ul> <li>Automatic correlation with upstream version tags</li> <li>Semantic versioning aligned with upstream releases</li> <li>Clear change documentation and impact analysis   </li> </ul> <p>AI-Enhanced Development Support leverages multiple AI providers for intelligent analysis, automated impact assessment, step-by-step conflict resolution guidance, and generated commit messages and PR descriptions through Model Context Protocol (MCP) integration.</p>"},{"location":"concepts/#why-this-matters","title":"Why This Matters","text":"<p>This automated fork management approach delivers significant operational and strategic value across development teams, operations, and enterprise architecture.</p> <p>Key Impact Areas</p> <p>Teams achieve 90% reduction in manual integration work while maintaining full compatibility with upstream OSDU community standards. This enables focus on innovation rather than integration overhead.</p> Strategic ValueDevelopment TeamsOperations Teams <p> Separation of Concerns <p>Clear boundaries between open-source and proprietary development enable teams to optimize for their specific technical contexts without compromising either approach.   </p> <p> Scalable Automation <p>Template-based deployment supports unlimited fork instances with consistent automation patterns, enabling expansion across multiple OSDU repository forks.   </p> <p> Future-Proof Architecture <p>The system's design accommodates evolving upstream requirements and changing cloud provider strategies without requiring fundamental architectural changes.    </p> <p> Focus on Innovation <p>Teams spend time on Azure SPI enhancements rather than integration overhead, accelerating feature delivery and reducing context switching between upstream and proprietary development contexts.   </p> <p> Reduced Technical Debt <p>Systematic upstream integration prevents accumulation of compatibility issues, maintaining code quality and reducing maintenance burden through predictable automation.   </p> <p> Predictable Planning <p>Automated handling of routine integration tasks enables more reliable sprint planning and feature roadmap execution with fewer unexpected disruptions.    </p> <p> Enhanced Compliance <p>Complete audit trails and automated security scanning ensure regulatory requirements are consistently met throughout the integration process.   </p> <p> Reliable Delivery <p>Structured release correlation provides predictable, stable delivery points for downstream systems like Azure Data Manager for Energy (ADME).   </p> <p> Risk Mitigation <p>Early conflict detection and isolated resolution prevent integration issues from impacting production systems through controlled isolation patterns.    </p>"},{"location":"architecture/ai_integration/","title":"AI Integration Architecture","text":"<p>The OSDU SPI Fork Management system incorporates sophisticated AI capabilities to enhance development workflows while maintaining reliability and cost-effectiveness. This integration provides intelligent analysis, automated documentation generation, and enhanced decision-making support throughout the fork management lifecycle.</p>"},{"location":"architecture/ai_integration/#ai-integration-philosophy","title":"AI Integration Philosophy","text":"<ul> <li> <p> Enhancement, Not Dependency</p> <p>AI capabilities enhance existing workflows without creating dependencies. All core functionality operates normally when AI services are unavailable, ensuring system reliability.</p> </li> </ul> <ul> <li> <p> Multi-Provider Architecture</p> <p>Support for multiple AI providers prevents vendor lock-in and enables intelligent provider selection based on availability, cost, and capability requirements.</p> </li> </ul> <ul> <li> <p> Secure by Design</p> <p>API keys and sensitive data are handled through secure GitHub secrets management with proper access controls and audit trails.</p> </li> </ul> <ul> <li> <p> Cost-Conscious Usage</p> <p>Intelligent usage patterns, caching, and fallback strategies control API costs while maximizing value from AI capabilities.</p> </li> </ul>"},{"location":"architecture/ai_integration/#ai-provider-architecture","title":"AI Provider Architecture","text":"<pre><code>graph TD\n    A[Workflow Trigger] --&gt; B[AI Provider Selection]\n    B --&gt; C{Primary: Claude}\n    B --&gt; D{Secondary: Azure OpenAI}\n    B --&gt; E{Tertiary: OpenAI}\n\n    C --&gt; F[Claude Code CLI]\n    C --&gt; G[Direct API Access]\n    D --&gt; H[Azure OpenAI Service]\n    E --&gt; I[OpenAI GPT-4]\n\n    F --&gt; J[AI Analysis Output]\n    G --&gt; J\n    H --&gt; J\n    I --&gt; J\n\n    J --&gt; K[Fallback to Standard Template]\n\n    style A fill:#e1f5fe,stroke:#01579b,stroke-width:2px\n    style C fill:#e8f5e9,stroke:#1b5e20,stroke-width:2px\n    style D fill:#fff3e0,stroke:#e65100,stroke-width:2px\n    style E fill:#fce4ec,stroke:#c2185b,stroke-width:2px</code></pre>"},{"location":"architecture/ai_integration/#provider-hierarchy","title":"Provider Hierarchy","text":"Provider Priority Integration Key Strengths Best Use Case Claude (Anthropic) Primary Claude Code CLI + MCP Code analysis, reasoning, large context Complex analysis and generation tasks Azure OpenAI Secondary Azure API + Enterprise features Enterprise integration, compliance Microsoft-aligned environments :material-openai: OpenAI Tertiary Direct API access Broad model availability, baselines Comprehensive fallback coverage <p>Provider Selection Strategy</p> <p>The system automatically selects the highest-priority available provider, with intelligent fallback to ensure reliable operation even when primary services are unavailable.</p>"},{"location":"architecture/ai_integration/#ai-enhanced-capabilities","title":"AI-Enhanced Capabilities","text":"<ul> <li> <p> Intelligent Change Analysis</p> <p>AI-powered analysis of upstream changes and merge conflicts with structured impact assessment and intelligent resolution guidance</p> <ul> <li>Change Classification: Automatic categorization of changes (feat, fix, breaking, etc.)</li> <li>Impact Assessment: Analysis of potential effects on Azure SPI implementations</li> <li>Conflict Resolution: Intelligent guidance for merge conflict resolution strategies</li> <li>Risk Evaluation: Identification of high-risk changes requiring careful review</li> </ul> </li> </ul> <ul> <li> <p> Automated Documentation Generation</p> <p>AI-generated pull request descriptions and conventional commit messages that integrate seamlessly with semantic versioning workflows</p> <ul> <li>PR Enhancement: Comprehensive pull request descriptions with structured summaries</li> <li>Conventional Commits: Standardized commit messages with proper scope detection</li> <li>Breaking Change Detection: Automatic identification and marking of breaking changes</li> <li>Release Integration: Messages designed for automated changelog generation</li> </ul> </li> </ul> <p>AI-Generated PR Description Sample</p> <pre><code>## Summary\nThis sync integrates 12 commits from upstream with primarily dependency updates and security fixes.\n\n## Key Changes\n- **Security**: Updated Jackson dependency to resolve CVE-2023-35116\n- **Enhancement**: Improved error handling in data processing pipeline\n\n## Impact Assessment\n- **Breaking Changes**: None detected\n- **Testing**: All upstream tests passing\n</code></pre> <ul> <li> <p> AI-Enhanced Security Analysis</p> <p>AI-powered security analysis that provides contextual vulnerability assessment, intelligent secret detection, and actionable remediation guidance</p> <ul> <li>Vulnerability Triage: Contextual risk assessment with intelligent priority ranking</li> <li>Secret Detection: Advanced pattern recognition with false positive reduction</li> <li>Remediation Guidance: Specific recommendations for vulnerability and secret resolution</li> <li>Risk Assessment: Deployment context analysis for accurate threat evaluation</li> </ul> </li> </ul> <p>AI Integration Benefits</p> <p>These AI capabilities work together to create an intelligent development environment that reduces manual effort, improves code quality, and accelerates the development lifecycle while maintaining security and reliability standards.</p> <ul> <li> <p> Cross-Platform Integration</p> <p>AI-powered GitHub-to-GitLab workflow automation that enables seamless contribution to OSDU community repositories while maintaining GitHub-based development workflows</p> <ul> <li>GitLab MR Creation: Automated GitLab merge request creation from GitHub PRs</li> <li>Cross-Platform Sync: Intelligent synchronization of changes between GitHub and GitLab</li> <li>OSDU Integration: Specialized support for <code>community.opengroup.org</code> GitLab instance</li> <li>AI-Enhanced Triggers: <code>@alfi</code> mentions activate cross-platform automation</li> </ul> </li> </ul>"},{"location":"architecture/ai_integration/#technical-implementation","title":"Technical Implementation","text":""},{"location":"architecture/ai_integration/#claude-code-cli-integration","title":"Claude Code CLI Integration","text":""},{"location":"architecture/ai_integration/#installation-and-configuration","title":"Installation and Configuration","text":"<p>Automated setup in GitHub Actions workflows:</p> <pre><code># Claude Code CLI Installation\n- name: Install Claude Code CLI\n  run: npm install -g @anthropic-ai/claude-code\n\n# MCP Configuration for Maven and GitLab Integration  \n- name: Configure MCP Servers\n  run: |\n    cat &gt; .mcp.json &lt;&lt; 'EOF'\n    {\n      \"mcpServers\": {\n        \"mvn-mcp-server\": {\n          \"type\": \"stdio\",\n          \"command\": \"uvx\",\n          \"args\": [\"--from\", \"git+https://github.com/danielscholl-osdu/mvn-mcp-server@main\", \"mvn-mcp-server\"]\n        },\n        \"gitlab\": {\n          \"command\": \"npx\",\n          \"args\": [\"-y\", \"@zereight/mcp-gitlab\"],\n          \"env\": {\n            \"GITLAB_PERSONAL_ACCESS_TOKEN\": \"${{ secrets.GITLAB_TOKEN }}\",\n            \"GITLAB_API_URL\": \"https://community.opengroup.org/api/v4\"\n          }\n        }\n      }\n    }\n    EOF\n</code></pre>"},{"location":"architecture/ai_integration/#model-context-protocol-mcp-integration","title":"Model Context Protocol (MCP) Integration","text":"<p>Specialized tool integration for enhanced AI capabilities:</p> <ul> <li>Maven MCP Server: Dependency analysis and management recommendations for Java/Maven projects</li> <li>GitLab MCP Server: Cross-platform GitLab API operations for MR creation and repository management</li> <li>Git Integration: Repository history and change pattern analysis across platforms</li> <li>Security Scanning: Vulnerability database integration and analysis</li> <li>Documentation Tools: Automated documentation generation and validation</li> </ul>"},{"location":"architecture/ai_integration/#cross-platform-gitlab-integration","title":"Cross-Platform GitLab Integration","text":""},{"location":"architecture/ai_integration/#ai-enhanced-gitlab-workflow-osdu-alfiyml","title":"AI-Enhanced GitLab Workflow (<code>osdu-alfi.yml</code>)","text":"<p>The system includes sophisticated cross-platform integration that extends AI capabilities to GitLab repositories, enabling seamless contribution to OSDU community projects:</p> <pre><code>sequenceDiagram\n    participant GH as GitHub PR/Issue\n    participant AI as Claude + GitLab MCP\n    participant GL as GitLab Repository\n    participant U as User\n\n    U-&gt;&gt;GH: Add @alfi mention to comment\n    GH-&gt;&gt;AI: Trigger OSDU Alfi workflow\n    AI-&gt;&gt;AI: Analyze GitHub context and changes\n    AI-&gt;&gt;GL: Create corresponding GitLab branch\n    AI-&gt;&gt;GL: Push synchronized changes\n    AI-&gt;&gt;GL: Create GitLab merge request\n    AI-&gt;&gt;GH: Comment with GitLab MR link</code></pre> <p>Key Capabilities:</p> <ul> <li>Trigger Activation: <code>@alfi</code> mentions in GitHub PR reviews, issue comments, or new issues</li> <li>Context Analysis: AI reads GitHub PR/issue content and determines appropriate GitLab actions</li> <li>Branch Synchronization: Creates GitLab branches with synchronized changes from GitHub</li> <li>MR Creation: Generates GitLab merge requests with OSDU-appropriate labels and descriptions</li> <li>Feedback Loop: Comments back on GitHub with GitLab MR links for seamless tracking</li> </ul> <p>OSDU-Specific Features:</p> <ul> <li>Community GitLab Targeting: Configured for <code>community.opengroup.org</code> GitLab instance</li> <li>OSDU Branch Naming: Uses <code>ai-agent/</code> prefix for automated branches</li> <li>Appropriate Labeling: Applies <code>MR::Dependencies Upgrade</code> and context-specific labels</li> <li>Template Protection: Automatically skips template repositories, only runs on actual forks</li> </ul> <p>Cross-Platform Workflow Integration</p> <p>This GitLab integration extends the three-branch strategy without disrupting it. GitHub remains the primary development platform, while GitLab integration provides automated pathways for contributing to upstream OSDU repositories.</p>"},{"location":"architecture/ai_integration/#multi-provider-fallback-strategy","title":"Multi-Provider Fallback Strategy","text":""},{"location":"architecture/ai_integration/#provider-selection-logic","title":"Provider Selection Logic","text":"<pre><code>graph TD\n    A[AI Task Request] --&gt; B{Claude API Key?}\n    B --&gt;|Yes| C[Use Claude Code CLI]\n    B --&gt;|No| D{Azure OpenAI Key?}\n    D --&gt;|Yes| E[Use Azure OpenAI]\n    D --&gt;|No| F{OpenAI Key?}\n    F --&gt;|Yes| G[Use OpenAI GPT-4]\n    F --&gt;|No| H[Use Standard Template]\n\n    C --&gt; I{Success?}\n    E --&gt; I\n    G --&gt; I\n    I --&gt;|No| J[Try Next Provider]\n    I --&gt;|Yes| K[Return AI Result]\n    J --&gt; D\n    H --&gt; L[Return Standard Result]</code></pre> <p>Graceful Degradation</p> <p>When AI services are unavailable, the system automatically falls back to proven alternatives:</p> <p>\u2713 Standard Templates for PR descriptions and commit messages \u2713 Rule-based Analysis for conflict detection and categorization \u2713 Manual Workflows with clear guidance for AI-enhanced tasks \u2713 Informative Error Messages about service availability</p>"},{"location":"architecture/ai_integration/#performance-optimization","title":"Performance Optimization","text":"Strategy Implementation Benefit Control Mechanism Response Caching Cache similar change patterns Reduced API calls Intelligent cache invalidation Model Selection Task complexity analysis Optimized costs Automatic provider selection Batch Processing Group related tasks Improved efficiency Smart batching algorithms Usage Monitoring Track API costs Budget visibility Real-time cost tracking Intelligent Routing Cost-effective providers Optimized spending Provider cost comparison Context Optimization Minimize token usage Reduced costs Smart content summarization Budget Controls Configurable limits Cost management Automated alerts and limits"},{"location":"architecture/ai_integration/#security-and-compliance","title":"Security and Compliance","text":"\ud83d\udd10 API Security\ud83d\udcca Data Protection\u2705 Quality Assurance <p>Secure Storage &amp; Access Control:</p> <ul> <li>GitHub Secrets: Encrypted storage of all AI provider API keys</li> <li>Environment Isolation: Separate keys for different environments  </li> <li>Access Controls: Limited access based on repository permissions</li> <li>Audit Logging: Complete audit trail of AI service usage</li> </ul> <p>Privacy &amp; Compliance:</p> <ul> <li>Minimal Data Exposure: Only necessary code changes sent to AI services</li> <li>No Persistent Storage: AI providers don't retain workflow data</li> <li>Regional Compliance: Data residency support through Azure OpenAI</li> <li>Encryption: All API communications use TLS encryption</li> </ul> <p>Output Validation &amp; Reliability:</p> <ul> <li>Format Verification: Ensure AI outputs meet expected formats</li> <li>Content Filtering: Validate appropriate content in AI-generated text</li> <li>Consistency Checks: Verify consistency across related AI outputs</li> <li>Human Review: Require human approval for critical AI-generated content</li> <li>Timeout Handling: Appropriate timeouts for AI service calls</li> <li>Error Recovery: Robust error handling with informative messages</li> <li>Service Monitoring: Track AI service availability and performance</li> <li>Fallback Testing: Regular validation of fallback mechanisms</li> </ul>"},{"location":"architecture/overview/","title":"Overview","text":""},{"location":"architecture/overview/#principles","title":"Principles","text":"<p>The OSDU SPI Fork Management system is built on a foundation of template-driven automation that prioritizes zero-configuration deployment, intelligent automation, and continuous maintenance. The architecture leverages GitHub's native capabilities to provide enterprise-grade fork management without external dependencies.</p> <ul> <li> <p> Self-Configuring</p> <p>Template repositories automatically adapt to specific upstream sources through intelligent initialization workflows that detect and configure appropriate settings.</p> </li> <li> <p> Safety-First</p> <p>Multiple validation points prevent unstable code promotion through the three-branch strategy, with branch protection rules and automated security scanning.</p> </li> <li> <p> Event-Driven</p> <p>Automated response to repository changes, schedules, and external triggers enables real-time synchronization and conflict management.</p> </li> <li> <p> Scalable</p> <p>Support unlimited repository deployments with consistent patterns, enabling enterprise-wide adoption across multiple OSDU repository forks.</p> </li> </ul>"},{"location":"architecture/overview/#system-design","title":"System Design","text":"<p>The system implements a sophisticated template repository pattern that separates concerns:</p> <pre><code>graph TD\n    A[Template Repository] --&gt; B[Fork Instance 1]\n    A --&gt; C[Fork Instance 2]\n    A --&gt; D[Fork Instance N]\n\n    B --&gt; E[Upstream OSDU library]\n    C --&gt; F[Upstream OSDU legal]\n    D --&gt; G[Upstream OSDU storage]\n\n    style A fill:#e1f5fe,stroke:#01579b,stroke-width:2px\n    style B fill:#e8f5e9,stroke:#1b5e20,stroke-width:2px\n    style C fill:#e8f5e9,stroke:#1b5e20,stroke-width:2px\n    style D fill:#e8f5e9,stroke:#1b5e20,stroke-width:2px</code></pre> <p>Template Repository Pattern</p> <p>This pattern separates template development from instance operation, enabling scalable management of unlimited fork deployments while maintaining consistent automation patterns.</p> <p>Template Development Context includes <code>.github/workflows/</code> for template development and maintenance workflows, template-specific documentation and configuration, and update propagation mechanisms with testing frameworks.</p> <p>Fork Instance Context encompasses <code>.github/template-workflows/</code> for production fork management workflows, instance-specific configuration and customization, and upstream-specific synchronization and integration.</p> <p>Event-Driven Architecture enables intelligent automation through GitHub's native event system. The system responds to scheduled events (daily sync), change events (PR validation), and manual events (on-demand resolution), providing comprehensive lifecycle management.</p> <p>Architectural Success Pattern</p> <p>The combination of template-driven deployment with event-driven automation creates a self-managing system that scales across unlimited fork instances while maintaining consistent behavior and zero-configuration operation.</p> <p>System Components provide comprehensive automation through three specialized layers that work together to deliver enterprise-grade fork management capabilities.</p> <ul> <li> <p> Three-Branch Strategy</p> <p>Isolated conflict resolution and controlled integration from upstream through staging to production environments.</p> <p> Learn about branch strategy</p> </li> </ul> <ul> <li> <p> Workflow System</p> <p>Event-driven automation with AI-enhanced capabilities for synchronization, validation, and release management.</p> <p> Explore workflow architecture</p> </li> </ul> <ul> <li> <p> AI Integration</p> <p>Multi-provider AI support with intelligent analysis, automated documentation, and fallback strategies.</p> <p> Discover AI capabilities</p> </li> </ul>"},{"location":"architecture/overview/#enterprise-capabilities","title":"Enterprise Capabilities","text":"<p>The system delivers enterprise-grade features through comprehensive security, proven scalability patterns, and native GitHub integration. Branch protection strategies ensure production stability while enabling flexible conflict resolution workflows.</p> <p>Enterprise Ready</p> <p>Production deployments benefit from automated security scanning, unlimited scalability through template propagation, and seamless integration with existing development toolchains and AI services.</p>"},{"location":"architecture/three_branch_strategy/","title":"Three-Branch Strategy","text":"<p>The three-branch strategy forms the cornerstone of safe, systematic fork management in the OSDU SPI Fork Management system. This architectural pattern provides controlled integration checkpoints that prevent cascade failures while enabling continuous upstream synchronization.</p>"},{"location":"architecture/three_branch_strategy/#branch-architecture","title":"Branch Architecture","text":"<pre><code>graph TD\n    A[Upstream Repository] --&gt; B[fork_upstream&lt;br/&gt;Mirror]\n    B --&gt; C[fork_integration&lt;br/&gt;Staging]  \n    C --&gt; D[main&lt;br/&gt;Production]\n\n    E[Local Development] --&gt; F[Feature Branches]\n    F --&gt; D\n\n    style A fill:#e1f5fe,stroke:#01579b,stroke-width:2px\n    style B fill:#fff3e0,stroke:#e65100,stroke-width:2px\n    style C fill:#fce4ec,stroke:#c2185b,stroke-width:2px\n    style D fill:#e8f5e9,stroke:#1b5e20,stroke-width:2px\n    style E fill:#f3e5f5,stroke:#4a148c,stroke-width:2px\n    style F fill:#f3e5f5,stroke:#4a148c,stroke-width:2px</code></pre>"},{"location":"architecture/three_branch_strategy/#branch-purposes","title":"Branch Purposes","text":"<ul> <li> <p> <code>main</code> - Production Branch</p> <p>Stable production branch containing successfully integrated changes</p> <ul> <li>Maximum security with required PR reviews</li> <li>Production-ready Azure SPI implementations  </li> <li>Updates only through validated pull requests from <code>fork_integration</code></li> <li>All changes must pass comprehensive validation</li> </ul> </li> </ul> <ul> <li> <p> <code>fork_upstream</code> - Upstream Mirror</p> <p>Clean tracking of upstream OSDU repository without local modifications</p> <ul> <li>Automation-only updates to maintain purity</li> <li>Exact mirror of upstream repository state</li> <li>Automated synchronization from upstream repository</li> <li>Enables clear diff analysis and change detection</li> </ul> </li> </ul> <ul> <li> <p> <code>fork_integration</code> - Integration Workspace</p> <p>Dedicated space for conflict resolution and comprehensive validation</p> <ul> <li>Flexible protection for conflict resolution workflows</li> <li>Merge workspace for upstream changes with local modifications</li> <li>Automated merges from <code>fork_upstream</code> with conflict resolution</li> <li>Complete build, test, and security scanning before production</li> </ul> </li> </ul>"},{"location":"architecture/three_branch_strategy/#process-flow","title":"Process Flow","text":""},{"location":"architecture/three_branch_strategy/#synchronize","title":"Synchronize","text":"<pre><code>sequenceDiagram\n    participant U as Upstream Repo\n    participant FU as fork_upstream\n    participant S as Sync Workflow\n    participant SM as Sync State Manager\n    participant H as Human Reviewer\n\n    S-&gt;&gt;U: Fetch latest changes\n    S-&gt;&gt;SM: Check existing sync PRs and upstream SHA\n    SM-&gt;&gt;SM: Compare with stored last-sync state\n\n    alt New upstream changes, no existing PR\n        S-&gt;&gt;FU: Create new sync branch from fork_upstream\n        activate FU\n        S-&gt;&gt;S: Generate AI analysis\n        S-&gt;&gt;S: Create new sync PR and issue\n        S-&gt;&gt;H: Notify human reviewer\n    else Upstream advanced, existing PR open\n        S-&gt;&gt;FU: Update existing sync branch (force push)\n        S-&gt;&gt;S: Update PR title and description\n        S-&gt;&gt;S: Add progress comment to existing issue\n        S-&gt;&gt;H: Update notification on existing issue\n    else Duplicate detected (same upstream SHA)\n        S-&gt;&gt;S: Add reminder comment to existing issue\n        S-&gt;&gt;H: Gentle reminder notification\n    else No changes detected\n        S-&gt;&gt;S: Exit - no action needed\n    end\n\n    opt Human approval received\n        H-&gt;&gt;H: Review and approve\n        H-&gt;&gt;FU: Merge sync branch into fork_upstream\n        SM-&gt;&gt;SM: Update stored sync state\n        SM-&gt;&gt;SM: Cleanup completed sync artifacts\n        deactivate FU\n    end</code></pre> <p>Sync State Management</p> <p>The synchronization process includes intelligent duplicate prevention that maintains sync continuity. The Sync State Manager tracks upstream SHA, active PR numbers, and issue state between runs to prevent duplicate PRs and maintain human workflow continuity. When upstream advances while a PR is open, the existing branch is updated rather than creating duplicates.</p>"},{"location":"architecture/three_branch_strategy/#integrate","title":"Integrate","text":"<pre><code>sequenceDiagram\n    participant M as main\n    participant FU as fork_upstream\n    participant FI as fork_integration\n    participant C as Cascade Workflow\n    participant H as Human Reviewer\n\n    C-&gt;&gt;M: Check for local changes\n    M-&gt;&gt;FI: Merge main \u2192 fork_integration\n    activate FI\n    C-&gt;&gt;FU: Check for upstream updates\n    FU-&gt;&gt;FI: Merge fork_upstream \u2192 fork_integration\n    C-&gt;&gt;FI: Run validation suite\n    C-&gt;&gt;C: Create main PR\n\n    alt Validation Conflicts/Failures\n        C-&gt;&gt;C: Create conflict resolution issue\n        C-&gt;&gt;H: Notify about conflicts\n        H-&gt;&gt;FI: Push conflict resolution to fork_integration\n    end\n\n    C-&gt;&gt;FI: Run validation suite\n    C-&gt;&gt;H: Notify human reviewer\n    H-&gt;&gt;H: Review and approve\n    FI-&gt;&gt;M: Merge to main\n    deactivate FI</code></pre>"},{"location":"architecture/three_branch_strategy/#release","title":"Release","text":"<pre><code>sequenceDiagram\n    participant M as main\n    participant R as Release Workflow\n    participant H as Human Reviewer\n    participant DR as Downstream Repo\n\n    M-&gt;&gt;R: Push to main triggers release\n    R-&gt;&gt;R: Analyze commits for version bump\n    R-&gt;&gt;M: Create release branch with CHANGELOG.md\n    activate M\n    R-&gt;&gt;H: Create release PR\n    R-&gt;&gt;M: Run validation suite\n    H-&gt;&gt;H: Review and approve\n    H-&gt;&gt;M: Merge release branch into main\n    deactivate M\n    R-&gt;&gt;R: Create release &amp; tags\n\n    alt Downstream Consumption\n        DR-&gt;&gt;M: Pull desired release tag\n    end</code></pre>"},{"location":"architecture/three_branch_strategy/#safety-mechanisms","title":"Safety Mechanisms","text":""},{"location":"architecture/three_branch_strategy/#branch-protection-rules","title":"Branch Protection Rules","text":"Protection Setting main fork_upstream fork_integration Required Reviews 1 minimum Not required Not required Status Checks All workflows Not required Validation only Up-to-date Branch Required Not enforced Not enforced Force Push Blocked Allowed Allowed Human Access PR only Blocked Direct push"},{"location":"architecture/three_branch_strategy/#quality-gates","title":"Quality Gates","text":"<p>Integration Validation</p> <p>\u2713 Build Verification: Complete compilation and dependency resolution \u2713 Test Execution: Full test suite including integration tests \u2713 Security Scanning: Automated vulnerability and compliance checks \u2713 Code Quality: Linting and code quality metrics verification</p> <p>Production Validation</p> <p>\u26a0\ufe0f Human Review: Manual approval for all production changes \u26a0\ufe0f Impact Assessment: Analysis of changes to Azure SPI implementations \u26a0\ufe0f Rollback Planning: Verification of rollback procedures if needed \u26a0\ufe0f Documentation: Change documentation and release notes</p>"},{"location":"architecture/three_branch_strategy/#workflow-benefits","title":"Workflow Benefits","text":"<ul> <li> <p> Conflict Isolation</p> <p>Merge conflicts are resolved in the dedicated <code>fork_integration</code> branch, preventing disruption to the stable <code>main</code> branch during resolution.</p> </li> <li> <p> Clear Change Attribution</p> <p>Easy identification of what changes originate from upstream versus local Azure SPI modifications through clean branch separation.</p> </li> <li> <p> Multi-Stage Validation</p> <p>Multiple review and validation points ensure problematic changes are caught before reaching production systems.</p> </li> <li> <p> Upstream Tracking</p> <p>Pure upstream branch enables accurate diff analysis, change detection, and impact assessment for each synchronization.</p> </li> <li> <p> Rollback Capability</p> <p>Easy reversion of problematic integrations without losing upstream synchronization state or affecting ongoing development.</p> </li> <li> <p> Branch Preservation</p> <p>All three branches are permanently preserved, maintaining historical state for analysis and providing continuous availability.</p> </li> </ul>"},{"location":"architecture/three_branch_strategy/#operational-patterns","title":"Operational Patterns","text":""},{"location":"architecture/three_branch_strategy/#daily-synchronization-cycle","title":"Daily Synchronization Cycle","text":"<p>Automated Processing:</p> <p> Step 1: Check Upstream - Daily automated check for new upstream changes Step 2: Sync Detection - AI-enhanced analysis of change scope and impact Step 3: Integration Attempt - Automated merge to integration branch Step 4: Validation Execution - Comprehensive testing and security scanning</p> <p>Human Intervention Points:</p> <p> Step 1: Conflict Resolution - Manual resolution when automated merge fails Step 2: Validation Review - Assessment of test results and security findings Step 3: Production Approval - Final authorization for changes to reach <code>main</code> Step 4: Release Coordination - Alignment with downstream system requirements</p>"},{"location":"architecture/three_branch_strategy/#emergency-procedures","title":"Emergency Procedures","text":""},{"location":"architecture/three_branch_strategy/#upstream-rollback","title":"Upstream Rollback","text":"<p>If upstream changes cause issues: 1. Identify last known good state in <code>fork_upstream</code> 2. Create rollback branch from previous stable point 3. Update <code>fork_integration</code> with rollback changes 4. Execute normal validation and approval process</p>"},{"location":"architecture/three_branch_strategy/#production-hotfix","title":"Production Hotfix","text":"<p>For urgent Azure SPI fixes: 1. Create hotfix branch from current <code>main</code> 2. Implement and test fix in isolation 3. Fast-track through integration validation 4. Deploy with minimal upstream integration delay</p> <p>Release Strategy</p> <p>For production deployments, temporary release branches (<code>release/upstream-YYYYMMDD-HHMMSS</code>) are created from <code>fork_integration</code> to <code>main</code>, allowing safe cleanup while preserving the three-branch core architecture.</p>"},{"location":"architecture/workflow_system/","title":"Workflow System Architecture","text":"<p>The OSDU SPI Fork Management system implements a sophisticated workflow architecture that separates template development concerns from fork production operations. This design enables scalable deployment across multiple fork instances while maintaining centralized template management.</p>"},{"location":"architecture/workflow_system/#workflow-architecture-pattern","title":"Workflow Architecture Pattern","text":""},{"location":"architecture/workflow_system/#template-workflows-separation","title":"Template-Workflows Separation","text":"<p>The system implements a clean separation between template development and fork production workflows:</p> <pre><code>graph TD\n    A[Template Repository] --&gt; B[.github/workflows/&lt;br/&gt;Template Development]\n    A --&gt; C[.github/template-workflows/&lt;br/&gt;Fork Production]\n\n    C --&gt; D[Fork Instance 1&lt;br/&gt;.github/workflows/]\n    C --&gt; E[Fork Instance 2&lt;br/&gt;.github/workflows/]\n    C --&gt; F[Fork Instance N&lt;br/&gt;.github/workflows/]\n\n    style A fill:#e1f5fe,stroke:#01579b,stroke-width:2px\n    style B fill:#fff3e0,stroke:#e65100,stroke-width:2px\n    style C fill:#f3e5f5,stroke:#4a148c,stroke-width:2px\n    style D fill:#e8f5e9,stroke:#1b5e20,stroke-width:2px\n    style E fill:#e8f5e9,stroke:#1b5e20,stroke-width:2px\n    style F fill:#e8f5e9,stroke:#1b5e20,stroke-width:2px</code></pre> <ul> <li> <p> Template Development Context</p> <p><code>.github/workflows/</code> - Template management and maintenance</p> <ul> <li>Repository initialization and bootstrap workflows</li> <li>Template testing and validation workflows</li> <li>Template versioning and release management</li> <li>Development CI/CD pipelines</li> </ul> </li> </ul> <ul> <li> <p> Fork Production Context</p> <p><code>.github/template-workflows/</code> - Production fork operations</p> <ul> <li>Upstream synchronization workflows</li> <li>Build and validation workflows  </li> <li>Release management for fork instances</li> <li>Monitoring and maintenance workflows</li> </ul> </li> </ul>"},{"location":"architecture/workflow_system/#core-workflow-categories","title":"Core Workflow Categories","text":""},{"location":"architecture/workflow_system/#synchronization-workflows","title":"Synchronization Workflows","text":"<ul> <li> <p> Daily Upstream Sync (<code>sync.yml</code>)</p> <p>AI-powered daily synchronization with intelligent duplicate prevention that fetches upstream changes, analyzes them for conflicts, and creates integration PRs with conventional commit messages</p> <ul> <li>Trigger: Scheduled daily at midnight UTC with intelligent duplicate prevention</li> <li>State Management: Tracks sync state between runs to prevent duplicate PRs and issues</li> <li>Decision Logic: Updates existing branches when upstream advances, prevents duplicates for same SHA</li> <li>Integration: Three-branch safety pattern (fork_upstream \u2192 fork_integration \u2192 main)</li> <li>AI Features: Intelligent change analysis and conventional commit generation</li> <li>Conflict Handling: Automated detection with human-guided resolution</li> </ul> <p> Detailed spec</p> </li> </ul> <ul> <li> <p> Template Propagation (<code>sync-template.yml</code>)</p> <p>Distributes template improvements across multiple fork instances with selective synchronization and automated validation</p> <ul> <li>Trigger: Weekly scheduled execution on Mondays at 8 AM UTC</li> <li>Scope: Selective file synchronization based on configuration rules</li> <li>Safety: Automated testing and validation before deployment</li> <li>Scalability: Supports unlimited fork instances with consistent patterns</li> </ul> <p> Detailed spec</p> </li> </ul>"},{"location":"architecture/workflow_system/#validation-workflows","title":"Validation Workflows","text":"<ul> <li> <p> Pull Request Validation (<code>validate.yml</code>)</p> <p>Comprehensive quality assurance system that enforces code standards, verifies build integrity, and ensures consistency across all changes</p> <ul> <li>Quality Gates: Multi-phase validation pipeline with adaptive rules</li> <li>Scope: Commit format, branch naming, build verification, conflict detection</li> <li>Intelligence: Context-aware validation for different contribution types</li> <li>Feedback: Detailed status reporting with actionable developer guidance</li> </ul> <p> Detailed spec</p> </li> </ul> <ul> <li> <p> Dependabot Automation (<code>dependabot-validation.yml</code>)</p> <p>Automated dependency update validation with intelligent risk assessment and selective auto-merging for routine updates</p> <ul> <li>Automation: Validates and tests all Dependabot dependency updates</li> <li>Security: Comprehensive vulnerability assessment of new dependencies</li> <li>Intelligence: Risk-based auto-merging for low-impact updates</li> <li>Integration: Seamless coordination with main validation pipeline</li> </ul> <p> Detailed spec</p> </li> </ul>"},{"location":"architecture/workflow_system/#build-release-workflows","title":"Build &amp; Release Workflows","text":"<ul> <li> <p> Project Build (<code>build.yml</code>)</p> <p>Feature branch build verification with comprehensive testing, coverage analysis, and performance-optimized execution</p> <ul> <li>Focus: Rapid developer feedback for feature branch development</li> <li>Coverage: Unit tests, integration tests, and comprehensive quality metrics</li> <li>Performance: Intelligent caching and parallel execution strategies</li> <li>Support: Java/Maven projects with extensible patterns for other languages</li> </ul> <p> Detailed spec</p> </li> </ul> <ul> <li> <p> Semantic Release (<code>release.yml</code>)</p> <p>Automated semantic versioning with conventional commit analysis, changelog generation, and coordinated release distribution</p> <ul> <li>Versioning: Release Please integration with conventional commit standards</li> <li>Coordination: Upstream version tracking and alignment strategies</li> <li>Documentation: Automated changelog and release notes generation</li> <li>Distribution: Package publication and artifact management</li> </ul> <p> Detailed spec</p> </li> </ul>"},{"location":"architecture/workflow_system/#cascade-workflows","title":"Cascade Workflows","text":"<ul> <li> <p> Integration Cascade (<code>cascade.yml</code>)</p> <p>Multi-stage integration workflow that safely promotes changes through the three-branch strategy with comprehensive validation</p> <ul> <li>Flow: Systematic progression from fork_upstream \u2192 fork_integration \u2192 main</li> <li>Safety: Comprehensive testing and validation at each integration stage</li> <li>Flexibility: Manual execution with automated monitoring capabilities</li> <li>Tracking: Complete progress monitoring through GitHub Issues</li> </ul> <p> Detailed spec</p> </li> </ul> <ul> <li> <p> Cascade Monitoring (<code>cascade-monitor.yml</code>)</p> <p>Intelligent monitoring system that detects completed synchronizations and automatically triggers cascade operations with SLA management</p> <ul> <li>Detection: Automated monitoring for completed upstream synchronizations</li> <li>SLA Management: Ensures cascade operations meet timing requirements</li> <li>Escalation: Proactive alerts and notifications for overdue operations</li> <li>Recovery: Automatic retry mechanisms with intelligent backoff strategies</li> </ul> <p> Detailed spec</p> </li> </ul>"},{"location":"architecture/workflow_system/#ai-enhanced-integration-workflows","title":"AI-Enhanced Integration Workflows","text":""},{"location":"architecture/workflow_system/#cross-platform-integration","title":"Cross-Platform Integration","text":"<ul> <li> <p> OSDU GitLab Integration (<code>osdu-alfi.yml</code>)</p> <p>AI-powered cross-platform workflow that enables seamless GitHub-to-GitLab contribution for OSDU community repositories</p> <ul> <li>Trigger: <code>@alfi</code> mentions in GitHub PR reviews, issue comments, or new issues</li> <li>AI Integration: Claude Code CLI with GitLab MCP server for intelligent automation</li> <li>Cross-Platform Sync: Creates GitLab branches and merge requests from GitHub context</li> <li>OSDU Targeting: Specialized support for <code>community.opengroup.org</code> GitLab instance</li> </ul> <p> Learn about cross-platform AI</p> </li> </ul> <p>AI-Enhanced Extensions</p> <p>These workflows extend the core fork management system with AI-powered capabilities that bridge platforms and enhance developer productivity. They operate alongside the core workflows without disrupting the fundamental three-branch strategy.</p>"},{"location":"architecture/workflow_system/#workflow-event-architecture","title":"Workflow Event Architecture","text":""},{"location":"architecture/workflow_system/#event-driven-triggers","title":"Event-Driven Triggers","text":"<pre><code>graph LR\n    A[Schedule Events] --&gt; B[Workflow Triggers]\n    C[Repository Events] --&gt; B\n    D[Manual Events] --&gt; B\n\n    B --&gt; E[Sync Workflows]\n    B --&gt; F[Validation Workflows]\n    B --&gt; G[Build Workflows]\n    B --&gt; H[Cascade Workflows]\n\n    style A fill:#e1f5fe,stroke:#01579b,stroke-width:2px\n    style C fill:#fff3e0,stroke:#e65100,stroke-width:2px\n    style D fill:#f3e5f5,stroke:#4a148c,stroke-width:2px</code></pre> Trigger Type Workflow Schedule/Event Description Scheduled Daily Sync <code>0 0 * * *</code> Midnight UTC upstream synchronization with duplicate prevention Scheduled Template Sync <code>0 8 * * 1</code> Monday 8 AM UTC template updates Scheduled Monitoring <code>0 */6 * * *</code> 6-hour cascade monitoring Event-Based PR Validation PR creation/updates Validation workflows on pull requests Event-Based Cascade Trigger Issue creation Cascade triggering on sync completion Event-Based Build Push to main Build workflows on main branch updates Event-Based Release Tag creation Distribution workflows on releases AI-Triggered GitLab Integration <code>@alfi</code> mentions Cross-platform GitLab MR creation from GitHub Manual Emergency Sync On-demand Immediate upstream synchronization Manual Cascade Override On-demand Manual cascade operation initiation Manual Template Update On-demand Immediate template propagation Manual Validation Retry On-demand Re-execution of failed workflows"},{"location":"architecture/workflow_system/#workflow-integration-patterns","title":"Workflow Integration Patterns","text":""},{"location":"architecture/workflow_system/#ai-enhanced-automation","title":"AI-Enhanced Automation","text":"<ul> <li> <p> Claude (Anthropic)</p> <p>Primary AI provider for analysis and generation with comprehensive reasoning capabilities</p> </li> <li> <p> Azure OpenAI</p> <p>Enterprise alternative with Microsoft integration and compliance features</p> </li> <li> <p> OpenAI GPT-4</p> <p>Fallback option providing comprehensive coverage and established performance baselines</p> </li> </ul> <p>AI-Powered Capabilities enhance every stage of the workflow system:</p> <ul> <li>Change Analysis: Intelligent assessment of upstream modifications</li> <li>Commit Generation: Conventional commit message creation</li> <li>PR Descriptions: Comprehensive pull request documentation</li> <li>Conflict Guidance: Step-by-step conflict resolution instructions</li> </ul>"},{"location":"architecture/workflow_system/#security-integration","title":"Security Integration","text":"<p>Security-First Approach</p> <p>All workflows integrate comprehensive security scanning and branch protection to ensure production stability and compliance.</p> <ul> <li> <p> Automated Security Scanning</p> <ul> <li>Trivy scanning for container and dependency vulnerabilities</li> <li>Secret detection and automated leak prevention</li> <li>GitHub security advisory integration</li> <li>Automated compliance rule validation</li> </ul> </li> <li> <p> Branch Protection Integration</p> <ul> <li>Required workflow completion before merge</li> <li>Mandatory human approval for production changes</li> <li>Prevention of unauthorized direct pushes</li> <li>Controlled override procedures for critical issues</li> </ul> </li> </ul>"},{"location":"architecture/workflow_system/#workflow-state-management","title":"Workflow State Management","text":""},{"location":"architecture/workflow_system/#issue-based-tracking","title":"Issue-Based Tracking","text":""},{"location":"architecture/workflow_system/#lifecycle-management","title":"Lifecycle Management","text":"<ul> <li>State Tracking: GitHub Issues for workflow state management</li> <li>Progress Updates: Automated status updates throughout workflow execution</li> <li>Error Reporting: Detailed failure analysis and resolution guidance</li> <li>Audit Trail: Complete record of all workflow operations</li> </ul>"},{"location":"architecture/workflow_system/#label-based-organization","title":"Label-Based Organization","text":"<ul> <li>Workflow Types: <code>upstream-sync</code>, <code>cascade-active</code>, <code>template-update</code></li> <li>Status Indicators: <code>in-progress</code>, <code>completed</code>, <code>requires-attention</code></li> <li>Priority Levels: <code>high-priority</code>, <code>critical</code>, <code>routine</code></li> <li>Assignment Strategy: <code>human-required</code> for manual intervention points</li> </ul>"},{"location":"architecture/workflow_system/#performance-optimization","title":"Performance Optimization","text":"<ul> <li> <p> Intelligent Caching</p> <ul> <li>Maven dependencies, Node modules, Docker layers</li> <li>Compiled assets and test results</li> <li>Upstream repository metadata</li> <li>Previously generated AI analysis results</li> </ul> </li> <li> <p> Resource Management</p> <ul> <li>Concurrent workflow execution where safe</li> <li>Intelligent scheduling to prevent resource contention</li> <li>Appropriate timeouts with graceful degradation</li> <li>Exponential backoff for transient failures</li> </ul> </li> </ul>"},{"location":"architecture/workflow_system/#workflow-extensibility","title":"Workflow Extensibility","text":""},{"location":"architecture/workflow_system/#custom-action-integration","title":"Custom Action Integration","text":""},{"location":"architecture/workflow_system/#reusable-actions","title":"Reusable Actions","text":"<ul> <li>Enhanced PR Creation: AI-powered pull request generation</li> <li>Java Build Status: Specialized build reporting for Maven projects</li> <li>Security Scanning: Standardized vulnerability assessment</li> <li>Notification Management: Intelligent alert distribution</li> </ul>"},{"location":"architecture/workflow_system/#extension-points","title":"Extension Points","text":"<ul> <li>Project Type Detection: Automatic workflow adaptation based on project type</li> <li>Custom Validation: Project-specific quality gates and testing</li> <li>Integration Hooks: External system integration capabilities</li> <li>Notification Customization: Flexible alert and reporting mechanisms</li> </ul>"},{"location":"decisions/","title":"Architecture Decision Records","text":"<p> 23 ADRs |  Design rationale |  Evolution timeline</p> <p>This catalog documents the architectural decisions that shape the OSDU SPI Fork Management system. Each Architecture Decision Record (ADR) captures the context, decision, and consequences of significant design choices that enable automated management of long-lived upstream forks.</p>"},{"location":"decisions/#decision-categories","title":"Decision Categories","text":""},{"location":"decisions/#core-architecture","title":"Core Architecture","text":"<p>Foundation decisions that define the system's structure and approach:</p> ADR Decision Impact Status 001 Three-Branch Strategy  Critical  Accepted 002 GitHub Actions Automation  Critical  Accepted 003 Template Repository Pattern  Critical  Accepted 005 Conflict Management Strategy  Critical  Accepted"},{"location":"decisions/#workflow-design","title":"Workflow Design","text":"<p>Decisions governing workflow behavior and integration patterns:</p> ADR Decision Impact Status 006 Two-Workflow Initialization  High  Accepted 014 AI-Enhanced Workflows  High  Accepted 019 Cascade Monitor Pattern  High  Accepted 020 Human-Required Labels  High  Accepted 023 Meta Commit Strategy  High  Accepted"},{"location":"decisions/#implementation-details","title":"Implementation Details","text":"<p>Technical implementation and optimization decisions:</p> ADR Decision Impact Status 008 Centralized Label Management  Medium  Accepted 009 Asymmetric Cascade Review  Medium  Accepted 010 YAML-Safe Shell Scripting  Medium  Accepted 013 Reusable GitHub Actions  Medium  Accepted 015 Template-Workflows Separation  Medium  Accepted 021 Pull Request Target Pattern  Medium  Accepted 022 Issue Lifecycle Tracking  Medium  Accepted"},{"location":"decisions/#template-management","title":"Template Management","text":"<p>Decisions for template updates and synchronization:</p> ADR Decision Impact Status 011 Configuration-Driven Sync  High  Accepted 012 Template Update Propagation  High  Accepted 018 Fork-Resources Staging  Medium  Accepted"},{"location":"decisions/#release-management","title":"Release Management","text":"<p>Version management and release automation decisions:</p> ADR Decision Impact Status 004 Release Please Versioning  High  Accepted"},{"location":"decisions/#security-operations","title":"Security &amp; Operations","text":"<p>Security, monitoring, and operational decisions:</p> ADR Decision Impact Status 016 Initialization Security  Medium  Accepted 017 MCP Server Integration  Medium  Accepted"},{"location":"decisions/#development-process","title":"Development Process","text":"<p>Development workflow and bootstrap decisions:</p> ADR Decision Impact Status 007 Workflow Bootstrap Pattern  Medium  Proposed"},{"location":"decisions/#decision-timeline","title":"Decision Timeline","text":""},{"location":"decisions/#2025-evolution","title":"2025 Evolution","text":"<p>May 2025 - Foundation Phase - ADR-001 through ADR-006: Core architecture and workflow patterns established - Three-branch strategy and GitHub Actions automation chosen - Two-workflow initialization pattern for improved UX</p> <p>June 2025 - Enhancement Phase - ADR-008 through ADR-015: Implementation optimizations and AI integration - Centralized label management and reusable actions - AI-enhanced workflows with multi-provider support</p> <p>June 2025 - Reliability Phase - ADR-019 through ADR-023: Monitoring and reliability improvements - Cascade monitor pattern for robust triggering - Meta commit strategy for Release Please integration</p> <p>January 2025 - Security &amp; Integration Phase - ADR-016 through ADR-018: Security handling and MCP integration - Fork-resources staging pattern for specialized deployment</p>"},{"location":"decisions/#quick-reference-guide","title":"Quick Reference Guide","text":""},{"location":"decisions/#key-architectural-principles","title":"Key Architectural Principles","text":"<p>Three-Branch Safety: All changes flow through <code>fork_upstream</code> \u2192 <code>fork_integration</code> \u2192 <code>main</code> with validation at each stage.</p> <p>Human-Centric Automation: Automation enhances human workflows rather than replacing human judgment, with clear escalation paths.</p> <p>AI Enhancement: AI capabilities improve workflow quality while maintaining reliable fallback mechanisms.</p> <p>Template Pattern: Repository templates enable consistent deployment with automated updates and configuration.</p>"},{"location":"decisions/#common-decision-patterns","title":"Common Decision Patterns","text":"<p>Event-Driven Architecture: Workflows trigger based on GitHub events with monitoring for missed triggers.</p> <p>Label-Based State Management: GitHub labels provide machine-readable state with human-friendly interfaces.</p> <p>Multi-Provider Resilience: Critical integrations support multiple providers to prevent single points of failure.</p> <p>Configuration-Driven Behavior: JSON configuration files control workflow behavior without code changes.</p>"},{"location":"decisions/#impact-assessment","title":"Impact Assessment","text":"<p> Critical Decisions: Fundamental to system operation - changes require careful migration planning.</p> <p> High Impact: Significant workflow effects - changes affect multiple components.</p> <p> Medium Impact: Localized improvements - changes have bounded effects.</p>"},{"location":"decisions/#using-this-catalog","title":"Using This Catalog","text":""},{"location":"decisions/#finding-relevant-adrs","title":"Finding Relevant ADRs","text":"<p>By Problem Area: Use the category sections above to find decisions related to specific system areas.</p> <p>By Timeline: Review the evolution timeline to understand how decisions built upon each other.</p> <p>By Impact: Focus on Critical and High Impact decisions for understanding core system behavior.</p>"},{"location":"decisions/#cross-references","title":"Cross-References","text":"<p>Most ADRs reference related decisions - follow these links to understand the full context of architectural choices.</p>"},{"location":"decisions/#staying-current","title":"Staying Current","text":"<p>ADRs are living documents that may be superseded by new decisions. Check the status field and look for newer ADRs that reference older ones.</p> <p>These architectural decisions collectively enable the automated management of OSDU SPI forks while maintaining reliability, security, and team productivity.</p>"},{"location":"decisions/adr_001_three_branch_strategy/","title":"ADR-001: Three-Branch Fork Management Strategy","text":"<p> Critical Decision |  2025-05-28 |  Accepted</p>"},{"location":"decisions/adr_001_three_branch_strategy/#problem-statement","title":"Problem Statement","text":"<p>When maintaining long-lived forks of upstream repositories, teams face significant challenges balancing upstream synchronization with local modifications. Traditional forking approaches often result in complex merge conflicts, difficulty tracking changes, and unstable release branches that impact team productivity and system reliability.</p>"},{"location":"decisions/adr_001_three_branch_strategy/#context-and-requirements","title":"Context and Requirements","text":""},{"location":"decisions/adr_001_three_branch_strategy/#system-requirements","title":"System Requirements","text":"<p>The fork management system must support:</p> <ul> <li>Regular Upstream Sync: Automated synchronization with upstream repositories</li> <li>Modification Isolation: Clear separation between upstream and local changes  </li> <li>Safe Conflict Resolution: Controlled workflow for handling merge conflicts</li> <li>Stable Release Management: Reliable production branch maintenance</li> <li>Change Traceability: Clear attribution and tracking of all modifications</li> </ul>"},{"location":"decisions/adr_001_three_branch_strategy/#current-challenges","title":"Current Challenges","text":"<p>Traditional Forking Issues: - Merge conflicts occur directly on production branches - Difficulty distinguishing upstream changes from local modifications - Complex conflict resolution disrupts ongoing development - No dedicated validation space for upstream changes - Risk of breaking stable branches during integration</p>"},{"location":"decisions/adr_001_three_branch_strategy/#decision","title":"Decision","text":"<p>Implement a three-branch strategy that provides clear separation of concerns and safe integration pathways:</p> <pre><code>graph TD\n    A[Upstream Repository] --&gt; B[fork_upstream]\n    B --&gt; C[fork_integration]\n    C --&gt; D[main]\n\n    style A fill:#e1f5fe,stroke:#01579b,stroke-width:2px\n    style B fill:#fff3e0,stroke:#e65100,stroke-width:2px\n    style C fill:#fce4ec,stroke:#c2185b,stroke-width:2px\n    style D fill:#e8f5e9,stroke:#1b5e20,stroke-width:2px</code></pre>"},{"location":"decisions/adr_001_three_branch_strategy/#branch-architecture","title":"Branch Architecture","text":""},{"location":"decisions/adr_001_three_branch_strategy/#main-production-branch","title":"<code>main</code> - Production Branch","text":"<ul> <li>Purpose: Stable production branch containing successfully integrated changes</li> <li>Protection: Only receives changes through reviewed pull requests</li> <li>Content: Fully validated and tested integrated codebase</li> </ul>"},{"location":"decisions/adr_001_three_branch_strategy/#fork_upstream-upstream-tracking-branch","title":"<code>fork_upstream</code> - Upstream Tracking Branch","text":"<ul> <li>Purpose: Clean mirror of upstream repository's main branch</li> <li>Content: Pure upstream changes without local modifications</li> <li>Automation: Updated automatically by sync workflows</li> </ul>"},{"location":"decisions/adr_001_three_branch_strategy/#fork_integration-validation-workspace","title":"<code>fork_integration</code> - Validation Workspace","text":"<ul> <li>Purpose: Dedicated space for conflict resolution and comprehensive testing</li> <li>Function: Safe environment for validating upstream changes before production</li> <li>Validation: Complete build, test, and quality assurance execution</li> </ul>"},{"location":"decisions/adr_001_three_branch_strategy/#implementation-strategy","title":"Implementation Strategy","text":""},{"location":"decisions/adr_001_three_branch_strategy/#branch-protection-configuration","title":"Branch Protection Configuration","text":"<pre><code># Branch protection rules\nmain:\n  protection:\n    - required_status_checks: strict\n    - required_pull_request_reviews: 1\n    - dismiss_stale_reviews: true\n    - enforce_admins: false\n    - allow_force_pushes: false\n\nfork_upstream:\n  protection:\n    - automation_only: true\n    - direct_push_allowed: sync_workflows\n\nfork_integration:\n  protection:\n    - conflict_resolution_access: true\n    - validation_required: true\n</code></pre>"},{"location":"decisions/adr_001_three_branch_strategy/#material-workflow-integration-workflow","title":":material-workflow: Integration Workflow","text":""},{"location":"decisions/adr_001_three_branch_strategy/#phase-1-upstream-synchronization","title":"Phase 1: Upstream Synchronization","text":"<ol> <li>Automated Sync: Sync workflow updates <code>fork_upstream</code> with latest upstream changes</li> <li>Change Detection: Compare <code>fork_upstream</code> with current state to identify new changes</li> <li>Sync Notification: Create tracking issue for new upstream changes</li> </ol>"},{"location":"decisions/adr_001_three_branch_strategy/#phase-2-integration-validation","title":"Phase 2: Integration Validation","text":"<ol> <li>Branch Preparation: Merge <code>main</code> into <code>fork_integration</code> to include latest local changes</li> <li>Upstream Integration: Merge <code>fork_upstream</code> into <code>fork_integration</code></li> <li>Conflict Detection: Identify and isolate any merge conflicts</li> <li>Comprehensive Validation: Execute full build, test, and quality checks</li> </ol>"},{"location":"decisions/adr_001_three_branch_strategy/#phase-3-production-release","title":"Phase 3: Production Release","text":"<ol> <li>Validation Gate: Block progression if any validation failures detected</li> <li>Release Branch: Create temporary release branch from validated <code>fork_integration</code></li> <li>Production PR: Submit pull request from release branch to <code>main</code></li> <li>Manual Review: Require human approval for all production changes</li> </ol>"},{"location":"decisions/adr_001_three_branch_strategy/#branch-preservation-strategy","title":"Branch Preservation Strategy","text":""},{"location":"decisions/adr_001_three_branch_strategy/#critical-requirement-permanent-branch-preservation","title":"Critical Requirement: Permanent Branch Preservation","text":"<p>All three core branches must be permanently maintained:</p> <ul> <li><code>main</code>: Production branch - never delete</li> <li><code>fork_upstream</code>: Upstream tracking - required for future synchronization</li> <li><code>fork_integration</code>: Integration workspace - needed for ongoing conflict resolution</li> </ul>"},{"location":"decisions/adr_001_three_branch_strategy/#temporary-branch-pattern","title":"Temporary Branch Pattern","text":"<p>For production releases, use temporary branches to preserve core architecture:</p> <pre><code># Create temporary release branch from validated integration\ngit checkout fork_integration\ngit checkout -b release/upstream-$(date +%Y%m%d-%H%M%S)\n\n# Create PR to main using temporary branch\ngh pr create --base main --head release/upstream-...\n\n# After merge, safely delete temporary branch\ngit branch -d release/upstream-...\n</code></pre>"},{"location":"decisions/adr_001_three_branch_strategy/#rationale-and-benefits","title":"Rationale and Benefits","text":""},{"location":"decisions/adr_001_three_branch_strategy/#strategic-advantages","title":"Strategic Advantages","text":""},{"location":"decisions/adr_001_three_branch_strategy/#change-attribution-and-clarity","title":"Change Attribution and Clarity","text":"<ul> <li>Clear Separation: Easy identification of upstream vs. local modifications</li> <li>Diff Analysis: Pure upstream branch enables accurate change detection</li> <li>Audit Trail: Complete traceability of all changes and their sources</li> </ul>"},{"location":"decisions/adr_001_three_branch_strategy/#risk-mitigation-and-safety","title":"Risk Mitigation and Safety","text":"<ul> <li>Conflict Isolation: Merge conflicts resolved in dedicated workspace</li> <li>Validation Gate: Comprehensive testing before production integration</li> <li>Stable Main: Production branch protected from integration issues</li> <li>Rollback Capability: Easy reversion of problematic integrations</li> </ul>"},{"location":"decisions/adr_001_three_branch_strategy/#quality-assurance","title":"Quality Assurance","text":"<ul> <li>Early Detection: Issues caught during integration validation phase</li> <li>Comprehensive Testing: Full build, test, and lint validation</li> <li>Systematic Resolution: Structured approach to conflict and failure resolution</li> </ul>"},{"location":"decisions/adr_001_three_branch_strategy/#operational-benefits","title":"Operational Benefits","text":""},{"location":"decisions/adr_001_three_branch_strategy/#team-productivity","title":"Team Productivity","text":"<ul> <li>Parallel Development: Ongoing development unaffected by upstream integration</li> <li>Clear Processes: Well-defined workflows for different change types</li> <li>Reduced Conflicts: Proactive conflict detection and resolution</li> </ul>"},{"location":"decisions/adr_001_three_branch_strategy/#system-reliability","title":"System Reliability","text":"<ul> <li>Multiple Validation Points: Several quality gates before production</li> <li>Automated Monitoring: Continuous validation and status reporting</li> <li>Failure Recovery: Systematic handling of integration failures</li> </ul>"},{"location":"decisions/adr_001_three_branch_strategy/#alternative-approaches-considered","title":"Alternative Approaches Considered","text":""},{"location":"decisions/adr_001_three_branch_strategy/#two-branch-strategy","title":"Two-Branch Strategy","text":"<p><pre><code>upstream \u2192 main\n</code></pre> - Pros: Simpler branch structure with reduced management overhead - Cons: Conflicts occur directly on production branch, no isolation - Decision: Rejected due to unacceptable risk to production stability</p>"},{"location":"decisions/adr_001_three_branch_strategy/#feature-branch-per-sync","title":"Feature Branch per Sync","text":"<p><pre><code>upstream \u2192 sync-YYYYMMDD \u2192 main\n</code></pre> - Pros: Complete isolation for each sync operation - Cons: Branch proliferation, complex tracking of multiple syncs - Decision: Rejected due to operational complexity</p>"},{"location":"decisions/adr_001_three_branch_strategy/#direct-upstream-merge","title":"Direct Upstream Merge","text":"<p><pre><code>upstream \u2192 main (direct merge)\n</code></pre> - Pros: Simplest possible integration approach - Cons: No conflict isolation, high risk of breaking production - Decision: Rejected due to lack of safety controls</p>"},{"location":"decisions/adr_001_three_branch_strategy/#consequences-and-trade-offs","title":"Consequences and Trade-offs","text":""},{"location":"decisions/adr_001_three_branch_strategy/#positive-outcomes","title":"Positive Outcomes","text":""},{"location":"decisions/adr_001_three_branch_strategy/#enhanced-stability","title":"Enhanced Stability","text":"<ul> <li>Production branch maintains stability through controlled integration</li> <li>Multiple validation points prevent problematic changes from reaching main</li> <li>Clear rollback path for integration issues</li> </ul>"},{"location":"decisions/adr_001_three_branch_strategy/#improved-traceability","title":"Improved Traceability","text":"<ul> <li>Complete audit trail of upstream changes and local modifications</li> <li>Easy identification of change sources and integration points</li> <li>Systematic tracking of validation results and resolutions</li> </ul>"},{"location":"decisions/adr_001_three_branch_strategy/#operational-excellence","title":"Operational Excellence","text":"<ul> <li>Predictable workflows for different types of changes</li> <li>Automated validation and quality assurance</li> <li>Clear escalation paths for integration failures</li> </ul>"},{"location":"decisions/adr_001_three_branch_strategy/#trade-offs-and-limitations","title":"Trade-offs and Limitations","text":""},{"location":"decisions/adr_001_three_branch_strategy/#increased-complexity","title":"Increased Complexity","text":"<ul> <li>Three branches require more sophisticated management</li> <li>Team training needed for branch strategy and workflows</li> <li>Additional automation requirements for effective operation</li> </ul>"},{"location":"decisions/adr_001_three_branch_strategy/#automation-dependency","title":"Automation Dependency","text":"<ul> <li>Requires robust automated workflows for branch synchronization</li> <li>Manual processes become more complex without automation</li> <li>Need for monitoring and alerting on automation failures</li> </ul>"},{"location":"decisions/adr_001_three_branch_strategy/#resource-requirements","title":"Resource Requirements","text":"<ul> <li>Additional CI/CD resources for comprehensive validation</li> <li>Storage requirements for maintaining multiple branches</li> <li>Operational overhead for monitoring branch health</li> </ul>"},{"location":"decisions/adr_001_three_branch_strategy/#success-metrics","title":"Success Metrics","text":""},{"location":"decisions/adr_001_three_branch_strategy/#quantitative-indicators","title":"Quantitative Indicators","text":"<ul> <li>Integration Success Rate: &gt;95% of upstream syncs complete without manual intervention</li> <li>Conflict Resolution Time: &lt;48 hours average time to resolve conflicts</li> <li>Production Stability: Zero unplanned main branch rollbacks due to integration issues</li> <li>Validation Effectiveness: &gt;90% of issues caught during integration phase</li> </ul>"},{"location":"decisions/adr_001_three_branch_strategy/#qualitative-indicators","title":"Qualitative Indicators","text":"<ul> <li>Teams can safely integrate upstream changes without disrupting ongoing development</li> <li>Conflicts are resolved systematically in isolated environment</li> <li>Clear audit trail maintained for all changes and their sources</li> <li>Reduced stress and improved confidence in upstream integration process</li> </ul>"},{"location":"decisions/adr_001_three_branch_strategy/#related-decisions","title":"Related Decisions","text":"<ul> <li>ADR-002: GitHub Actions automation supports this branch strategy</li> <li>ADR-005: Conflict management processes built on this foundation</li> <li>ADR-019: Monitoring system for branch synchronization</li> <li>ADR-022: Issue tracking for integration lifecycle</li> </ul> <p>This three-branch strategy provides the foundation for safe, reliable upstream integration while maintaining production stability and team productivity.</p>"},{"location":"decisions/adr_002_github_actions/","title":"ADR-002: GitHub Actions-Based Automation Architecture","text":"<p> Critical Decision |  2025-05-28 |  Accepted</p>"},{"location":"decisions/adr_002_github_actions/#problem-statement","title":"Problem Statement","text":"<p>The fork management system requires extensive automation to handle repository initialization, upstream synchronization, conflict detection, build validation, and release management. The automation must be reliable, maintainable, and integrate seamlessly with GitHub's ecosystem while supporting complex workflows.</p>"},{"location":"decisions/adr_002_github_actions/#context-and-requirements","title":"Context and Requirements","text":""},{"location":"decisions/adr_002_github_actions/#automation-requirements","title":"Automation Requirements","text":"<p>The system must provide automated support for:</p> <ul> <li>Repository Initialization: Setup and configuration of new fork instances</li> <li>Upstream Synchronization: Regular sync with upstream repositories</li> <li>Conflict Management: Detection and workflow for merge conflicts</li> <li>Quality Assurance: Build validation, testing, and compliance checks</li> <li>Release Management: Automated versioning and release publication</li> <li>Security Scanning: Vulnerability detection and compliance monitoring</li> </ul>"},{"location":"decisions/adr_002_github_actions/#system-constraints","title":"System Constraints","text":"<p>Integration Requirements: - Deep integration with GitHub repository features - Native support for GitHub events and webhooks - Secure handling of API keys and sensitive data - Cost-effective solution within GitHub ecosystem</p> <p>Operational Requirements: - High reliability and availability - Maintainable by development teams - Scalable across multiple fork instances - Clear error handling and debugging capabilities</p>"},{"location":"decisions/adr_002_github_actions/#decision","title":"Decision","text":"<p>Implement modular GitHub Actions-based automation with specialized workflows for each system function:</p> <pre><code>graph TD\n    A[Repository Events] --&gt; B[init.yml]\n    A --&gt; C[sync.yml]\n    A --&gt; D[cascade.yml]\n    A --&gt; E[validate.yml]\n    A --&gt; F[build.yml]\n    A --&gt; G[release.yml]\n    H[cascade-monitor.yml] --&gt; D\n\n    style B fill:#e1f5fe,stroke:#01579b,stroke-width:2px\n    style C fill:#fff3e0,stroke:#e65100,stroke-width:2px\n    style D fill:#fce4ec,stroke:#c2185b,stroke-width:2px\n    style E fill:#e8f5e9,stroke:#1b5e20,stroke-width:2px</code></pre>"},{"location":"decisions/adr_002_github_actions/#material-workflow-workflow-architecture","title":":material-workflow: Workflow Architecture","text":""},{"location":"decisions/adr_002_github_actions/#core-workflows","title":"Core Workflows","text":"Workflow Purpose Trigger Responsibility init.yml Repository setup Template creation Initial configuration and branch structure sync.yml Upstream sync Schedule + Manual Issue-tracked upstream synchronization cascade.yml Integration flow Human trigger Validation and production integration validate.yml Quality gates PR events Code quality and compliance checks build.yml Build/test Push + PR Compilation, testing, coverage release.yml Release management Main branch push Semantic versioning and publication"},{"location":"decisions/adr_002_github_actions/#supporting-workflows","title":"Supporting Workflows","text":"Workflow Purpose Trigger Responsibility cascade-monitor.yml Health monitoring Schedule (6h) Safety net and conflict escalation"},{"location":"decisions/adr_002_github_actions/#modular-design-principles","title":"Modular Design Principles","text":""},{"location":"decisions/adr_002_github_actions/#separation-of-concerns","title":"Separation of Concerns","text":"<ul> <li>Each workflow has a single, well-defined responsibility</li> <li>Minimal overlap between workflow functions</li> <li>Clear interfaces for workflow interaction</li> </ul>"},{"location":"decisions/adr_002_github_actions/#event-driven-architecture","title":"Event-Driven Architecture","text":"<ul> <li>Workflows respond to specific GitHub events</li> <li>Asynchronous execution with state tracking</li> <li>Human-centric triggers for critical operations</li> </ul>"},{"location":"decisions/adr_002_github_actions/#reusable-components","title":"Reusable Components","text":"<pre><code># Composite actions for common patterns\n- name: Java Build Process\n  uses: ./.github/actions/java-build\n  with:\n    java-version: '17'\n    cache-key: ${{ hashFiles('**/pom.xml') }}\n\n- name: Update PR Status\n  uses: ./.github/actions/pr-status\n  with:\n    status: ${{ job.status }}\n    coverage: ${{ steps.test.outputs.coverage }}\n</code></pre>"},{"location":"decisions/adr_002_github_actions/#implementation-strategy","title":"Implementation Strategy","text":""},{"location":"decisions/adr_002_github_actions/#security-and-permissions","title":"Security and Permissions","text":""},{"location":"decisions/adr_002_github_actions/#minimal-permission-model","title":"Minimal Permission Model","text":"<pre><code># Each workflow uses minimal required permissions\npermissions:\n  contents: read        # Repository access\n  pull-requests: write  # PR management\n  issues: write         # Issue tracking\n  statuses: write       # Status checks\n</code></pre>"},{"location":"decisions/adr_002_github_actions/#secrets-management","title":"Secrets Management","text":"<ul> <li>GitHub secrets for API keys and sensitive data</li> <li>Environment-specific secret configuration</li> <li>Secure token handling for external integrations</li> </ul>"},{"location":"decisions/adr_002_github_actions/#error-handling-and-reliability","title":"Error Handling and Reliability","text":""},{"location":"decisions/adr_002_github_actions/#graceful-degradation","title":"Graceful Degradation","text":"<pre><code># Optional steps don't block critical workflows\n- name: Optional Enhancement\n  continue-on-error: true\n  run: |\n    # Enhancement that shouldn't fail the workflow\n</code></pre>"},{"location":"decisions/adr_002_github_actions/#human-centric-recovery","title":"Human-Centric Recovery","text":"<ul> <li>Failed workflows create issues with <code>human-required</code> labels</li> <li>Clear error messages with actionable guidance</li> <li>Safety net monitoring for missed operations</li> </ul>"},{"location":"decisions/adr_002_github_actions/#issue-lifecycle-tracking","title":"Issue Lifecycle Tracking","text":"<ul> <li>Comprehensive state tracking through GitHub issues</li> <li>Complete audit trail for cascade operations</li> <li>Automatic status updates and progress reporting</li> </ul>"},{"location":"decisions/adr_002_github_actions/#performance-optimization","title":"Performance Optimization","text":""},{"location":"decisions/adr_002_github_actions/#parallel-execution","title":"Parallel Execution","text":"<ul> <li>Independent workflows run concurrently</li> <li>Conditional execution prevents unnecessary runs</li> <li>Efficient caching strategies for build artifacts</li> </ul>"},{"location":"decisions/adr_002_github_actions/#resource-management","title":"Resource Management","text":"<pre><code># Efficient caching for build dependencies\n- name: Cache Dependencies\n  uses: actions/cache@v4\n  with:\n    path: ~/.m2/repository\n    key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}\n</code></pre>"},{"location":"decisions/adr_002_github_actions/#rationale-and-benefits","title":"Rationale and Benefits","text":""},{"location":"decisions/adr_002_github_actions/#strategic-advantages","title":"Strategic Advantages","text":""},{"location":"decisions/adr_002_github_actions/#native-github-integration","title":"Native GitHub Integration","text":"<ul> <li>Deep integration with repository features</li> <li>Native support for events, webhooks, and API</li> <li>Seamless user experience within GitHub interface</li> </ul>"},{"location":"decisions/adr_002_github_actions/#cost-effectiveness","title":"Cost Effectiveness","text":"<ul> <li>Included with GitHub subscriptions</li> <li>No additional infrastructure costs</li> <li>Efficient resource utilization</li> </ul>"},{"location":"decisions/adr_002_github_actions/#security-model","title":"Security Model","text":"<ul> <li>Runs in GitHub's secure environment</li> <li>Built-in secrets management</li> <li>Controlled access to repository resources</li> </ul>"},{"location":"decisions/adr_002_github_actions/#operational-benefits","title":"Operational Benefits","text":""},{"location":"decisions/adr_002_github_actions/#zero-setup-requirements","title":"Zero Setup Requirements","text":"<ul> <li>Works immediately upon repository creation</li> <li>No external service configuration needed</li> <li>Template-based deployment across instances</li> </ul>"},{"location":"decisions/adr_002_github_actions/#maintainability","title":"Maintainability","text":"<ul> <li>Modular design enables focused updates</li> <li>Clear separation of concerns</li> <li>Standard YAML configuration format</li> </ul>"},{"location":"decisions/adr_002_github_actions/#reliability","title":"Reliability","text":"<ul> <li>GitHub's infrastructure provides high availability</li> <li>Built-in retry mechanisms for transient failures</li> <li>Comprehensive monitoring and alerting</li> </ul>"},{"location":"decisions/adr_002_github_actions/#alternative-approaches-considered","title":"Alternative Approaches Considered","text":""},{"location":"decisions/adr_002_github_actions/#external-cicd-platforms","title":"External CI/CD Platforms","text":"<p>Options: Jenkins, GitLab CI, CircleCI, Travis CI</p> <ul> <li>Pros: More powerful build environments, advanced pipeline features</li> <li>Cons: External dependencies, additional costs, setup complexity</li> <li>Decision: Rejected due to complexity and cost considerations</li> </ul>"},{"location":"decisions/adr_002_github_actions/#serverless-functions","title":"Serverless Functions","text":"<p>Options: AWS Lambda, Azure Functions, Google Cloud Functions</p> <ul> <li>Pros: Highly scalable, event-driven architecture</li> <li>Cons: Platform lock-in, complex setup, additional infrastructure</li> <li>Decision: Rejected due to vendor lock-in and operational complexity</li> </ul>"},{"location":"decisions/adr_002_github_actions/#monolithic-workflow","title":"Monolithic Workflow","text":"<p>Pattern: Single large workflow handling all operations</p> <ul> <li>Pros: All logic centralized in one location</li> <li>Cons: Complex maintenance, unnecessary execution, poor modularity</li> <li>Decision: Rejected due to maintainability concerns</li> </ul>"},{"location":"decisions/adr_002_github_actions/#consequences-and-trade-offs","title":"Consequences and Trade-offs","text":""},{"location":"decisions/adr_002_github_actions/#positive-outcomes","title":"Positive Outcomes","text":""},{"location":"decisions/adr_002_github_actions/#immediate-deployment","title":"Immediate Deployment","text":"<ul> <li>Zero configuration required for new repositories</li> <li>Automatic activation upon template usage</li> <li>Consistent behavior across all fork instances</li> </ul>"},{"location":"decisions/adr_002_github_actions/#integrated-ecosystem","title":"Integrated Ecosystem","text":"<ul> <li>Leverages GitHub's security and access controls</li> <li>Native support for repository features</li> <li>Seamless integration with development workflows</li> </ul>"},{"location":"decisions/adr_002_github_actions/#operational-excellence","title":"Operational Excellence","text":"<ul> <li>High availability through GitHub's infrastructure</li> <li>Automated error handling and recovery</li> <li>Comprehensive monitoring and alerting</li> </ul>"},{"location":"decisions/adr_002_github_actions/#trade-offs-and-limitations","title":"Trade-offs and Limitations","text":""},{"location":"decisions/adr_002_github_actions/#platform-dependency","title":"Platform Dependency","text":"<ul> <li>Tied specifically to GitHub platform</li> <li>Migration complexity if platform change needed</li> <li>Limited by GitHub Actions feature set</li> </ul>"},{"location":"decisions/adr_002_github_actions/#execution-constraints","title":"Execution Constraints","text":"<ul> <li>Subject to GitHub Actions usage limits</li> <li>Limited control over execution environment</li> <li>Timeout constraints for long-running operations</li> </ul>"},{"location":"decisions/adr_002_github_actions/#yaml-complexity","title":"YAML Complexity","text":"<ul> <li>Complex workflows can become difficult to maintain</li> <li>Debugging requires understanding of GitHub Actions</li> <li>Version control needed for workflow changes</li> </ul>"},{"location":"decisions/adr_002_github_actions/#success-metrics","title":"Success Metrics","text":""},{"location":"decisions/adr_002_github_actions/#quantitative-indicators","title":"Quantitative Indicators","text":"<ul> <li>Initialization Success: &gt;99% of repositories initialize successfully within 5 minutes</li> <li>Sync Reliability: &gt;95% of scheduled upstream syncs complete without intervention</li> <li>Cascade Response: &gt;90% of sync merges followed by cascade within 2 hours</li> <li>Build Performance: Build workflows complete within 15 minutes for typical projects</li> <li>Safety Net Coverage: 100% of missed cascade triggers detected within 6 hours</li> </ul>"},{"location":"decisions/adr_002_github_actions/#qualitative-indicators","title":"Qualitative Indicators","text":"<ul> <li>Development teams can maintain workflows without specialized GitHub Actions expertise</li> <li>Clear audit trail provided through issue lifecycle tracking</li> <li>Failed workflows create actionable issues with recovery guidance</li> <li>Security scanning effectively prevents vulnerabilities from reaching production</li> </ul>"},{"location":"decisions/adr_002_github_actions/#related-decisions","title":"Related Decisions","text":"<ul> <li>ADR-001: Three-branch strategy supported by these workflows</li> <li>ADR-019: Monitoring workflow provides safety net capabilities</li> <li>ADR-014: AI enhancement integrated into workflow system</li> <li>ADR-020: Human-required label strategy for workflow failures</li> </ul> <p>This GitHub Actions-based automation architecture provides reliable, maintainable workflow automation while leveraging GitHub's native capabilities and security model.</p>"},{"location":"decisions/adr_003_template_pattern/","title":"ADR-003: Template Repository Pattern for Self-Configuration","text":"<p> Critical Decision |  2025-05-28 |  Accepted</p>"},{"location":"decisions/adr_003_template_pattern/#problem-statement","title":"Problem Statement","text":"<p>Teams need a way to quickly deploy fork management systems for different upstream repositories without manual configuration. The setup process is complex, involving branch structures, workflow configuration, security settings, and upstream connections that are error-prone and time-consuming when done manually.</p>"},{"location":"decisions/adr_003_template_pattern/#context-and-requirements","title":"Context and Requirements","text":""},{"location":"decisions/adr_003_template_pattern/#manual-setup-complexity","title":"Manual Setup Complexity","text":"<p>Required Configuration Steps: - Creating and configuring three-branch hierarchy with proper relationships - Setting up GitHub Actions workflows with repository-specific parameters - Configuring branch protection rules and security settings - Establishing upstream repository connection and sync settings - Initializing project-specific build and validation configurations</p>"},{"location":"decisions/adr_003_template_pattern/#deployment-requirements","title":"Deployment Requirements","text":"<p>Zero-Configuration Deployment: Teams should be able to deploy a complete fork management system in under 5 minutes without technical expertise.</p> <p>Consistency Assurance: All deployed repositories must follow identical patterns and configurations to ensure reliability and maintainability.</p> <p>Update Propagation: Template improvements should benefit existing deployed repositories without manual intervention.</p>"},{"location":"decisions/adr_003_template_pattern/#decision","title":"Decision","text":"<p>Implement the fork management system as a GitHub Template Repository with intelligent self-configuration:</p> <pre><code>graph TD\n    A[Template Repository] --&gt; B[User Creates from Template]\n    B --&gt; C[init.yml Auto-Triggers]\n    C --&gt; D[Creates Configuration Issue]\n    D --&gt; E[User Provides Upstream URL]\n    E --&gt; F[Validation &amp; Setup]\n    F --&gt; G[Complete Fork Repository]\n\n    style A fill:#e1f5fe,stroke:#01579b,stroke-width:2px\n    style C fill:#e8f5e9,stroke:#1b5e20,stroke-width:2px\n    style F fill:#fff3e0,stroke:#e65100,stroke-width:2px\n    style G fill:#fce4ec,stroke:#c2185b,stroke-width:2px</code></pre>"},{"location":"decisions/adr_003_template_pattern/#template-architecture-components","title":"Template Architecture Components","text":""},{"location":"decisions/adr_003_template_pattern/#1-template-repository-structure","title":"1. Template Repository Structure","text":"<pre><code># Repository marked as template with complete setup\ntemplate_repository:\n  workflows: Complete GitHub Actions workflows with placeholders\n  documentation: Comprehensive guides and ADRs  \n  configurations: Branch protection, security, and build settings\n  examples: Sample configurations for common scenarios\n</code></pre>"},{"location":"decisions/adr_003_template_pattern/#2-issue-based-configuration-interface","title":"2. Issue-Based Configuration Interface","text":"<pre><code># User-friendly configuration through GitHub Issues\nconfiguration_process:\n  trigger: Automatic issue creation by init.yml\n  input_method: Simple comment-based upstream URL provision\n  validation: Automated upstream repository accessibility verification\n  feedback: Real-time progress updates and error reporting\n</code></pre>"},{"location":"decisions/adr_003_template_pattern/#3-self-modifying-workflow-system","title":"3. Self-Modifying Workflow System","text":"<pre><code># Workflows that configure themselves\nself_configuration:\n  parameter_injection: Repository-specific values inserted automatically\n  branch_creation: Three-branch structure established with relationships\n  security_setup: Branch protection and security settings applied\n  upstream_connection: Remote repository configuration and initial sync\n</code></pre>"},{"location":"decisions/adr_003_template_pattern/#implementation-strategy","title":"Implementation Strategy","text":""},{"location":"decisions/adr_003_template_pattern/#deployment-process","title":"Deployment Process","text":""},{"location":"decisions/adr_003_template_pattern/#phase-1-template-creation","title":"Phase 1: Template Creation","text":"<pre><code># One-click repository creation\n- user_action: Click \"Use this template\"\n- github_action: Create repository from template\n- automatic_trigger: init.yml workflow activates immediately\n- result: New repository with all template files copied\n</code></pre>"},{"location":"decisions/adr_003_template_pattern/#phase-2-configuration-collection","title":"Phase 2: Configuration Collection","text":"<pre><code># Issue-based configuration interface\n- issue_creation: Automated configuration issue with instructions\n- user_input: Upstream repository URL provided in issue comment\n- validation: URL format and accessibility verification\n- confirmation: Setup parameters validated and confirmed\n</code></pre>"},{"location":"decisions/adr_003_template_pattern/#phase-3-automated-configuration","title":"Phase 3: Automated Configuration","text":"<pre><code># Self-configuration process\n- branch_setup: Three-branch structure created\n- workflow_customization: Repository-specific parameters injected\n- security_configuration: Branch protection and access controls applied\n- upstream_connection: Remote repository linked and initial sync performed\n</code></pre>"},{"location":"decisions/adr_003_template_pattern/#security-and-reliability","title":"Security and Reliability","text":""},{"location":"decisions/adr_003_template_pattern/#validation-framework","title":"Validation Framework","text":"<pre><code># Comprehensive validation before setup\nupstream_validation:\n  url_format: Verify proper GitHub/GitLab URL format\n  accessibility: Confirm repository is accessible\n  permissions: Validate read access to upstream repository\n  branch_detection: Identify upstream default branch\n</code></pre>"},{"location":"decisions/adr_003_template_pattern/#error-handling","title":"Error Handling","text":"<pre><code># Robust error management\nerror_scenarios:\n  invalid_url: Clear guidance on correct URL format\n  inaccessible_repo: Instructions for access token configuration\n  permission_issues: Step-by-step permission setup guide\n  network_failures: Automatic retry with exponential backoff\n</code></pre>"},{"location":"decisions/adr_003_template_pattern/#rationale-and-benefits","title":"Rationale and Benefits","text":""},{"location":"decisions/adr_003_template_pattern/#strategic-advantages","title":"Strategic Advantages","text":""},{"location":"decisions/adr_003_template_pattern/#user-experience-excellence","title":"User Experience Excellence","text":"<ul> <li>Zero Friction Deployment: Complete setup in under 5 minutes</li> <li>No Technical Expertise Required: Web interface eliminates command-line complexity</li> <li>Interactive Configuration: Real-time feedback and validation during setup</li> <li>Clear Progress Tracking: Visible status updates throughout initialization</li> </ul>"},{"location":"decisions/adr_003_template_pattern/#operational-consistency","title":"Operational Consistency","text":"<ul> <li>Standardized Deployments: All repositories follow identical patterns</li> <li>Configuration Accuracy: Eliminates manual setup errors</li> <li>Quality Assurance: Automated validation ensures proper configuration</li> <li>Audit Trail: Complete setup history maintained in issue comments</li> </ul>"},{"location":"decisions/adr_003_template_pattern/#maintainability-and-evolution","title":"Maintainability and Evolution","text":"<ul> <li>Centralized Updates: Template improvements benefit all deployments</li> <li>Version Control: All changes tracked through standard Git workflows</li> <li>Propagation Mechanism: Update system ensures existing repositories stay current</li> <li>Scalable Architecture: Supports unlimited repository deployments</li> </ul>"},{"location":"decisions/adr_003_template_pattern/#template-update-propagation","title":"Template Update Propagation","text":""},{"location":"decisions/adr_003_template_pattern/#automatic-update-system-resolved-by-adr-011-and-adr-012","title":"Automatic Update System (Resolved by ADR-011 and ADR-012)","text":"<pre><code># Template synchronization workflow\nupdate_process:\n  detection: Weekly checks for template updates\n  analysis: AI-enhanced change categorization\n  deployment: Automated PR creation for updates\n  validation: Quality gates before update application\n</code></pre>"},{"location":"decisions/adr_003_template_pattern/#alternative-approaches-considered","title":"Alternative Approaches Considered","text":""},{"location":"decisions/adr_003_template_pattern/#manual-setup-documentation","title":"Manual Setup Documentation","text":"<p>Approach: Comprehensive setup documentation with step-by-step instructions</p> <ul> <li>Pros: Simple approach with no automation complexity</li> <li>Cons: Error-prone, time-consuming, inconsistent results, requires technical expertise</li> <li>Decision: Rejected due to poor user experience and consistency issues</li> </ul>"},{"location":"decisions/adr_003_template_pattern/#cli-tool-for-setup","title":"CLI Tool for Setup","text":"<p>Approach: Command-line tool for repository configuration</p> <ul> <li>Pros: Powerful configuration options, scriptable deployment</li> <li>Cons: Requires tool installation, platform dependencies, maintenance overhead</li> <li>Decision: Rejected due to deployment complexity and tool maintenance burden</li> </ul>"},{"location":"decisions/adr_003_template_pattern/#external-configuration-service","title":"External Configuration Service","text":"<p>Approach: Web service for centralized repository management</p> <ul> <li>Pros: Advanced configuration UI, centralized management capabilities</li> <li>Cons: External dependency, security concerns, additional infrastructure costs</li> <li>Decision: Rejected due to complexity and external service dependencies</li> </ul>"},{"location":"decisions/adr_003_template_pattern/#static-template-generators","title":"Static Template Generators","text":"<p>Approach: Cookiecutter/Yeoman-style static template generation</p> <ul> <li>Pros: Industry standard approach, powerful templating capabilities</li> <li>Cons: Requires local tools, no automatic updates, static one-time generation</li> <li>Decision: Rejected due to local tool requirements and lack of update mechanism</li> </ul>"},{"location":"decisions/adr_003_template_pattern/#consequences-and-trade-offs","title":"Consequences and Trade-offs","text":""},{"location":"decisions/adr_003_template_pattern/#positive-outcomes","title":"Positive Outcomes","text":""},{"location":"decisions/adr_003_template_pattern/#deployment-excellence","title":"Deployment Excellence","text":"<ul> <li>Teams can deploy complete fork management in under 5 minutes</li> <li>Zero technical expertise required for successful deployment</li> <li>Consistent, reliable results across all repository instances</li> <li>Immediate activation with no additional configuration needed</li> </ul>"},{"location":"decisions/adr_003_template_pattern/#operational-benefits","title":"Operational Benefits","text":"<ul> <li>Centralized template enables rapid improvement deployment</li> <li>Standardized patterns simplify support and maintenance</li> <li>Scalable architecture supports enterprise-wide adoption</li> <li>Complete audit trail for all deployment and update activities</li> </ul>"},{"location":"decisions/adr_003_template_pattern/#user-satisfaction","title":"User Satisfaction","text":"<ul> <li>Intuitive web-based interface eliminates learning curve</li> <li>Real-time feedback provides confidence during setup</li> <li>Clear documentation and examples accelerate adoption</li> <li>Success rate approaches 100% for guided deployments</li> </ul>"},{"location":"decisions/adr_003_template_pattern/#trade-offs-and-limitations","title":"Trade-offs and Limitations","text":""},{"location":"decisions/adr_003_template_pattern/#platform-dependencies","title":"Platform Dependencies","text":"<ul> <li>Tied specifically to GitHub's template repository feature</li> <li>Limited portability to other version control platforms</li> <li>Dependent on GitHub Actions for automation capabilities</li> </ul>"},{"location":"decisions/adr_003_template_pattern/#customization-constraints","title":"Customization Constraints","text":"<ul> <li>Initial setup options constrained by GitHub issue form capabilities</li> <li>Advanced configuration requires workflow modification</li> <li>Some customization scenarios may require manual intervention</li> </ul>"},{"location":"decisions/adr_003_template_pattern/#technical-complexity","title":"Technical Complexity","text":"<ul> <li>Self-modifying workflows add complexity to initialization logic</li> <li>Troubleshooting requires understanding of GitHub Actions</li> <li>Bootstrap process more complex than static templates</li> </ul>"},{"location":"decisions/adr_003_template_pattern/#success-metrics","title":"Success Metrics","text":""},{"location":"decisions/adr_003_template_pattern/#quantitative-indicators","title":"Quantitative Indicators","text":"<ul> <li>Deployment Time: &lt;5 minutes from template use to functional repository</li> <li>Success Rate: &gt;99% successful deployments without manual intervention</li> <li>User Adoption: Measured through template usage statistics</li> <li>Setup Errors: &lt;1% of deployments require manual correction</li> </ul>"},{"location":"decisions/adr_003_template_pattern/#qualitative-indicators","title":"Qualitative Indicators","text":"<ul> <li>Teams report high satisfaction with deployment experience</li> <li>Support requests related to setup decrease significantly</li> <li>Consistent behavior across all deployed repositories</li> <li>Template updates propagate successfully to existing instances</li> </ul>"},{"location":"decisions/adr_003_template_pattern/#related-decisions","title":"Related Decisions","text":"<ul> <li>ADR-001: Three-branch strategy implemented by this template</li> <li>ADR-006: Two-workflow initialization pattern for reliable setup</li> <li>ADR-011: Configuration-driven template synchronization</li> <li>ADR-012: Template update propagation strategy</li> </ul> <p>This template repository pattern provides zero-friction deployment of sophisticated fork management capabilities while maintaining consistency and enabling continuous improvement through automated updates.</p>"},{"location":"decisions/adr_004_release_versioning/","title":"ADR-004: Release Please for Automated Version Management","text":"<p> Critical Decision |  2025-05-28 |  Accepted</p>"},{"location":"decisions/adr_004_release_versioning/#problem-statement","title":"Problem Statement","text":"<p>Fork repositories require sophisticated automated version management that can handle both local modifications and upstream integration while maintaining semantic versioning principles and generating clear changelog documentation. Traditional fork versioning approaches often fail to distinguish between local changes and upstream integration, creating unclear version histories and confusing release documentation.</p>"},{"location":"decisions/adr_004_release_versioning/#context-and-requirements","title":"Context and Requirements","text":""},{"location":"decisions/adr_004_release_versioning/#fork-version-management-challenges","title":"Fork Version Management Challenges","text":"<p>Dual-Source Change Complexity: - Need to distinguish between local enhancements and upstream integration changes - Version numbers must reflect both fork evolution and upstream alignment - Changelog generation requires attribution of changes to local vs upstream sources - Release tags should reference both local and upstream version relationships</p> <p>Automation Requirements: - Semantic versioning based on standardized commit message conventions - Automated changelog generation with meaningful categorization and formatting - Release process automation without manual intervention or human approval gates - Integration with three-branch fork management strategy for consistent workflow</p> <p>Documentation and Transparency: - Meaningful changelogs that clearly communicate change impact and source - Release tags that maintain relationship between fork and upstream versions - Clear audit trail for all version decisions and change attribution - Team communication improvements through standardized commit messaging</p>"},{"location":"decisions/adr_004_release_versioning/#version-management-requirements","title":"Version Management Requirements","text":"<p>Conventional Commit Integration: Standardized commit message format enabling automated version determination and change categorization.</p> <p>Fork-Aware Versioning: Version management system that understands and handles fork-specific versioning needs including upstream references.</p> <p>Automated Release Pipeline: Complete automation from commit to release without manual intervention while maintaining quality and accuracy.</p>"},{"location":"decisions/adr_004_release_versioning/#decision","title":"Decision","text":"<p>Adopt Google's Release Please action for automated version management with Conventional Commits integration:</p> <pre><code>graph TD\n    A[Conventional Commit] --&gt; B[Release Please Analysis]\n    B --&gt; C{Version Bump Type?}\n    C --&gt;|feat| D[Minor Version]\n    C --&gt;|fix| E[Patch Version]\n    C --&gt;|BREAKING| F[Major Version]\n    D --&gt; G[Generate Changelog]\n    E --&gt; G\n    F --&gt; G\n    G --&gt; H[Create Release PR]\n    H --&gt; I[Review &amp; Merge]\n    I --&gt; J[Tag &amp; GitHub Release]\n\n    K[Upstream Integration] --&gt; L[Special Commit Type]\n    L --&gt; M[Attribution in Changelog]\n    M --&gt; G\n\n    style A fill:#e1f5fe,stroke:#01579b,stroke-width:2px\n    style F fill:#fff3e0,stroke:#e65100,stroke-width:2px\n    style J fill:#e8f5e9,stroke:#1b5e20,stroke-width:2px\n    style M fill:#fce4ec,stroke:#c2185b,stroke-width:2px</code></pre>"},{"location":"decisions/adr_004_release_versioning/#material-format-text-conventional-commits-foundation","title":":material-format-text Conventional Commits Foundation","text":""},{"location":"decisions/adr_004_release_versioning/#standardized-commit-format","title":"Standardized Commit Format","text":"<pre><code># Conventional commit structure\ncommit_format:\n  pattern: \"&lt;type&gt;[optional scope]: &lt;description&gt;\"\n  body: \"[optional body explaining the change]\"\n  footer: \"[optional footer(s) with breaking changes]\"\n\n  examples:\n    feature: \"feat(auth): add OAuth integration for upstream sync\"\n    bugfix: \"fix(cascade): resolve conflict detection in merge workflow\"\n    breaking: \"feat!: migrate to new upstream API (BREAKING CHANGE)\"\n    upstream: \"upstream: integrate v2.3.1 changes from upstream repository\"\n</code></pre>"},{"location":"decisions/adr_004_release_versioning/#version-bump-mapping","title":"Version Bump Mapping","text":"<pre><code># Semantic version determination rules\nversion_bumps:\n  major: \"BREAKING CHANGE footer or ! after type\"\n  minor: \"feat type commits\"\n  patch: \"fix type commits\"\n\n  no_bump:\n    - docs: Documentation only changes\n    - style: Code style/formatting changes\n    - refactor: Code refactoring without feature changes\n    - test: Test additions or modifications\n    - chore: Maintenance tasks and tooling updates\n</code></pre>"},{"location":"decisions/adr_004_release_versioning/#material-auto-fix-release-please-configuration","title":":material-auto-fix Release Please Configuration","text":""},{"location":"decisions/adr_004_release_versioning/#fork-optimized-setup","title":"Fork-Optimized Setup","text":"<pre><code># .github/workflows/release.yml configuration\nrelease_please_config:\n  release_type: \"simple\"\n  package_name: \"fork-management-template\"\n\n  changelog_types:\n    features: \n      type: \"feat\"\n      section: \"\u2728 New Features\"\n      hidden: false\n\n    fixes:\n      type: \"fix\" \n      section: \"\ud83d\udc1b Bug Fixes\"\n      hidden: false\n\n    upstream:\n      type: \"upstream\"\n      section: \"\ud83d\udd04 Upstream Integration\"\n      hidden: false\n\n    maintenance:\n      type: \"chore\"\n      section: \"\ud83d\udee0\ufe0f Maintenance\"\n      hidden: false\n</code></pre>"},{"location":"decisions/adr_004_release_versioning/#fork-specific-enhancements","title":"Fork-Specific Enhancements","text":"<pre><code># Enhanced release management for forks\nfork_enhancements:\n  upstream_tags: \"Release tags include upstream version references\"\n  change_attribution: \"Commits marked with source (local vs upstream)\"\n  integration_notes: \"Special handling for upstream integration commits\"\n  version_correlation: \"Changelog includes upstream version relationship\"\n</code></pre>"},{"location":"decisions/adr_004_release_versioning/#implementation-strategy","title":"Implementation Strategy","text":""},{"location":"decisions/adr_004_release_versioning/#material-cog-sync-automated-workflow-integration","title":":material-cog-sync Automated Workflow Integration","text":""},{"location":"decisions/adr_004_release_versioning/#release-please-workflow","title":"Release Please Workflow","text":"<pre><code># Complete release automation pipeline\nname: Release Please\n\non:\n  push:\n    branches: [main]\n\njobs:\n  release-please:\n    runs-on: ubuntu-latest\n    outputs:\n      release_created: ${{ steps.release.outputs.release_created }}\n      tag_name: ${{ steps.release.outputs.tag_name }}\n    steps:\n      - uses: googleapis/release-please-action@v4\n        id: release\n        with:\n          config-file: .release-please-config.json\n          manifest-file: .release-please-manifest.json\n</code></pre>"},{"location":"decisions/adr_004_release_versioning/#enhanced-changelog-generation","title":"Enhanced Changelog Generation","text":"<pre><code># Fork-aware changelog configuration\nchangelog_enhancements:\n  upstream_integration:\n    title: \"\ud83d\udd04 Upstream Integration\"\n    description: \"Changes integrated from upstream repository\"\n    commits: \"upstream: integrate upstream changes from version X.Y.Z\"\n\n  local_features:\n    title: \"\u2728 Fork-Specific Features\" \n    description: \"New capabilities developed specifically for this fork\"\n    commits: \"feat: enhance cascade workflow with monitoring\"\n\n  compatibility:\n    title: \"\ud83d\udd27 Compatibility Updates\"\n    description: \"Changes to maintain upstream compatibility\"\n    commits: \"fix: update API calls for upstream compatibility\"\n</code></pre>"},{"location":"decisions/adr_004_release_versioning/#material-check-circle-outline-commit-message-validation","title":":material-check-circle-outline Commit Message Validation","text":""},{"location":"decisions/adr_004_release_versioning/#automated-enforcement","title":"Automated Enforcement","text":"<pre><code># Conventional commit validation workflow\nname: Validate Commits\n\non: [pull_request]\n\njobs:\n  validate-commits:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: wagoid/commitlint-github-action@v5\n        with:\n          configFile: .commitlintrc.json\n          failOnWarnings: true\n          helpURL: \"https://www.conventionalcommits.org\"\n</code></pre>"},{"location":"decisions/adr_004_release_versioning/#validation-configuration","title":"Validation Configuration","text":"<pre><code># .commitlintrc.json\n{\n  \"extends\": [\"@commitlint/config-conventional\"],\n  \"rules\": {\n    \"type-enum\": [2, \"always\", [\n      \"feat\", \"fix\", \"docs\", \"style\", \"refactor\", \n      \"test\", \"chore\", \"upstream\", \"revert\"\n    ]],\n    \"subject-case\": [2, \"always\", \"lower-case\"],\n    \"subject-max-length\": [2, \"always\", 100],\n    \"body-max-line-length\": [2, \"always\", 100]\n  }\n}\n</code></pre>"},{"location":"decisions/adr_004_release_versioning/#benefits-and-rationale","title":"Benefits and Rationale","text":""},{"location":"decisions/adr_004_release_versioning/#material-trending-up-strategic-advantages","title":":material-trending-up Strategic Advantages","text":""},{"location":"decisions/adr_004_release_versioning/#automation-excellence","title":"Automation Excellence","text":"<ul> <li>Complete release automation eliminates manual version management overhead</li> <li>Semantic versioning ensures predictable, standards-compliant version progression</li> <li>Automated changelog generation provides comprehensive change documentation</li> <li>GitHub-native integration leverages platform capabilities for release management</li> </ul>"},{"location":"decisions/adr_004_release_versioning/#fork-specific-value","title":"Fork-Specific Value","text":"<ul> <li>Clear attribution distinguishes local enhancements from upstream integration</li> <li>Upstream version references maintain relationship visibility in release tags</li> <li>Specialized commit types enable sophisticated change categorization</li> <li>Version correlation tracking provides complete fork evolution audit trail</li> </ul>"},{"location":"decisions/adr_004_release_versioning/#team-productivity-enhancement","title":"Team Productivity Enhancement","text":"<ul> <li>Standardized commit messages improve team communication and code review quality</li> <li>Automated release process eliminates manual tasks and potential human errors</li> <li>Clear change documentation accelerates onboarding and knowledge transfer</li> <li>Conventional commits enable automated tooling integration and analysis</li> </ul>"},{"location":"decisions/adr_004_release_versioning/#material-cog-outline-technical-architecture-benefits","title":":material-cog-outline Technical Architecture Benefits","text":""},{"location":"decisions/adr_004_release_versioning/#industry-standard-adoption","title":"Industry Standard Adoption","text":"<ul> <li>Release Please widely adopted by Google and major open-source projects</li> <li>Conventional Commits specification provides established, proven patterns</li> <li>GitHub Actions native integration ensures reliable, scalable automation</li> <li>Semantic versioning compliance enables ecosystem tool compatibility</li> </ul>"},{"location":"decisions/adr_004_release_versioning/#quality-assurance-integration","title":"Quality Assurance Integration","text":"<ul> <li>Commit message validation prevents release pipeline issues</li> <li>Breaking change detection ensures appropriate version bump handling</li> <li>Automated testing integration through release workflow triggering</li> <li>Change impact analysis through commit type categorization</li> </ul>"},{"location":"decisions/adr_004_release_versioning/#alternative-approaches-considered","title":"Alternative Approaches Considered","text":""},{"location":"decisions/adr_004_release_versioning/#manual-version-management","title":"Manual Version Management","text":"<p>Approach: Human-managed version numbers and changelog maintenance</p> <ul> <li>Pros: Complete control over versioning decisions, simple initial implementation</li> <li>Cons: Error-prone, time-consuming, inconsistent results, requires constant human intervention</li> <li>Decision: Rejected due to automation requirements and scalability concerns</li> </ul>"},{"location":"decisions/adr_004_release_versioning/#semantic-release","title":"Semantic Release","text":"<p>Approach: Popular alternative with extensive plugin ecosystem</p> <ul> <li>Pros: Flexible configuration, comprehensive plugin system, established community</li> <li>Cons: Node.js dependency, complex configuration management, less GitHub-native integration</li> <li>Decision: Rejected in favor of GitHub-native solution with simpler maintenance</li> </ul>"},{"location":"decisions/adr_004_release_versioning/#custom-versioning-script","title":"Custom Versioning Script","text":"<p>Approach: Fork-specific versioning logic implementation</p> <ul> <li>Pros: Complete customization for fork requirements, specific business logic integration</li> <li>Cons: Significant maintenance overhead, testing requirements, reinventing established patterns</li> <li>Decision: Rejected due to long-term maintenance complexity and reliability concerns</li> </ul>"},{"location":"decisions/adr_004_release_versioning/#gitversion-or-branch-based-tools","title":"GitVersion or Branch-Based Tools","text":"<p>Approach: Sophisticated branch-based versioning systems</p> <ul> <li>Pros: Powerful versioning logic, complex branching strategy support</li> <li>Cons: Complex configuration, steep learning curve, limited automation-friendly interfaces</li> <li>Decision: Rejected due to complexity and automation integration challenges</li> </ul>"},{"location":"decisions/adr_004_release_versioning/#consequences-and-trade-offs","title":"Consequences and Trade-offs","text":""},{"location":"decisions/adr_004_release_versioning/#positive-outcomes","title":"Positive Outcomes","text":""},{"location":"decisions/adr_004_release_versioning/#release-management-excellence","title":"Release Management Excellence","text":"<ul> <li>Zero manual intervention required for standard release processes</li> <li>Consistent, predictable semantic versioning across all releases</li> <li>Comprehensive, automatically-generated changelogs with clear categorization</li> <li>GitHub-native releases with proper asset management and discoverability</li> </ul>"},{"location":"decisions/adr_004_release_versioning/#development-workflow-enhancement","title":"Development Workflow Enhancement","text":"<ul> <li>Improved commit message quality through enforced conventional format</li> <li>Clear communication of change intent and impact through standardized messaging</li> <li>Automated validation prevents release pipeline issues from commit message problems</li> <li>Complete audit trail of all version decisions and change attribution</li> </ul>"},{"location":"decisions/adr_004_release_versioning/#fork-specific-value-delivery","title":"Fork-Specific Value Delivery","text":"<ul> <li>Clear distinction between local enhancements and upstream integration in releases</li> <li>Upstream version references maintain visibility into fork-upstream relationship</li> <li>Specialized changelog sections for different types of fork-related changes</li> <li>Version correlation tracking enables complete fork evolution understanding</li> </ul>"},{"location":"decisions/adr_004_release_versioning/#material-minus-trade-offs-and-limitations","title":":material-minus Trade-offs and Limitations","text":""},{"location":"decisions/adr_004_release_versioning/#team-process-requirements","title":"Team Process Requirements","text":"<ul> <li>Team must adopt and consistently follow Conventional Commits format</li> <li>Commit message discipline required for accurate version determination</li> <li>Learning curve for understanding commit type impact on version bumps</li> <li>Breaking change detection relies on proper commit message formatting</li> </ul>"},{"location":"decisions/adr_004_release_versioning/#system-dependencies","title":"System Dependencies","text":"<ul> <li>GitHub-specific implementation limits portability to other platforms</li> <li>Release Please configuration changes require understanding of tool internals</li> <li>Version determination constrained by commit message parsing rules</li> <li>Limited flexibility for non-standard versioning requirements</li> </ul>"},{"location":"decisions/adr_004_release_versioning/#operational-considerations","title":"Operational Considerations","text":"<ul> <li>Failed releases may require manual intervention and troubleshooting</li> <li>Commit message mistakes can lead to incorrect version bumps</li> <li>Complex changes may require multiple commits to properly categorize impact</li> </ul>"},{"location":"decisions/adr_004_release_versioning/#success-metrics","title":"Success Metrics","text":""},{"location":"decisions/adr_004_release_versioning/#quantitative-indicators","title":"Quantitative Indicators","text":"<ul> <li>Release Automation: 100% of releases generated automatically without manual intervention</li> <li>Version Accuracy: Semantic versioning compliance for all releases</li> <li>Changelog Quality: Complete change documentation with proper categorization</li> <li>Commit Format Compliance: &gt;95% of commits following Conventional Commits format</li> </ul>"},{"location":"decisions/adr_004_release_versioning/#qualitative-indicators","title":"Qualitative Indicators","text":"<ul> <li>Team reports improved clarity in communicating change intent through commits</li> <li>Release notes provide clear understanding of changes and their impact</li> <li>Breaking changes clearly identified and documented for users</li> <li>Version correlation with upstream maintained and visible in release documentation</li> </ul>"},{"location":"decisions/adr_004_release_versioning/#integration-points","title":"Integration Points","text":""},{"location":"decisions/adr_004_release_versioning/#material-source-branch-workflow-integration","title":":material-source-branch Workflow Integration","text":""},{"location":"decisions/adr_004_release_versioning/#three-branch-strategy-alignment","title":"Three-Branch Strategy Alignment","text":"<ul> <li>Release Please operates on main branch following successful cascade integration</li> <li>Release tags created after changes have been validated through fork_integration</li> <li>Upstream integration commits properly categorized and attributed in changelogs</li> </ul>"},{"location":"decisions/adr_004_release_versioning/#validation-workflow-coordination","title":"Validation Workflow Coordination","text":"<ul> <li>Commit message validation integrated into PR validation workflow</li> <li>Release pipeline triggered by validated commits reaching main branch</li> <li>Quality gates ensure only properly formatted commits contribute to releases</li> </ul>"},{"location":"decisions/adr_004_release_versioning/#material-label-outline-change-attribution-system","title":":material-label-outline Change Attribution System","text":""},{"location":"decisions/adr_004_release_versioning/#commit-type-extensions","title":"Commit Type Extensions","text":"<ul> <li><code>upstream</code>: Special type for upstream integration commits</li> <li>Enhanced change attribution in generated changelogs</li> <li>Fork-specific sections in release notes highlighting local vs upstream changes</li> </ul>"},{"location":"decisions/adr_004_release_versioning/#related-decisions","title":"Related Decisions","text":"<ul> <li>ADR-001: Three-branch strategy provides foundation for release timing</li> <li>ADR-023: Meta-commit strategy for Release Please coordination</li> <li>Validation Workflow Updates: Commit message validation integration</li> <li>Release Workflow Implementation: Complete automated release pipeline</li> </ul> <p>This Release Please integration provides sophisticated, automated version management specifically designed for fork repositories, ensuring clear change attribution while maintaining industry-standard semantic versioning and comprehensive release documentation.</p>"},{"location":"decisions/adr_005_conflict_management/","title":"ADR-005: Automated Conflict Management Strategy","text":"<p> Critical Decision |  2025-05-28 |  Accepted</p>"},{"location":"decisions/adr_005_conflict_management/#problem-statement","title":"Problem Statement","text":"<p>When synchronizing with upstream repositories, merge conflicts are inevitable due to local modifications in the fork. Traditional conflict management approaches often result in conflicts being resolved directly on main branches (causing instability) or conflicts being ignored (leading to drift from upstream). A systematic approach is needed to handle conflicts safely while maintaining productivity.</p>"},{"location":"decisions/adr_005_conflict_management/#context-and-requirements","title":"Context and Requirements","text":""},{"location":"decisions/adr_005_conflict_management/#conflict-management-challenges","title":"Conflict Management Challenges","text":"<p>Stability Requirements: - Prevent automatic merging of conflicted code into production branches - Maintain main branch stability during conflict resolution processes - Enable systematic resolution without blocking other development activities</p> <p>Visibility and Tracking: - Provide clear visibility into conflicts and resolution requirements - Track conflict resolution decisions for future reference and learning - Maintain complete audit trail of conflict handling activities</p> <p>Process Reliability: - Ensure conflicts are detected immediately during synchronization - Prevent conflicted code from reaching production environments - Enable multiple conflicts to be resolved independently</p>"},{"location":"decisions/adr_005_conflict_management/#decision","title":"Decision","text":"<p>Implement a comprehensive automated conflict management strategy with multi-stage safety controls:</p> <pre><code>graph TD\n    A[Upstream Sync] --&gt; B[Conflict Detection]\n    B --&gt; C{Conflicts Found?}\n    C --&gt;|No| D[Clean Integration]\n    C --&gt;|Yes| E[Create Conflict PR]\n    E --&gt; F[Create Tracking Issue]\n    F --&gt; G[Manual Resolution]\n    G --&gt; H[Review &amp; Validation]\n    H --&gt; I[Integration Approval]\n    I --&gt; J[Main Branch Update]\n\n    style A fill:#e1f5fe,stroke:#01579b,stroke-width:2px\n    style E fill:#fff3e0,stroke:#e65100,stroke-width:2px\n    style F fill:#fce4ec,stroke:#c2185b,stroke-width:2px\n    style J fill:#e8f5e9,stroke:#1b5e20,stroke-width:2px</code></pre>"},{"location":"decisions/adr_005_conflict_management/#automated-conflict-detection","title":"Automated Conflict Detection","text":""},{"location":"decisions/adr_005_conflict_management/#immediate-detection-system","title":"Immediate Detection System","text":"<pre><code># Conflict detection during sync process\nconflict_detection:\n  trigger: Automatic during upstream merge attempts\n  scope: All file types and merge scenarios\n  reporting: Immediate notification through GitHub Issues\n  isolation: Conflicts contained in fork_integration branch\n</code></pre>"},{"location":"decisions/adr_005_conflict_management/#comprehensive-conflict-analysis","title":"Comprehensive Conflict Analysis","text":"<pre><code># AI-enhanced conflict categorization\nconflict_analysis:\n  structural: Directory/file reorganization conflicts\n  functional: Logic changes affecting local modifications\n  merge_artifacts: Git markers from complex three-way merges\n  recommendation: Resolution strategy suggestions\n</code></pre>"},{"location":"decisions/adr_005_conflict_management/#fork-integration-branch-strategy","title":"Fork Integration Branch Strategy","text":""},{"location":"decisions/adr_005_conflict_management/#conflict-isolation-workspace","title":"Conflict Isolation Workspace","text":"<pre><code># Dedicated conflict resolution environment\nintegration_branch:\n  purpose: Safe conflict resolution without affecting main\n  protection: No direct integration to main until resolution complete\n  testing: Full validation required before progression\n  rollback: Easy abandonment of problematic resolutions\n</code></pre>"},{"location":"decisions/adr_005_conflict_management/#resolution-workflow","title":"Resolution Workflow","text":"<pre><code># Systematic conflict resolution process\nresolution_process:\n  detection: Automatic conflict identification\n  pr_creation: Separate PR for conflict resolution\n  issue_tracking: GitHub Issue for coordination and documentation\n  manual_resolution: Human review and resolution required\n  validation: Comprehensive testing before integration\n</code></pre>"},{"location":"decisions/adr_005_conflict_management/#implementation-strategy","title":"Implementation Strategy","text":""},{"location":"decisions/adr_005_conflict_management/#material-issue-tracker-issue-driven-resolution-process","title":":material-issue-tracker: Issue-Driven Resolution Process","text":""},{"location":"decisions/adr_005_conflict_management/#conflict-issue-creation","title":"Conflict Issue Creation","text":"<pre><code># Automatic issue creation for each conflict\nconflict_issue:\n  title: \"\ud83d\udea8 Upstream Sync Conflict - [Date]\"\n  labels: [\"conflict\", \"upstream-sync\", \"human-required\", \"high-priority\"]\n  content: |\n    - Conflict details and affected files\n    - Step-by-step resolution instructions\n    - Links to conflict PR and documentation\n    - Resolution strategy recommendations\n</code></pre>"},{"location":"decisions/adr_005_conflict_management/#resolution-tracking","title":"Resolution Tracking","text":"<pre><code># Comprehensive conflict tracking\ntracking_system:\n  status: Real-time resolution progress updates\n  assignments: Clear ownership of resolution tasks\n  discussion: Platform for resolution strategy discussion\n  documentation: Permanent record of resolution decisions\n  patterns: Historical pattern analysis for future conflicts\n</code></pre>"},{"location":"decisions/adr_005_conflict_management/#material-pull-request-pull-request-workflow","title":":material-pull-request: Pull Request Workflow","text":""},{"location":"decisions/adr_005_conflict_management/#conflict-pull-request","title":"Conflict Pull Request","text":"<pre><code># Dedicated PR for conflict resolution\nconflict_pr:\n  source: Conflict branch with merge markers\n  target: fork_integration branch\n  labels: [\"conflict\", \"needs-resolution\", \"cascade-blocked\"]\n  content: |\n    - Detailed conflict analysis\n    - Resolution instructions\n    - Testing requirements\n    - Review checklist\n</code></pre>"},{"location":"decisions/adr_005_conflict_management/#integration-safeguards","title":"Integration Safeguards","text":"<pre><code># Multiple validation points\nsafety_controls:\n  manual_review: Human approval required for all resolutions\n  testing_required: Comprehensive test suite execution\n  validation_gates: Build and quality checks before integration\n  final_approval: Team review before main branch update\n</code></pre>"},{"location":"decisions/adr_005_conflict_management/#conflict-resolution-framework","title":"Conflict Resolution Framework","text":""},{"location":"decisions/adr_005_conflict_management/#resolution-categories-and-strategies","title":"Resolution Categories and Strategies","text":""},{"location":"decisions/adr_005_conflict_management/#structural-conflicts-40-of-conflicts","title":"Structural Conflicts (40% of conflicts)","text":"<pre><code># Directory/file reorganization conflicts\nstructural_resolution:\n  risk_level: Low\n  strategy: Preserve local structure while adopting upstream organization\n  automation: Often auto-resolvable with clear patterns\n  testing: Verify build and deployment compatibility\n</code></pre>"},{"location":"decisions/adr_005_conflict_management/#functional-conflicts-35-of-conflicts","title":"Functional Conflicts (35% of conflicts)","text":"<pre><code># Logic changes affecting local enhancements\nfunctional_resolution:\n  risk_level: High\n  strategy: Preserve local enhancement intent while adopting upstream improvements\n  analysis: Deep code analysis and impact assessment required\n  testing: Comprehensive functionality validation required\n</code></pre>"},{"location":"decisions/adr_005_conflict_management/#merge-artifacts-25-of-conflicts","title":"Merge Artifacts (25% of conflicts)","text":"<pre><code># Git markers from complex merges\nartifact_resolution:\n  risk_level: Medium\n  strategy: Manual cleanup with functionality preservation\n  validation: Focus on functionality testing over compilation\n  documentation: Clear rationale for resolution choices\n</code></pre>"},{"location":"decisions/adr_005_conflict_management/#resolution-quality-assurance","title":"Resolution Quality Assurance","text":""},{"location":"decisions/adr_005_conflict_management/#validation-requirements","title":"Validation Requirements","text":"<pre><code># Comprehensive validation before integration\nquality_gates:\n  compilation: Code must compile successfully\n  testing: All tests must pass\n  functionality: Core functionality preserved\n  performance: No significant performance regressions\n  security: No security vulnerabilities introduced\n</code></pre>"},{"location":"decisions/adr_005_conflict_management/#review-process","title":"Review Process","text":"<pre><code># Multi-stage review requirements\nreview_process:\n  technical_review: Code quality and correctness assessment\n  functionality_review: Feature preservation validation\n  security_review: Security impact analysis\n  documentation_review: Resolution decision documentation\n</code></pre>"},{"location":"decisions/adr_005_conflict_management/#benefits-and-rationale","title":"Benefits and Rationale","text":""},{"location":"decisions/adr_005_conflict_management/#safety-and-stability","title":"Safety and Stability","text":""},{"location":"decisions/adr_005_conflict_management/#production-protection","title":"Production Protection","text":"<ul> <li>Main branch remains stable throughout conflict resolution</li> <li>Multiple validation points prevent problematic code from reaching production</li> <li>Easy rollback capability for problematic resolutions</li> <li>Clear separation between conflict resolution and integration</li> </ul>"},{"location":"decisions/adr_005_conflict_management/#risk-mitigation","title":"Risk Mitigation","text":"<ul> <li>Automated detection prevents conflicts from being overlooked</li> <li>Systematic process ensures consistent handling regardless of complexity</li> <li>Human review prevents automated incorrect resolutions</li> <li>Complete audit trail enables issue analysis and prevention</li> </ul>"},{"location":"decisions/adr_005_conflict_management/#process-efficiency","title":"Process Efficiency","text":""},{"location":"decisions/adr_005_conflict_management/#systematic-workflow","title":"Systematic Workflow","text":"<ul> <li>Consistent handling of all conflicts using established patterns</li> <li>Clear ownership and accountability for resolution tasks</li> <li>Parallel resolution capability for multiple conflicts</li> <li>Knowledge transfer through documented resolution patterns</li> </ul>"},{"location":"decisions/adr_005_conflict_management/#quality-assurance","title":"Quality Assurance","text":"<ul> <li>Human judgment ensures appropriate conflict resolution</li> <li>Multiple review stages catch potential issues early</li> <li>Testing requirements ensure functionality preservation</li> <li>Documentation enables learning from resolution decisions</li> </ul>"},{"location":"decisions/adr_005_conflict_management/#alternative-approaches-considered","title":"Alternative Approaches Considered","text":""},{"location":"decisions/adr_005_conflict_management/#automatic-conflict-resolution","title":"Automatic Conflict Resolution","text":"<p>Approach: AI-powered automatic resolution of detected conflicts</p> <ul> <li>Pros: No manual intervention required, faster integration cycles</li> <li>Cons: Risk of incorrect resolutions, loss of context, potential data loss</li> <li>Decision: Rejected due to safety and quality concerns requiring human judgment</li> </ul>"},{"location":"decisions/adr_005_conflict_management/#main-branch-resolution","title":"Main Branch Resolution","text":"<p>Approach: Resolve conflicts directly on main branch</p> <ul> <li>Pros: Simpler workflow with direct resolution path</li> <li>Cons: Destabilizes main branch, blocks other development, high risk</li> <li>Decision: Rejected due to stability requirements and development velocity impact</li> </ul>"},{"location":"decisions/adr_005_conflict_management/#feature-branch-per-conflict","title":"Feature Branch per Conflict","text":"<p>Approach: Create separate feature branch for each conflict</p> <ul> <li>Pros: Complete isolation of individual conflicts</li> <li>Cons: Branch proliferation, complex tracking overhead, management complexity</li> <li>Decision: Rejected due to operational complexity and maintenance burden</li> </ul>"},{"location":"decisions/adr_005_conflict_management/#manual-detection-process","title":"Manual Detection Process","text":"<p>Approach: Rely on developers to detect and report conflicts</p> <ul> <li>Pros: Human judgment in conflict identification</li> <li>Cons: Inconsistent detection, delays, human error prone, lacks systematic approach</li> <li>Decision: Rejected due to reliability requirements and automation benefits</li> </ul>"},{"location":"decisions/adr_005_conflict_management/#consequences-and-trade-offs","title":"Consequences and Trade-offs","text":""},{"location":"decisions/adr_005_conflict_management/#positive-outcomes","title":"Positive Outcomes","text":""},{"location":"decisions/adr_005_conflict_management/#enhanced-stability","title":"Enhanced Stability","text":"<ul> <li>Main branch protected from conflicts during resolution activities</li> <li>Multiple safety gates prevent unstable code from reaching production</li> <li>Clear rollback path for problematic conflict resolutions</li> <li>Reduced risk of production incidents due to poor conflict resolution</li> </ul>"},{"location":"decisions/adr_005_conflict_management/#improved-visibility","title":"Improved Visibility","text":"<ul> <li>Complete tracking of all conflicts and resolution status</li> <li>Clear accountability and ownership for resolution activities</li> <li>Permanent record of resolution decisions for future reference</li> <li>Pattern analysis enables improvement of resolution processes</li> </ul>"},{"location":"decisions/adr_005_conflict_management/#quality-assurance_1","title":"Quality Assurance","text":"<ul> <li>Human review ensures appropriate and context-aware resolutions</li> <li>Multiple validation points catch potential issues before integration</li> <li>Systematic approach ensures consistent quality across all resolutions</li> <li>Documentation enables knowledge sharing and process improvement</li> </ul>"},{"location":"decisions/adr_005_conflict_management/#trade-offs-and-limitations","title":"Trade-offs and Limitations","text":""},{"location":"decisions/adr_005_conflict_management/#process-overhead","title":"Process Overhead","text":"<ul> <li>Manual resolution required for all conflicts adds time to integration</li> <li>Multiple review stages can slow down urgent fixes</li> <li>Issue creation and tracking adds administrative overhead</li> </ul>"},{"location":"decisions/adr_005_conflict_management/#resource-requirements","title":"Resource Requirements","text":"<ul> <li>Human expertise required for conflict resolution activities</li> <li>Time investment needed for proper resolution and validation</li> <li>Training required for team members on resolution procedures</li> </ul>"},{"location":"decisions/adr_005_conflict_management/#complexity-management","title":"Complexity Management","text":"<ul> <li>Multiple branches and PRs require careful coordination</li> <li>Resolution process workflow requires team understanding and adoption</li> <li>Troubleshooting resolution issues requires process knowledge</li> </ul>"},{"location":"decisions/adr_005_conflict_management/#success-metrics","title":"Success Metrics","text":""},{"location":"decisions/adr_005_conflict_management/#quantitative-indicators","title":"Quantitative Indicators","text":"<ul> <li>Resolution Time: &lt;48 hours average for conflict resolution</li> <li>Main Branch Stability: Zero unplanned rollbacks due to conflict resolution</li> <li>Detection Rate: 100% of conflicts detected automatically</li> <li>Resolution Quality: &lt;5% of resolutions require rework</li> </ul>"},{"location":"decisions/adr_005_conflict_management/#qualitative-indicators","title":"Qualitative Indicators","text":"<ul> <li>Team confidence in conflict resolution process</li> <li>Clear understanding of resolution decision rationale</li> <li>Effective knowledge transfer through resolution documentation</li> <li>Reduced stress and improved predictability in upstream integration</li> </ul>"},{"location":"decisions/adr_005_conflict_management/#related-decisions","title":"Related Decisions","text":"<ul> <li>ADR-001: Three-branch strategy provides foundation for conflict isolation</li> <li>ADR-019: Monitoring system ensures conflict resolution completion</li> <li>ADR-020: Human-required labeling coordinates resolution activities</li> <li>ADR-022: Issue lifecycle tracking supports conflict management</li> </ul> <p>This automated conflict management strategy provides systematic, safe handling of merge conflicts while maintaining production stability and enabling continuous learning from resolution patterns.</p>"},{"location":"decisions/adr_006_initialization/","title":"ADR-006: Two-Workflow Initialization Pattern","text":"<p> Critical Decision |  2025-05-28 |  Accepted</p>"},{"location":"decisions/adr_006_initialization/#problem-statement","title":"Problem Statement","text":"<p>The original initialization system used a single, monolithic workflow (<code>init.yml</code>) handling everything from user interface to repository setup in one 492-line file. This approach created significant maintainability, usability, and reliability challenges that hindered the template's effectiveness and user experience.</p>"},{"location":"decisions/adr_006_initialization/#context-and-requirements","title":"Context and Requirements","text":""},{"location":"decisions/adr_006_initialization/#single-workflow-architecture-problems","title":"Single Workflow Architecture Problems","text":"<p>Complexity Issues: - Monolithic 492-line workflow handling multiple concerns simultaneously - Complex nested conditions with numerous failure points - Overlapping initialization checks and complex cleanup processes - Technical error messages unsuitable for non-expert users</p> <p>Maintainability Challenges: - Large, complex workflow difficult to debug and modify - Interconnected logic making isolated changes risky - No clear separation between user interaction and system setup - Error handling scattered throughout complex conditional blocks</p> <p>User Experience Issues: - Technical GitHub Actions error messages exposed to users - No clear progress indication during initialization process - Confusing status updates mixed with technical implementation details - Poor error recovery with limited actionable feedback</p>"},{"location":"decisions/adr_006_initialization/#architectural-requirements","title":"Architectural Requirements","text":"<p>Clear Separation of Concerns: Distinct phases for user interaction and system configuration with minimal interdependencies.</p> <p>Enhanced User Experience: Friendly, progress-aware interface with clear guidance and actionable error messages.</p> <p>Maintainable Implementation: Focused, understandable workflows that developers can confidently modify and extend.</p>"},{"location":"decisions/adr_006_initialization/#decision","title":"Decision","text":"<p>Implement a two-workflow initialization pattern with clear separation between user interface and system setup:</p> <pre><code>graph TD\n    A[Template Creation] --&gt; B[init.yml Triggers]\n    B --&gt; C[Create Welcome Issue]\n    C --&gt; D[User Provides Upstream URL]\n    D --&gt; E[init-complete.yml Triggers]\n    E --&gt; F[Validate Input]\n    F --&gt; G{Valid Repository?}\n    G --&gt;|No| H[Friendly Error Message]\n    G --&gt;|Yes| I[Repository Setup]\n    I --&gt; J[Branch Creation]\n    J --&gt; K[Configuration]\n    K --&gt; L[Completion Summary]\n    L --&gt; M[Self-Cleanup]\n\n    style A fill:#e1f5fe,stroke:#01579b,stroke-width:2px\n    style C fill:#e8f5e9,stroke:#1b5e20,stroke-width:2px\n    style H fill:#fff3e0,stroke:#e65100,stroke-width:2px\n    style M fill:#fce4ec,stroke:#c2185b,stroke-width:2px</code></pre>"},{"location":"decisions/adr_006_initialization/#phase-1-user-interface-workflow-inityml","title":"Phase 1: User Interface Workflow (<code>init.yml</code>)","text":""},{"location":"decisions/adr_006_initialization/#streamlined-user-interaction-40-lines","title":"Streamlined User Interaction (~40 lines)","text":"<pre><code># Focused responsibilities\nuser_interface:\n  purpose: Create friendly initialization experience\n  triggers: Push to main branch (template creation)\n  responsibilities:\n    - Template vs. instance detection\n    - Welcome issue creation with clear instructions\n    - User guidance and communication\n  removed_complexity:\n    - README status updates (unnecessary noise)\n    - Complex validation logic\n    - Repository setup operations\n</code></pre>"},{"location":"decisions/adr_006_initialization/#enhanced-user-communication","title":"Enhanced User Communication","text":"<pre><code># User-friendly messaging\ncommunication_pattern:\n  welcome_message: Emoji-enhanced instructions with clear steps\n  guidance: Step-by-step process explanation\n  expectations: Clear timeline and requirements\n  accessibility: Web interface only, no technical prerequisites\n</code></pre>"},{"location":"decisions/adr_006_initialization/#phase-2-repository-setup-workflow-init-completeyml","title":"Phase 2: Repository Setup Workflow (<code>init-complete.yml</code>)","text":""},{"location":"decisions/adr_006_initialization/#comprehensive-system-configuration-300-lines","title":"Comprehensive System Configuration (~300 lines)","text":"<pre><code># Focused system setup\nrepository_setup:\n  purpose: Complete repository configuration and initialization\n  triggers: Issue comments (user providing upstream repository)\n  responsibilities:\n    - Input validation with clear error messages\n    - Repository variable state management\n    - Branch structure creation and configuration\n    - Security and protection rule setup\n    - Automatic validation workflow triggering\n  enhanced_features:\n    - Self-cleanup of initialization workflows\n    - Consolidated commit strategy\n    - Comprehensive completion summary\n</code></pre>"},{"location":"decisions/adr_006_initialization/#advanced-state-management","title":"Advanced State Management","text":"<pre><code># Centralized initialization tracking\nstate_management:\n  primary_indicator: .github/workflow.env file\n  initialization_flag: INITIALIZATION_COMPLETE=true\n  repository_metadata: UPSTREAM_REPO_URL and configuration\n  concurrency_control: Issue-based locking mechanism\n</code></pre>"},{"location":"decisions/adr_006_initialization/#implementation-strategy","title":"Implementation Strategy","text":""},{"location":"decisions/adr_006_initialization/#workflow-separation-architecture","title":"Workflow Separation Architecture","text":""},{"location":"decisions/adr_006_initialization/#clear-trigger-patterns","title":"Clear Trigger Patterns","text":"<pre><code># init.yml - Template creation detection\ninit_workflow:\n  trigger: push to main branch\n  purpose: User interface and initial setup\n  output: Initialization issue with instructions\n\n# init-complete.yml - User response handling  \ncomplete_workflow:\n  trigger: issue_comment created\n  purpose: Repository setup and configuration\n  output: Configured repository ready for use\n</code></pre>"},{"location":"decisions/adr_006_initialization/#state-management-framework","title":"State Management Framework","text":"<pre><code># Primary initialization state tracking\nstate_indicators:\n  completion_flag: .github/workflow.env with INITIALIZATION_COMPLETE=true\n  repository_variables: Upstream URL and configuration metadata\n  issue_tracking: GitHub issue for coordination and communication\n  concurrency_control: Workflow-level locking per issue\n</code></pre>"},{"location":"decisions/adr_006_initialization/#enhanced-user-experience-design","title":"Enhanced User Experience Design","text":""},{"location":"decisions/adr_006_initialization/#progress-communication-pattern","title":"Progress Communication Pattern","text":"<pre><code># Real-time user feedback\nprogress_updates:\n  welcome: \"\ud83c\udf89 Welcome! Setting up your fork management repository...\"\n  validation: \"\ud83d\udd0d Validating upstream repository access...\"\n  setup: \"\ud83d\udd27 Creating branch structure and configuration...\"\n  completion: \"\u2705 Repository successfully configured and ready!\"\n</code></pre>"},{"location":"decisions/adr_006_initialization/#error-handling-and-recovery","title":"Error Handling and Recovery","text":"<pre><code># User-friendly error management\nerror_handling:\n  validation_errors: Clear explanation of URL format requirements\n  access_errors: Step-by-step guidance for access token setup\n  network_errors: Automatic retry with progress updates\n  format_errors: Examples of correct input formats\n</code></pre>"},{"location":"decisions/adr_006_initialization/#concurrency-and-safety-controls","title":"Concurrency and Safety Controls","text":""},{"location":"decisions/adr_006_initialization/#workflow-isolation","title":"Workflow Isolation","text":"<pre><code># Prevent concurrent initialization attempts\nconcurrency_control:\n  group: ${{ github.workflow }}-${{ github.event.issue.number }}\n  cancel_in_progress: false\n  scope: Per-issue isolation for safety\n</code></pre>"},{"location":"decisions/adr_006_initialization/#self-cleanup-mechanism","title":"Self-Cleanup Mechanism","text":"<pre><code># Automatic cleanup of initialization workflows\ncleanup_process:\n  trigger: Successful repository setup completion\n  actions:\n    - Remove initialization workflows from .github/workflows/\n    - Commit cleanup with descriptive message\n    - Close initialization issue with summary\n    - Update repository variables with final state\n</code></pre>"},{"location":"decisions/adr_006_initialization/#benefits-and-rationale","title":"Benefits and Rationale","text":""},{"location":"decisions/adr_006_initialization/#material-trending-up-user-experience-excellence","title":":material-trending-up User Experience Excellence","text":""},{"location":"decisions/adr_006_initialization/#friendly-interface-design","title":"Friendly Interface Design","text":"<ul> <li>Emoji-enhanced communication creates welcoming experience</li> <li>Step-by-step guidance eliminates confusion and uncertainty</li> <li>Real-time progress updates provide confidence during setup</li> <li>Clear error messages with actionable resolution steps</li> </ul>"},{"location":"decisions/adr_006_initialization/#simplified-user-journey","title":"Simplified User Journey","text":"<ul> <li>Single upstream URL input required from user</li> <li>Web-based interface requires no technical tools or expertise</li> <li>Automatic validation prevents common configuration mistakes</li> <li>Comprehensive completion summary confirms successful setup</li> </ul>"},{"location":"decisions/adr_006_initialization/#technical-architecture-benefits","title":"Technical Architecture Benefits","text":""},{"location":"decisions/adr_006_initialization/#maintainable-code-structure","title":"Maintainable Code Structure","text":"<ul> <li>Each workflow has single, clear responsibility and purpose</li> <li>Reduced complexity enables confident modification and debugging</li> <li>Isolated concerns allow independent testing and validation</li> <li>Clear interfaces between workflows minimize coupling</li> </ul>"},{"location":"decisions/adr_006_initialization/#enhanced-reliability","title":"Enhanced Reliability","text":"<ul> <li>Fewer complex operations reduce potential failure points</li> <li>Better error handling with user-friendly feedback mechanisms</li> <li>Improved state management with single source of truth</li> <li>Concurrency controls prevent race conditions and conflicts</li> </ul>"},{"location":"decisions/adr_006_initialization/#simplified-state-management","title":"Simplified State Management","text":"<ul> <li><code>.github/workflow.env</code> serves as primary initialization indicator</li> <li>Repository variables provide metadata persistence</li> <li>Issue-based coordination enables clear communication tracking</li> <li>Self-cleanup eliminates maintenance overhead</li> </ul>"},{"location":"decisions/adr_006_initialization/#alternative-approaches-considered","title":"Alternative Approaches Considered","text":""},{"location":"decisions/adr_006_initialization/#maintain-single-workflow-with-refactoring","title":"Maintain Single Workflow with Refactoring","text":"<p>Approach: Refactor existing 492-line workflow for better organization</p> <ul> <li>Pros: Fewer files to manage, all logic in single location</li> <li>Cons: Fundamental complexity issues remain unaddressed, difficult to properly separate concerns</li> <li>Decision: Rejected due to inability to resolve core architectural problems</li> </ul>"},{"location":"decisions/adr_006_initialization/#three-workflow-pattern-init-validate-setup","title":"Three-Workflow Pattern (Init + Validate + Setup)","text":"<p>Approach: Further subdivision into initialization, validation, and setup workflows</p> <ul> <li>Pros: Maximum granular separation of concerns</li> <li>Cons: Over-engineering for current requirements, excessive coordination complexity</li> <li>Decision: Rejected as unnecessary complexity without proportional benefits</li> </ul>"},{"location":"decisions/adr_006_initialization/#composite-actions-for-reusable-components","title":"Composite Actions for Reusable Components","text":"<p>Approach: Extract common functionality into reusable composite actions</p> <ul> <li>Pros: Code reuse opportunities, modular component architecture</li> <li>Cons: Doesn't address fundamental workflow architecture issues</li> <li>Decision: Considered for future enhancement but not primary solution</li> </ul>"},{"location":"decisions/adr_006_initialization/#external-service-integration","title":"External Service Integration","text":"<p>Approach: Use external service for configuration management</p> <ul> <li>Pros: Advanced UI capabilities, centralized management features</li> <li>Cons: External dependencies, security concerns, additional infrastructure costs</li> <li>Decision: Rejected due to template simplicity and self-contained requirements</li> </ul>"},{"location":"decisions/adr_006_initialization/#consequences-and-trade-offs","title":"Consequences and Trade-offs","text":""},{"location":"decisions/adr_006_initialization/#positive-outcomes","title":"Positive Outcomes","text":""},{"location":"decisions/adr_006_initialization/#dramatically-improved-user-experience","title":"Dramatically Improved User Experience","text":"<ul> <li>Users receive friendly, emoji-enhanced guidance throughout initialization</li> <li>Clear progress indication eliminates uncertainty during setup process</li> <li>Actionable error messages enable users to resolve issues independently</li> <li>Comprehensive completion summary confirms successful configuration</li> </ul>"},{"location":"decisions/adr_006_initialization/#enhanced-developer-experience","title":"Enhanced Developer Experience","text":"<ul> <li>Developers can quickly understand and confidently modify focused workflows</li> <li>Isolated concerns enable safe changes without unintended side effects</li> <li>Clear interfaces between workflows minimize debugging complexity</li> <li>Better error handling reduces support burden and user frustration</li> </ul>"},{"location":"decisions/adr_006_initialization/#increased-system-reliability","title":"Increased System Reliability","text":"<ul> <li>Reduced complexity eliminates numerous potential failure points</li> <li>Better state management prevents race conditions and conflicts</li> <li>Enhanced error recovery improves success rates across edge cases</li> <li>Self-cleanup mechanism eliminates manual maintenance requirements</li> </ul>"},{"location":"decisions/adr_006_initialization/#trade-offs-and-limitations","title":"Trade-offs and Limitations","text":""},{"location":"decisions/adr_006_initialization/#additional-workflow-files","title":"Additional Workflow Files","text":"<ul> <li>Two workflows instead of one (mitigated by dramatically simpler content per file)</li> <li>Cross-workflow dependencies require understanding coordination pattern</li> <li>Team learning curve for two-workflow pattern adoption</li> </ul>"},{"location":"decisions/adr_006_initialization/#coordination-complexity","title":"Coordination Complexity","text":"<ul> <li><code>init-complete.yml</code> depends on issue created by <code>init.yml</code></li> <li>Issue-based communication adds coordination overhead</li> <li>State management across workflows requires careful design</li> </ul>"},{"location":"decisions/adr_006_initialization/#debugging-considerations","title":"Debugging Considerations","text":"<ul> <li>Issues may span multiple workflows requiring end-to-end understanding</li> <li>GitHub Actions limitations in cross-workflow debugging capabilities</li> </ul>"},{"location":"decisions/adr_006_initialization/#success-metrics","title":"Success Metrics","text":""},{"location":"decisions/adr_006_initialization/#quantitative-indicators","title":"Quantitative Indicators","text":"<ul> <li>Initialization Success Rate: &gt;99% successful template deployments</li> <li>User Completion Time: &lt;10 minutes from template creation to functional repository</li> <li>Error Resolution Rate: &gt;95% of errors resolved by users without support</li> <li>Maintenance Effort: &lt;2 hours per month for workflow maintenance</li> </ul>"},{"location":"decisions/adr_006_initialization/#qualitative-indicators","title":"Qualitative Indicators","text":"<ul> <li>Team members can confidently modify workflows without GitHub Actions expertise</li> <li>Users report positive experience with initialization process</li> <li>Error messages provide clear, actionable guidance for common issues</li> <li>Documentation and code are self-explanatory for new contributors</li> </ul>"},{"location":"decisions/adr_006_initialization/#related-decisions","title":"Related Decisions","text":"<ul> <li>ADR-003: Template repository pattern provides foundation for this initialization approach</li> <li>ADR-007: Initialization workflow bootstrap complements this pattern</li> <li>ADR-016: Initialization security handling ensures safe template deployment</li> <li>ADR-020: Human-required labeling coordinates initialization activities</li> </ul> <p>This two-workflow initialization pattern provides maintainable, user-friendly template deployment while ensuring reliable repository setup through clear separation of concerns and enhanced user experience design.</p>"},{"location":"decisions/adr_007_bootstrap/","title":"ADR-007: Initialization Workflow Bootstrap Pattern","text":"<p> Critical Decision |  2025-05-29 |  Accepted</p>"},{"location":"decisions/adr_007_bootstrap/#problem-statement","title":"Problem Statement","text":"<p>During OSDU repository testing, a critical bootstrap problem was discovered in the template initialization process: when repositories are created from the template, initialization workflows run from the template's initial commit rather than the current version, preventing critical fixes and improvements from being available during actual initialization.</p>"},{"location":"decisions/adr_007_bootstrap/#context-and-requirements","title":"Context and Requirements","text":""},{"location":"decisions/adr_007_bootstrap/#the-bootstrap-problem-discovery","title":"The Bootstrap Problem Discovery","text":"<p>GitHub Actions Execution Model: - GitHub Actions runs workflows from the commit that triggered the event - For template-created repositories, this is the initial commit containing potentially outdated workflow logic - Creates a chicken-and-egg problem where fixes to initialization aren't available during initialization - Results in users encountering already-fixed issues in new repository deployments</p> <p>Specific Failure Scenarios Encountered: <pre><code># Original failure sequence\nfailure_timeline:\n  step_1: \"User creates repository from template\"\n  step_2: \"Initialization workflow runs from commit b40474835cd53d4e78bf20108e18ac6178af6842\"\n  step_3: \"Workflow fails at: git merge fork_integration --no-ff\"\n  step_4: \"Error: fatal: refusing to merge unrelated histories\"\n  step_5: \"Current template already has fix: --allow-unrelated-histories flag\"\n  step_6: \"But fix isn't available to running workflow\"\n</code></pre></p> <p>Additional Technical Challenges: - Merge conflicts in common files (<code>.gitignore</code>, <code>README.md</code>) between template and upstream versions - Built-in <code>GITHUB_TOKEN</code> lacks permissions for repository secret creation operations - Need for <code>-X theirs</code> merge strategy to automatically resolve template/upstream conflicts - Requirement for Personal Access Token (PAT) with enhanced permissions for full initialization</p>"},{"location":"decisions/adr_007_bootstrap/#material-target-bootstrap-solution-requirements","title":":material-target Bootstrap Solution Requirements","text":"<p>Self-Updating Capability: Initialization workflows must be able to update themselves to the latest version before executing core logic.</p> <p>Fix Propagation: Critical fixes and improvements must immediately reach new repository deployments without manual intervention.</p> <p>Graceful Degradation: System must handle edge cases like template unavailability or permission issues with appropriate fallbacks.</p>"},{"location":"decisions/adr_007_bootstrap/#decision","title":"Decision","text":"<p>Implement a Self-Updating Initialization Workflow Bootstrap Pattern with two-phase execution:</p> <pre><code>graph TD\n    A[Template Repository Created] --&gt; B[Initialization Trigger]\n    B --&gt; C[Phase 1: Bootstrap Update]\n    C --&gt; D[Fetch Latest Template]\n    D --&gt; E[Update Workflow Files]\n    E --&gt; F{Updates Available?}\n    F --&gt;|Yes| G[Commit Updated Workflows]\n    F --&gt;|No| H[No Update Needed]\n    G --&gt; I[Phase 2: Execute Initialization]\n    H --&gt; I\n    I --&gt; J[Run Updated Logic]\n    J --&gt; K[Handle Unrelated Histories]\n    K --&gt; L[Resolve Merge Conflicts]\n    L --&gt; M[Create Repository Secrets]\n    M --&gt; N[Cleanup Template Artifacts]\n    N --&gt; O[Initialization Complete]\n\n    style A fill:#e1f5fe,stroke:#01579b,stroke-width:2px\n    style C fill:#e8f5e9,stroke:#1b5e20,stroke-width:2px\n    style G fill:#fff3e0,stroke:#e65100,stroke-width:2px\n    style O fill:#fce4ec,stroke:#c2185b,stroke-width:2px</code></pre>"},{"location":"decisions/adr_007_bootstrap/#material-update-phase-1-bootstrap-update-process","title":":material-update Phase 1: Bootstrap Update Process","text":""},{"location":"decisions/adr_007_bootstrap/#self-updating-workflow-logic","title":"Self-Updating Workflow Logic","text":"<pre><code># Two-phase initialization with self-update\nbootstrap_update:\n  name: \"Update initialization workflow to latest version\"\n\n  implementation: |\n    # Phase 1: Bootstrap Update\n    update-workflow:\n      name: Update initialization workflow\n      runs-on: ubuntu-latest\n      steps:\n        - name: Checkout current repository\n          uses: actions/checkout@v4\n          with:\n            token: ${{ secrets.GITHUB_TOKEN }}\n\n        - name: Fetch latest workflow from template\n          run: |\n            # Add template as remote source\n            git remote add template https://github.com/danielscholl-osdu/osdu-fork-template.git\n            git fetch template main\n\n            # Update workflows to latest version\n            git checkout template/main -- .github/workflows/init.yml\n            git checkout template/main -- .github/workflows/init-complete.yml\n\n            # Commit only if changes exist\n            if git diff --staged --quiet; then\n              echo \"Workflows are already up to date\"\n            else\n              git config user.name \"github-actions[bot]\"\n              git config user.email \"github-actions[bot]@users.noreply.github.com\"\n              git commit -m \"chore: update initialization workflows to latest version\"\n              git push\n            fi\n</code></pre>"},{"location":"decisions/adr_007_bootstrap/#enhanced-error-handling-and-fallbacks","title":"Enhanced Error Handling and Fallbacks","text":"<pre><code># Robust error handling for bootstrap process\nerror_handling:\n  template_unavailable: |\n    # Graceful fallback if template repository inaccessible\n    if ! git fetch template main 2&gt;/dev/null; then\n      echo \"\u26a0\ufe0f Template repository unavailable, proceeding with current workflow version\"\n      echo \"template_update_failed=true\" &gt;&gt; $GITHUB_OUTPUT\n    fi\n\n  permission_issues: |\n    # Handle permission limitations gracefully\n    if ! git push 2&gt;/dev/null; then\n      echo \"\u26a0\ufe0f Insufficient permissions to update workflows, proceeding with current version\"\n      echo \"workflow_update_skipped=true\" &gt;&gt; $GITHUB_OUTPUT\n    fi\n\n  conflict_prevention: |\n    # Check for local modifications before updating\n    if ! git diff --quiet .github/workflows/; then\n      echo \"\u26a0\ufe0f Local workflow modifications detected, skipping update to prevent conflicts\"\n      echo \"local_modifications_detected=true\" &gt;&gt; $GITHUB_OUTPUT\n    fi\n</code></pre>"},{"location":"decisions/adr_007_bootstrap/#material-cogs-phase-2-enhanced-initialization-execution","title":":material-cogs Phase 2: Enhanced Initialization Execution","text":""},{"location":"decisions/adr_007_bootstrap/#updated-initialization-logic-with-latest-fixes","title":"Updated Initialization Logic with Latest Fixes","text":"<pre><code># Enhanced initialization with all latest fixes\nenhanced_initialization:\n  unrelated_histories_fix: |\n    # Handle unrelated histories during merge\n    git merge fork_integration --no-ff --allow-unrelated-histories -X theirs \\\n      -m \"chore: complete repository initialization\"\n\n  merge_conflict_resolution: |\n    # Automatic conflict resolution strategy\n    git merge fork_integration --no-ff --allow-unrelated-histories -X theirs \\\n      -m \"chore: integrate upstream with template\"\n\n  enhanced_permissions: |\n    # Use PAT token for enhanced operations when available\n    if [ -n \"${{ secrets.GH_TOKEN }}\" ]; then\n      echo \"Using enhanced PAT token for repository operations\"\n      export GITHUB_TOKEN=\"${{ secrets.GH_TOKEN }}\"\n    else\n      echo \"\u26a0\ufe0f PAT token not available, using default token (limited permissions)\"\n      export GITHUB_TOKEN=\"${{ secrets.GITHUB_TOKEN }}\"\n    fi\n\n  template_cleanup: |\n    # Remove template-specific content after initialization\n    rm -rf doc/ .claude/ CLAUDE.md\n    git add -A\n    git commit -m \"chore: clean up template-specific content\"\n</code></pre>"},{"location":"decisions/adr_007_bootstrap/#implementation-strategy","title":"Implementation Strategy","text":""},{"location":"decisions/adr_007_bootstrap/#material-shield-check-key-design-elements","title":":material-shield-check Key Design Elements","text":""},{"location":"decisions/adr_007_bootstrap/#idempotent-operations","title":"Idempotent Operations","text":"<pre><code># Safe to run multiple times without issues\nidempotent_design:\n  update_checking: \"Only updates workflows if template version is newer\"\n  change_detection: \"git diff --staged --quiet prevents unnecessary commits\"\n  conflict_avoidance: \"Checks for local modifications before attempting updates\"\n  graceful_skipping: \"Skips operations that would cause conflicts or errors\"\n</code></pre>"},{"location":"decisions/adr_007_bootstrap/#transparent-process","title":"Transparent Process","text":"<pre><code># Visible workflow update process\ntransparency:\n  commit_history: \"Workflow updates appear as commits in repository history\"\n  update_messages: \"Clear commit messages explain what was updated and why\"\n  user_communication: \"Initialization issue documents bootstrap process\"\n  error_reporting: \"Clear error messages when bootstrap operations fail\"\n</code></pre>"},{"location":"decisions/adr_007_bootstrap/#security-and-reliability","title":"Security and Reliability","text":"<pre><code># Secure and reliable bootstrap process\nsecurity_reliability:\n  same_permissions: \"Uses existing repository permissions, no external dependencies\"\n  template_verification: \"Verifies template repository authenticity before updates\"\n  fallback_execution: \"Proceeds with current version if updates fail\"\n  audit_trail: \"Complete record of bootstrap operations in git history\"\n</code></pre>"},{"location":"decisions/adr_007_bootstrap/#benefits-and-rationale","title":"Benefits and Rationale","text":""},{"location":"decisions/adr_007_bootstrap/#material-trending-up-strategic-advantages","title":":material-trending-up Strategic Advantages","text":""},{"location":"decisions/adr_007_bootstrap/#automatic-fix-distribution","title":"Automatic Fix Distribution","text":"<ul> <li>All template improvements immediately available to new repository deployments</li> <li>Critical fixes like <code>--allow-unrelated-histories</code> and merge conflict resolution reach users automatically</li> <li>Enhanced permission handling and secret creation capabilities distributed seamlessly</li> <li>Template cleanup and customization improvements available without manual intervention</li> </ul>"},{"location":"decisions/adr_007_bootstrap/#enhanced-user-experience","title":"Enhanced User Experience","text":"<ul> <li>Initialization \"just works\" with latest fixes, reducing user friction significantly</li> <li>Users don't encounter previously-fixed issues, eliminating support burden</li> <li>Transparent update process maintains user confidence in initialization reliability</li> <li>Clear error messages and fallbacks provide guidance when issues occur</li> </ul>"},{"location":"decisions/adr_007_bootstrap/#maintainability-excellence","title":"Maintainability Excellence","text":"<ul> <li>Single source of truth for initialization logic eliminates version management complexity</li> <li>Simplified support process as old version issues are automatically resolved</li> <li>Traceable updates provide complete audit trail of initialization improvements</li> <li>Self-updating capability reduces manual coordination overhead for template improvements</li> </ul>"},{"location":"decisions/adr_007_bootstrap/#material-cog-outline-technical-architecture-benefits","title":":material-cog-outline Technical Architecture Benefits","text":""},{"location":"decisions/adr_007_bootstrap/#bootstrap-problem-resolution","title":"Bootstrap Problem Resolution","text":"<ul> <li>Eliminates chicken-and-egg problem inherent in template-based initialization</li> <li>Ensures latest initialization logic available regardless of template creation timing</li> <li>Provides systematic mechanism for propagating critical fixes to new deployments</li> <li>Maintains template repository as authoritative source for initialization improvements</li> </ul>"},{"location":"decisions/adr_007_bootstrap/#robust-error-handling","title":"Robust Error Handling","text":"<ul> <li>Graceful degradation when template repository unavailable or inaccessible</li> <li>Permission-aware operations that adapt to available token capabilities</li> <li>Conflict prevention through local modification detection before updates</li> <li>Clear communication of bootstrap status and any limitations encountered</li> </ul>"},{"location":"decisions/adr_007_bootstrap/#alternative-approaches-considered","title":"Alternative Approaches Considered","text":""},{"location":"decisions/adr_007_bootstrap/#manual-workaround-documentation","title":"Manual Workaround Documentation","text":"<p>Approach: Document manual commands for users when initialization fails</p> <ul> <li>Pros: Simple implementation, no code changes required</li> <li>Cons: Poor user experience, requires technical knowledge, defeats automation purpose</li> <li>Decision: Rejected - Goes against template's automation and user experience goals</li> </ul>"},{"location":"decisions/adr_007_bootstrap/#pre-create-all-branches-in-template","title":"Pre-create All Branches in Template","text":"<p>Approach: Include fork_upstream and fork_integration branches in template repository</p> <ul> <li>Pros: Might avoid unrelated histories issue during initialization</li> <li>Cons: Pollutes template with upstream-specific content, doesn't solve workflow updates</li> <li>Decision: Rejected - Doesn't address root cause and compromises template cleanliness</li> </ul>"},{"location":"decisions/adr_007_bootstrap/#external-initialization-script","title":"External Initialization Script","text":"<p>Approach: Separate script hosted externally that gets downloaded and executed</p> <ul> <li>Pros: Always runs latest version, complete control over initialization process</li> <li>Cons: External dependency, security concerns, network reliability issues</li> <li>Decision: Rejected - Adds unnecessary external dependencies and security complexity</li> </ul>"},{"location":"decisions/adr_007_bootstrap/#versioned-workflow-pinning","title":"Versioned Workflow Pinning","text":"<p>Approach: Pin workflows to specific versions with manual update process</p> <ul> <li>Pros: Predictable behavior, controlled update timing</li> <li>Cons: Requires manual intervention, doesn't solve immediate fix propagation</li> <li>Decision: Rejected - Doesn't address automatic fix distribution requirement</li> </ul>"},{"location":"decisions/adr_007_bootstrap/#consequences-and-trade-offs","title":"Consequences and Trade-offs","text":""},{"location":"decisions/adr_007_bootstrap/#positive-outcomes","title":"Positive Outcomes","text":""},{"location":"decisions/adr_007_bootstrap/#initialization-reliability-excellence","title":"Initialization Reliability Excellence","text":"<ul> <li>New repositories always use latest initialization workflow with all fixes</li> <li>Critical fixes immediately available without manual coordination or user intervention</li> <li>Users don't encounter previously-fixed initialization issues, improving satisfaction</li> <li>Template improvements automatically benefit all future repository deployments</li> </ul>"},{"location":"decisions/adr_007_bootstrap/#support-and-maintenance-efficiency","title":"Support and Maintenance Efficiency","text":"<ul> <li>Simplified support process as old version issues are automatically resolved</li> <li>Reduced coordination overhead for template improvements and fix distribution</li> <li>Clear audit trail through git history shows workflow update progression</li> <li>Self-contained process requires no external dependencies or infrastructure</li> </ul>"},{"location":"decisions/adr_007_bootstrap/#user-experience-enhancement","title":"User Experience Enhancement","text":"<ul> <li>Transparent workflow update process maintains user confidence and understanding</li> <li>Graceful error handling provides clear guidance when issues occur</li> <li>Automatic cleanup and customization improvements enhance repository initialization</li> <li>Consistent behavior across all repository deployments regardless of creation timing</li> </ul>"},{"location":"decisions/adr_007_bootstrap/#trade-offs-and-limitations","title":"Trade-offs and Limitations","text":""},{"location":"decisions/adr_007_bootstrap/#process-complexity","title":"Process Complexity","text":"<ul> <li>Two-phase initialization adds complexity compared to single-step process</li> <li>Additional commit created in repository history documenting workflow updates</li> <li>Potential for conflicts if users modify workflows before initialization completes</li> <li>Dependency on template repository remaining accessible for bootstrap updates</li> </ul>"},{"location":"decisions/adr_007_bootstrap/#edge-case-considerations","title":"Edge Case Considerations","text":"<ul> <li>Bootstrap process may fail if template repository becomes unavailable</li> <li>Permission limitations may prevent workflow updates in some repository contexts</li> <li>Local workflow modifications may prevent automatic updates to avoid conflicts</li> <li>Network issues during template fetch may delay or prevent bootstrap updates</li> </ul>"},{"location":"decisions/adr_007_bootstrap/#success-metrics","title":"Success Metrics","text":""},{"location":"decisions/adr_007_bootstrap/#quantitative-indicators","title":"Quantitative Indicators","text":"<ul> <li>Fix Propagation Speed: 100% of new repositories receive latest initialization fixes</li> <li>Bootstrap Success Rate: &gt;99% successful workflow bootstrap operations</li> <li>User Issue Reduction: Zero user reports of previously-fixed initialization problems</li> <li>Template Cleanup Success: 100% of repositories receive proper template artifact cleanup</li> </ul>"},{"location":"decisions/adr_007_bootstrap/#qualitative-indicators","title":"Qualitative Indicators","text":"<ul> <li>Users report smooth initialization experience without manual intervention required</li> <li>Clear understanding of bootstrap process through transparent workflow updates</li> <li>Effective error handling provides actionable guidance when issues occur</li> <li>Consistent initialization behavior across all repository deployments</li> </ul>"},{"location":"decisions/adr_007_bootstrap/#integration-points","title":"Integration Points","text":""},{"location":"decisions/adr_007_bootstrap/#material-source-branch-initialization-workflow-integration","title":":material-source-branch Initialization Workflow Integration","text":""},{"location":"decisions/adr_007_bootstrap/#two-workflow-initialization-pattern-per-adr-006","title":"Two-Workflow Initialization Pattern (per ADR-006)","text":"<ul> <li>Bootstrap pattern builds upon two-workflow pattern with self-update capability</li> <li>Phase separation enables clean bootstrap update before core initialization logic</li> <li>Enhanced error handling coordinates with user interface and repository setup workflows</li> </ul>"},{"location":"decisions/adr_007_bootstrap/#template-repository-pattern-per-adr-003","title":"Template Repository Pattern (per ADR-003)","text":"<ul> <li>Self-updating capability aligns with template-based architecture principles</li> <li>Bootstrap process maintains template repository as authoritative source</li> <li>Automatic fix distribution extends template benefits to initialization process</li> </ul>"},{"location":"decisions/adr_007_bootstrap/#material-update-template-improvement-distribution","title":":material-update Template Improvement Distribution","text":""},{"location":"decisions/adr_007_bootstrap/#template-update-propagation-per-adr-012","title":"Template Update Propagation (per ADR-012)","text":"<ul> <li>Bootstrap pattern complements template sync for ongoing repository maintenance</li> <li>Self-update capability provides immediate fix distribution for new repositories</li> <li>Coordinates with systematic template update propagation for existing repositories</li> </ul>"},{"location":"decisions/adr_007_bootstrap/#related-decisions","title":"Related Decisions","text":"<ul> <li>ADR-006: Two-workflow initialization pattern provides foundation for bootstrap enhancement</li> <li>ADR-003: Template repository pattern aligns with self-updating architecture</li> <li>ADR-012: Template update propagation coordinates with bootstrap for comprehensive fix distribution</li> </ul> <p>This initialization workflow bootstrap pattern ensures that all template improvements and critical fixes immediately reach new repository deployments through self-updating workflows, eliminating the bootstrap problem while maintaining user experience and system reliability.</p>"},{"location":"decisions/adr_008_labels/","title":"ADR-008: Centralized Label Management Strategy","text":"<p> Critical Decision |  2025-05-28 |  Accepted</p>"},{"location":"decisions/adr_008_labels/#problem-statement","title":"Problem Statement","text":"<p>The Fork Management Template uses GitHub labels extensively to track workflow states, issue types, and PR statuses across multiple automated workflows. The original distributed approach where each workflow created its own labels created reliability, consistency, and maintainability challenges that undermined automation effectiveness.</p>"},{"location":"decisions/adr_008_labels/#context-and-requirements","title":"Context and Requirements","text":""},{"location":"decisions/adr_008_labels/#distributed-label-management-problems","title":"Distributed Label Management Problems","text":"<p>Workflow Dependencies and Reliability: - Labels didn't exist until specific workflows executed, potentially breaking automation - New workflows couldn't reliably depend on required labels being available - Race conditions when multiple workflows tried to create the same labels - Failed workflows could leave label creation incomplete, breaking subsequent automation</p> <p>Consistency and Maintenance Issues: - No single source of truth for label definitions across the system - Inconsistent label colors, descriptions, and naming conventions - Difficult to maintain and document comprehensive label usage patterns - Each workflow implementation contained its own label creation logic</p> <p>Distributed Creation Pattern Problems: <pre><code># Problematic distributed approach\nsync_workflow: \"Creates sync-related labels during first run\"\ninit_workflow: \"Creates initialization labels when triggered\"\ndependabot_workflow: \"Creates dependency labels as needed\"\ncascade_workflow: \"Requires additional state-tracking labels\"\n</code></pre></p>"},{"location":"decisions/adr_008_labels/#label-management-requirements","title":"Label Management Requirements","text":"<p>Centralized Definition: Single source of truth for all system labels with consistent formatting and documentation.</p> <p>Initialization Guarantee: All required labels available from repository initialization without workflow execution dependencies.</p> <p>Automation Reliability: Workflows can assume label existence and focus on core functionality rather than infrastructure setup.</p>"},{"location":"decisions/adr_008_labels/#decision","title":"Decision","text":"<p>Implement a centralized label management strategy with comprehensive initialization and maintenance:</p> <pre><code>graph TD\n    A[Repository Creation] --&gt; B[Initialization Workflow]\n    B --&gt; C[Read .github/labels.json]\n    C --&gt; D[Create All System Labels]\n    D --&gt; E[Workflows Execute]\n    E --&gt; F[Assume Labels Exist]\n\n    G[Label Updates] --&gt; H[Modify labels.json]\n    H --&gt; I[Git Commit]\n    I --&gt; J[Re-run Label Creation]\n\n    style A fill:#e1f5fe,stroke:#01579b,stroke-width:2px\n    style D fill:#e8f5e9,stroke:#1b5e20,stroke-width:2px\n    style F fill:#fff3e0,stroke:#e65100,stroke-width:2px\n    style J fill:#fce4ec,stroke:#c2185b,stroke-width:2px</code></pre>"},{"location":"decisions/adr_008_labels/#material-file-document-outline-centralized-configuration-architecture","title":":material-file-document-outline Centralized Configuration Architecture","text":""},{"location":"decisions/adr_008_labels/#single-source-of-truth","title":"Single Source of Truth","text":"<pre><code># .github/labels.json structure\nlabel_configuration:\n  location: \".github/labels.json\"\n  format: \"Structured JSON with name, description, color\"\n  versioning: \"Git-tracked with complete change history\"\n  documentation: \"Self-documenting through descriptive names and descriptions\"\n</code></pre>"},{"location":"decisions/adr_008_labels/#comprehensive-label-taxonomy","title":"Comprehensive Label Taxonomy","text":"<pre><code>{\n  \"labels\": [\n    {\n      \"name\": \"upstream-sync\",\n      \"description\": \"Issues related to upstream repository synchronization\",\n      \"color\": \"1976d2\"\n    },\n    {\n      \"name\": \"cascade-active\", \n      \"description\": \"Currently processing through cascade integration pipeline\",\n      \"color\": \"0e8a16\"\n    },\n    {\n      \"name\": \"human-required\",\n      \"description\": \"Requires human intervention or review\",\n      \"color\": \"d73a49\"\n    },\n    {\n      \"name\": \"conflict\",\n      \"description\": \"Merge conflicts requiring manual resolution\",\n      \"color\": \"e53e3e\"\n    }\n  ]\n}\n</code></pre>"},{"location":"decisions/adr_008_labels/#material-cog-automated-label-creation-process","title":":material-cog Automated Label Creation Process","text":""},{"location":"decisions/adr_008_labels/#initialization-workflow-integration","title":"Initialization Workflow Integration","text":"<pre><code># Enhanced initialization with label creation\nname: \"Create all system labels\"\nimplementation: |\n  # Read and parse label configuration\n  labels=$(cat .github/labels.json | jq -r '.labels[] | @base64')\n\n  for label in $labels; do\n    # Decode and extract label properties\n    decoded=$(echo $label | base64 --decode)\n    name=$(echo $decoded | jq -r '.name')\n    description=$(echo $decoded | jq -r '.description')  \n    color=$(echo $decoded | jq -r '.color')\n\n    # Create or update label with full properties\n    gh label create \"$name\" \\\n      --description \"$description\" \\\n      --color \"$color\" \\\n      --force\n  done\n</code></pre>"},{"location":"decisions/adr_008_labels/#workflow-assumption-pattern","title":"Workflow Assumption Pattern","text":"<pre><code># Workflows now operate with label assumptions\nworkflow_pattern:\n  assumption: \"All required labels exist from initialization\"\n  usage: \"Direct label application without creation logic\"\n  reliability: \"No workflow failures due to missing labels\"\n\n  example: |\n    # Simple, reliable label application\n    gh issue create \\\n      --title \"Upstream sync ready for review\" \\\n      --body \"$NOTIFICATION_BODY\" \\\n      --label \"upstream-sync,human-required\"\n</code></pre>"},{"location":"decisions/adr_008_labels/#implementation-strategy","title":"Implementation Strategy","text":""},{"location":"decisions/adr_008_labels/#material-timeline-check-label-lifecycle-management","title":":material-timeline-check Label Lifecycle Management","text":""},{"location":"decisions/adr_008_labels/#complete-label-taxonomy","title":"Complete Label Taxonomy","text":"<pre><code># Comprehensive system label categories\nlabel_categories:\n  workflow_state:\n    - cascade-active: Integration pipeline in progress\n    - cascade-blocked: Integration blocked by conflicts\n    - production-ready: Ready for production deployment\n    - validated: Integration complete and validated\n\n  issue_types:\n    - upstream-sync: Upstream synchronization activities\n    - conflict: Merge conflicts requiring resolution\n    - escalation: Issues exceeding SLA timeouts\n    - template-sync: Template update activities\n\n  priority_levels:\n    - high-priority: Urgent items requiring immediate attention\n    - emergency: Critical system issues needing escalation\n\n  human_interaction:\n    - human-required: Requires human intervention or review\n    - review-needed: Code review or validation required\n</code></pre>"},{"location":"decisions/adr_008_labels/#color-scheme-standardization","title":"Color Scheme Standardization","text":"<pre><code># Consistent color palette\ncolor_scheme:\n  workflow_active: \"0e8a16\" # Green - active processes\n  workflow_blocked: \"e53e3e\" # Red - blocked or failed states  \n  human_required: \"d73a49\" # Dark red - human intervention needed\n  information: \"1976d2\" # Blue - informational or tracking\n  priority_high: \"ff6b35\" # Orange - high priority items\n  emergency: \"b71c1c\" # Dark red - emergency situations\n</code></pre>"},{"location":"decisions/adr_008_labels/#material-refresh-label-maintenance-process","title":":material-refresh Label Maintenance Process","text":""},{"location":"decisions/adr_008_labels/#update-workflow","title":"Update Workflow","text":"<pre><code># Label modification process\nupdate_process:\n  modify: \"Edit .github/labels.json with new definitions\"\n  commit: \"Git commit tracks all label changes\"\n  deploy: \"Re-run label creation during next initialization\"\n  verify: \"Confirm labels applied correctly across repository\"\n</code></pre>"},{"location":"decisions/adr_008_labels/#migration-strategy","title":"Migration Strategy","text":"<pre><code># Existing repository migration\nmigration_approach:\n  audit: \"Identify existing labels and their usage\"\n  consolidate: \"Map existing labels to centralized definitions\"\n  update: \"Apply new label configuration\"\n  cleanup: \"Remove orphaned or deprecated labels\"\n</code></pre>"},{"location":"decisions/adr_008_labels/#benefits-and-rationale","title":"Benefits and Rationale","text":""},{"location":"decisions/adr_008_labels/#material-trending-up-strategic-advantages","title":":material-trending-up Strategic Advantages","text":""},{"location":"decisions/adr_008_labels/#system-reliability-enhancement","title":"System Reliability Enhancement","text":"<ul> <li>All labels exist from repository initialization, eliminating dependency failures</li> <li>Workflows can assume label availability and focus on core functionality</li> <li>Automation reliability improves through consistent infrastructure setup</li> <li>Race conditions eliminated through initialization-time label creation</li> </ul>"},{"location":"decisions/adr_008_labels/#maintainability-and-consistency","title":"Maintainability and Consistency","text":"<ul> <li>Single source of truth for all label definitions simplifies management</li> <li>Consistent naming conventions and color schemes across entire system</li> <li>Git-tracked changes provide complete audit trail for label evolution</li> <li>Self-documenting configuration through descriptive names and descriptions</li> </ul>"},{"location":"decisions/adr_008_labels/#development-experience-improvement","title":"Development Experience Improvement","text":"<ul> <li>Workflows simplified through elimination of label creation logic</li> <li>New workflow development accelerated by guaranteed label availability</li> <li>Clear documentation of available labels for development planning</li> <li>Reduced debugging complexity through consistent label infrastructure</li> </ul>"},{"location":"decisions/adr_008_labels/#material-cog-outline-operational-benefits","title":":material-cog-outline Operational Benefits","text":""},{"location":"decisions/adr_008_labels/#documentation-and-visibility","title":"Documentation and Visibility","text":"<ul> <li>Complete label set visible from repository creation</li> <li>Self-documenting configuration eliminates need for separate documentation</li> <li>Label usage patterns clearly visible through centralized definitions</li> <li>Easy customization for specific organizational requirements</li> </ul>"},{"location":"decisions/adr_008_labels/#automation-architecture","title":"Automation Architecture","text":"<ul> <li>Workflows can depend on label existence without conditional logic</li> <li>Simplified workflow code through infrastructure assumption patterns</li> <li>Better error handling focus on business logic rather than setup issues</li> <li>Consistent automation behavior across all template deployments</li> </ul>"},{"location":"decisions/adr_008_labels/#alternative-approaches-considered","title":"Alternative Approaches Considered","text":""},{"location":"decisions/adr_008_labels/#distributed-workflow-specific-creation","title":"Distributed Workflow-Specific Creation","text":"<p>Approach: Each workflow manages its own required labels</p> <ul> <li>Pros: Self-contained workflows, no external dependencies</li> <li>Cons: Reliability issues, inconsistent definitions, maintenance overhead</li> <li>Decision: Rejected due to fundamental reliability and consistency problems</li> </ul>"},{"location":"decisions/adr_008_labels/#external-label-management-service","title":"External Label Management Service","text":"<p>Approach: Third-party service for label management across repositories</p> <ul> <li>Pros: Advanced management capabilities, cross-repository coordination</li> <li>Cons: External dependency, additional complexity, cost considerations</li> <li>Decision: Rejected due to template self-containment requirements</li> </ul>"},{"location":"decisions/adr_008_labels/#manual-label-creation-documentation","title":"Manual Label Creation Documentation","text":"<p>Approach: Documentation-based label setup requiring manual configuration</p> <ul> <li>Pros: Simple approach, complete control over implementation</li> <li>Cons: Error-prone, inconsistent application, manual maintenance burden</li> <li>Decision: Rejected due to automation goals and user experience requirements</li> </ul>"},{"location":"decisions/adr_008_labels/#dynamic-label-creation-with-caching","title":"Dynamic Label Creation with Caching","text":"<p>Approach: Workflows create labels with intelligent caching and checking</p> <ul> <li>Pros: Automated creation with some reliability improvements</li> <li>Cons: Still complex, potential race conditions, distributed logic</li> <li>Decision: Rejected in favor of simpler centralized approach</li> </ul>"},{"location":"decisions/adr_008_labels/#consequences-and-trade-offs","title":"Consequences and Trade-offs","text":""},{"location":"decisions/adr_008_labels/#positive-outcomes","title":"Positive Outcomes","text":""},{"location":"decisions/adr_008_labels/#enhanced-system-reliability","title":"Enhanced System Reliability","text":"<ul> <li>Zero workflow failures due to missing label dependencies</li> <li>Consistent automation behavior across all repository instances</li> <li>Simplified workflow logic through infrastructure assumption patterns</li> <li>Improved error handling focus on business logic rather than setup</li> </ul>"},{"location":"decisions/adr_008_labels/#improved-maintainability","title":"Improved Maintainability","text":"<ul> <li>Single location for all label definitions simplifies management</li> <li>Git-tracked changes provide complete audit trail for modifications</li> <li>Easy addition, updating, or removal of labels through configuration</li> <li>Self-documenting system through descriptive label properties</li> </ul>"},{"location":"decisions/adr_008_labels/#better-development-experience","title":"Better Development Experience","text":"<ul> <li>Workflows can assume label availability without conditional checking</li> <li>New workflow development accelerated by guaranteed infrastructure</li> <li>Clear visibility into available labels for development planning</li> <li>Consistent behavior across different template deployment contexts</li> </ul>"},{"location":"decisions/adr_008_labels/#trade-offs-and-limitations","title":"Trade-offs and Limitations","text":""},{"location":"decisions/adr_008_labels/#initialization-dependencies","title":"Initialization Dependencies","text":"<ul> <li>Workflows depend on initialization running successfully before execution</li> <li>Slightly longer repository setup process due to comprehensive label creation</li> <li>Migration required for existing repositories to adopt centralized approach</li> </ul>"},{"location":"decisions/adr_008_labels/#configuration-management","title":"Configuration Management","text":"<ul> <li>Label changes require modifying configuration file rather than ad-hoc creation</li> <li>Need to understand JSON configuration format for label modifications</li> <li>Coordination required when multiple developers need to add labels simultaneously</li> </ul>"},{"location":"decisions/adr_008_labels/#success-metrics","title":"Success Metrics","text":""},{"location":"decisions/adr_008_labels/#quantitative-indicators","title":"Quantitative Indicators","text":"<ul> <li>Workflow Reliability: 100% workflow success rate (zero label-related failures)</li> <li>Setup Time: Repository initialization completion within expected timeframe</li> <li>Label Consistency: All labels follow standardized naming and color conventions</li> <li>Maintenance Effort: Reduced time spent on label-related workflow debugging</li> </ul>"},{"location":"decisions/adr_008_labels/#qualitative-indicators","title":"Qualitative Indicators","text":"<ul> <li>Developers report improved confidence in workflow reliability</li> <li>Simplified workflow code through elimination of label creation logic</li> <li>Clear understanding of available labels for new workflow development</li> <li>Consistent behavior across all template repository deployments</li> </ul>"},{"location":"decisions/adr_008_labels/#integration-points","title":"Integration Points","text":""},{"location":"decisions/adr_008_labels/#material-source-branch-workflow-integration","title":":material-source-branch Workflow Integration","text":""},{"location":"decisions/adr_008_labels/#initialization-workflow-coordination","title":"Initialization Workflow Coordination","text":"<ul> <li>Label creation integrated into repository setup process</li> <li>All system labels available before other workflows execute</li> <li>Template deployment includes complete label infrastructure</li> </ul>"},{"location":"decisions/adr_008_labels/#cross-workflow-dependencies","title":"Cross-Workflow Dependencies","text":"<ul> <li>All workflows assume label existence without creation logic</li> <li>Consistent label usage patterns across different automation workflows</li> <li>Simplified error handling through guaranteed infrastructure availability</li> </ul>"},{"location":"decisions/adr_008_labels/#material-label-multiple-outline-label-usage-patterns","title":":material-label-multiple-outline Label Usage Patterns","text":""},{"location":"decisions/adr_008_labels/#state-management-integration","title":"State Management Integration","text":"<ul> <li>Workflow state tracking through lifecycle labels</li> <li>Issue and PR status coordination through consistent labeling</li> <li>Human intervention coordination through human-required labeling</li> </ul>"},{"location":"decisions/adr_008_labels/#related-decisions","title":"Related Decisions","text":"<ul> <li>ADR-006: Two-workflow initialization pattern provides foundation for label creation</li> <li>ADR-020: Human-required label strategy builds on centralized management</li> <li>ADR-019: Cascade monitor pattern relies on centralized label definitions</li> <li>ADR-022: Issue lifecycle tracking uses centralized label taxonomy</li> </ul> <p>This centralized label management strategy provides reliable, maintainable infrastructure for GitHub automation through consistent label definitions and guaranteed availability, enabling sophisticated workflow coordination while simplifying development and maintenance.</p>"},{"location":"decisions/adr_009_review_strategy/","title":"ADR-009: Asymmetric Cascade Review Strategy","text":"<p> Critical Decision |  2025-05-28 |  Accepted |  Revised 2025-06-29</p>"},{"location":"decisions/adr_009_review_strategy/#problem-statement","title":"Problem Statement","text":"<p>The cascade workflow moves upstream changes through a three-branch hierarchy requiring careful balance between automation efficiency and safety controls. With human-centric cascade triggering and issue lifecycle tracking implemented, a strategic review approach was needed to ensure proper validation while minimizing unnecessary manual intervention.</p>"},{"location":"decisions/adr_009_review_strategy/#context-and-requirements","title":"Context and Requirements","text":""},{"location":"decisions/adr_009_review_strategy/#cascade-review-challenges","title":"Cascade Review Challenges","text":"<p>Multi-Stage Risk Assessment: - Upstream changes are external and potentially breaking, requiring careful evaluation - Integration branch serves as testing ground but needs validation to be meaningful - Main branch represents production and must maintain absolute stability - Different risk profiles exist at each cascade stage requiring tailored approaches</p> <p>Human Control and Automation Balance: - Manual cascade triggering provides explicit human control over integration timing - Conflict resolution always requires human intervention regardless of automation - Issue tracking provides visibility but teams need clear review expectations - Validation failures must be clearly communicated with actionable resolution guidance</p> <p>Quality Assurance Integration: - Comprehensive validation (build, test, lint) needed before production deployment - Early detection of issues prevents problems from reaching production branch - Clear quality gates required to maintain integration branch integrity - Detailed failure tracking with logs and resolution steps for troubleshooting</p>"},{"location":"decisions/adr_009_review_strategy/#material-target-review-strategy-requirements","title":":material-target Review Strategy Requirements","text":"<p>Safety-First Architecture: External changes receive appropriate human review at critical decision points while maintaining efficiency.</p> <p>Production Protection: All production changes require final human oversight with comprehensive validation before deployment.</p> <p>Efficient Workflow: Minimize unnecessary manual intervention while maintaining safety and quality standards.</p>"},{"location":"decisions/adr_009_review_strategy/#decision","title":"Decision","text":"<p>Implement an Asymmetric Cascade Review Strategy with differentiated approaches for each cascade stage:</p> <pre><code>graph TD\n    A[Upstream Sync PR] --&gt; B[Human Review &amp; Merge]\n    B --&gt; C[Manual Cascade Trigger]\n    C --&gt; D[fork_upstream \u2192 fork_integration]\n    D --&gt; E[Comprehensive Validation]\n    E --&gt; F{Validation Pass?}\n    F --&gt;|Yes| G[Create Production PR]\n    F --&gt;|No| H[Block Cascade]\n    H --&gt; I[Create Failure Issue]\n    I --&gt; J[Human Resolution]\n    J --&gt; K[Retry Cascade]\n    K --&gt; E\n    G --&gt; L[fork_integration \u2192 main]\n    L --&gt; M[Human Review Required]\n    M --&gt; N[Manual Approval &amp; Merge]\n    N --&gt; O[Production Deployment]\n\n    style A fill:#e1f5fe,stroke:#01579b,stroke-width:2px\n    style C fill:#e8f5e9,stroke:#1b5e20,stroke-width:2px\n    style E fill:#fff3e0,stroke:#e65100,stroke-width:2px\n    style M fill:#fce4ec,stroke:#c2185b,stroke-width:2px</code></pre>"},{"location":"decisions/adr_009_review_strategy/#material-shield-check-phase-1-human-initiated-integration-with-comprehensive-validation","title":":material-shield-check Phase 1: Human-Initiated Integration with Comprehensive Validation","text":""},{"location":"decisions/adr_009_review_strategy/#manual-trigger-with-issue-tracking-integration","title":"Manual Trigger with Issue Tracking Integration","text":"<pre><code># Human-initiated cascade after upstream sync review\nphase_1_integration:\n  trigger: \"Manual cascade trigger after sync PR review and merge\"\n\n  process_flow: |\n    # Human triggers cascade workflow manually\n    # Cascade workflow updates issue tracking immediately\n    gh issue edit \"$ISSUE_NUMBER\" \\\n      --remove-label \"human-required\" \\\n      --add-label \"cascade-active\"\n\n    # Progress notification\n    gh issue comment \"$ISSUE_NUMBER\" --body \"\ud83d\ude80 **Cascade Integration Started** - $(date -u +%Y-%m-%dT%H:%M:%SZ)\n\n    Integration workflow triggered manually and now processing upstream changes.\n\n    **Phase 1:** Merging \\`fork_upstream\\` \u2192 \\`fork_integration\\`\n    **Validation:** Comprehensive build, test, and lint checks will run\"\n</code></pre>"},{"location":"decisions/adr_009_review_strategy/#comprehensive-validation-framework","title":"Comprehensive Validation Framework","text":"<pre><code># Extensive validation on integration branch\nvalidation_framework:\n  merge_validation: |\n    # Attempt merge with conflict detection\n    if git merge origin/fork_upstream --no-edit; then\n      echo \"\u2705 Clean merge of upstream changes achieved\"\n      echo \"conflicts=false\" &gt;&gt; $GITHUB_OUTPUT\n    else\n      echo \"\ud83d\udea8 Merge conflicts detected - human resolution required\"\n      echo \"conflicts=true\" &gt;&gt; $GITHUB_OUTPUT\n      # Update issue tracking and create conflict issue\n    fi\n\n  build_validation: |\n    # Comprehensive build validation\n    if ./scripts/build.sh; then\n      echo \"\u2705 Build validation passed\"\n      echo \"build_success=true\" &gt;&gt; $GITHUB_OUTPUT\n    else\n      echo \"\u274c Build validation failed\"\n      echo \"build_success=false\" &gt;&gt; $GITHUB_OUTPUT\n      # Capture build logs for failure issue\n    fi\n\n  test_validation: |\n    # Complete test suite execution\n    if ./scripts/test.sh; then\n      echo \"\u2705 Test validation passed\"  \n      echo \"test_success=true\" &gt;&gt; $GITHUB_OUTPUT\n    else\n      echo \"\u274c Test validation failed\"\n      echo \"test_success=false\" &gt;&gt; $GITHUB_OUTPUT\n      # Capture test logs for failure issue\n    fi\n\n  lint_validation: |\n    # Code quality and style validation\n    if ./scripts/lint.sh; then\n      echo \"\u2705 Lint validation passed\"\n      echo \"lint_success=true\" &gt;&gt; $GITHUB_OUTPUT\n    else\n      echo \"\u274c Lint validation failed\"\n      echo \"lint_success=false\" &gt;&gt; $GITHUB_OUTPUT\n      # Capture lint logs for failure issue\n    fi\n</code></pre>"},{"location":"decisions/adr_009_review_strategy/#validation-failure-handling","title":"Validation Failure Handling","text":"<pre><code># Detailed failure tracking and resolution guidance\nvalidation_failure_handling:\n  failure_detection: |\n    # Check if any validation failed\n    if [[ \"${{ steps.validation.outputs.conflicts }}\" == \"true\" ]] || \\\n       [[ \"${{ steps.validation.outputs.build_success }}\" == \"false\" ]] || \\\n       [[ \"${{ steps.validation.outputs.test_success }}\" == \"false\" ]] || \\\n       [[ \"${{ steps.validation.outputs.lint_success }}\" == \"false\" ]]; then\n      echo \"validation_failed=true\" &gt;&gt; $GITHUB_OUTPUT\n    fi\n\n  failure_issue_creation: |\n    # Create detailed failure issue with logs and resolution steps\n    FAILURE_BODY=\"## \ud83d\udea8 Cascade Validation Failure\n\n    Integration validation failed during cascade process. Manual resolution required.\n\n    **Failure Summary:**\n    - **Conflicts:** ${{ steps.validation.outputs.conflicts }}\n    - **Build:** ${{ steps.validation.outputs.build_success }}\n    - **Tests:** ${{ steps.validation.outputs.test_success }}\n    - **Lint:** ${{ steps.validation.outputs.lint_success }}\n\n    **Resolution Steps:**\n    1. Checkout the fork_integration branch locally\n    2. Address the specific validation failures listed above\n    3. Commit and push fixes to fork_integration\n    4. Remove 'human-required' label from tracking issue to retry cascade\n\n    **Logs and Details:**\n    [Detailed failure logs attached]\"\n\n    gh issue create \\\n      --title \"\ud83d\udea8 Cascade Validation Failure - $(date +%Y-%m-%d)\" \\\n      --body \"$FAILURE_BODY\" \\\n      --label \"cascade-failed,human-required,high-priority\"\n</code></pre>"},{"location":"decisions/adr_009_review_strategy/#material-security-phase-2-production-pr-creation-with-human-review-requirement","title":":material-security Phase 2: Production PR Creation with Human Review Requirement","text":""},{"location":"decisions/adr_009_review_strategy/#conditional-production-pr-creation","title":"Conditional Production PR Creation","text":"<pre><code># Production PR only created after successful validation\nphase_2_production:\n  condition: \"Only proceeds if all validation passes and no conflicts detected\"\n\n  pr_creation: |\n    # Only create production PR if integration validation successful\n    if [[ \"${{ steps.validation.outputs.validation_failed }}\" != \"true\" ]]; then\n      # Create production release branch\n      RELEASE_BRANCH=\"release/upstream-$(date +%Y%m%d-%H%M%S)\"\n      git checkout -b \"$RELEASE_BRANCH\" fork_integration\n      git push origin \"$RELEASE_BRANCH\"\n\n      # Create production PR with human review requirement\n      PR_URL=$(gh pr create \\\n        --base main \\\n        --head \"$RELEASE_BRANCH\" \\\n        --title \"\ud83d\ude80 Production Release: Upstream Integration - $(date +%Y-%m-%d)\" \\\n        --body \"$PRODUCTION_PR_BODY\" \\\n        --label \"upstream-sync,human-required,production\")\n\n      echo \"production_pr_created=true\" &gt;&gt; $GITHUB_OUTPUT\n      echo \"production_pr_url=$PR_URL\" &gt;&gt; $GITHUB_OUTPUT\n    else\n      echo \"Skipping production PR creation due to validation failures\"\n      echo \"production_pr_created=false\" &gt;&gt; $GITHUB_OUTPUT\n    fi\n</code></pre>"},{"location":"decisions/adr_009_review_strategy/#production-pr-content-and-guidance","title":"Production PR Content and Guidance","text":"<pre><code># Comprehensive production PR with review guidance\nproduction_pr_content:\n  pr_body_template: |\n    ## \ud83d\ude80 Production Release: Upstream Integration\n\n    This PR contains upstream changes that have been successfully validated in the integration branch.\n\n    **Integration Validation Results:**\n    - \u2705 **Merge:** Clean merge without conflicts\n    - \u2705 **Build:** All build processes completed successfully\n    - \u2705 **Tests:** Complete test suite passed\n    - \u2705 **Lint:** Code quality checks passed\n\n    **Changes Summary:**\n    - **Upstream Commits:** $(git rev-list --count fork_integration..origin/fork_upstream)\n    - **Files Modified:** $(git diff --name-only origin/main..fork_integration | wc -l)\n    - **Integration Period:** $(calculate_integration_period)\n\n    **Review Checklist:**\n    - [ ] Review upstream changes for business impact\n    - [ ] Verify integration validation results\n    - [ ] Confirm deployment timing is appropriate\n    - [ ] Check for any additional testing requirements\n\n    **Deployment Notes:**\n    Changes have been thoroughly validated in integration branch and are ready for production deployment.\n\n  auto_merge_policy: |\n    # All production PRs require explicit human review\n    # No auto-merge enabled for production deployments\n    # Human approval required before merge to main branch\n</code></pre>"},{"location":"decisions/adr_009_review_strategy/#implementation-strategy","title":"Implementation Strategy","text":""},{"location":"decisions/adr_009_review_strategy/#material-timeline-check-validation-quality-gates","title":":material-timeline-check Validation Quality Gates","text":""},{"location":"decisions/adr_009_review_strategy/#integration-branch-validation","title":"Integration Branch Validation","text":"<pre><code># Comprehensive validation framework\nintegration_validation:\n  purpose: \"Ensure integration branch maintains high quality before production PR creation\"\n\n  validation_categories:\n    conflict_resolution:\n      description: \"Detect and handle merge conflicts\"\n      blocking: true\n      human_required: \"Always for conflict resolution\"\n\n    build_verification:\n      description: \"Ensure all build processes complete successfully\"\n      blocking: true\n      automated: true\n      logs_captured: true\n\n    test_execution:\n      description: \"Run complete test suite to verify functionality\"\n      blocking: true\n      automated: true\n      coverage_tracking: true\n\n    code_quality:\n      description: \"Lint and style checks for code quality\"\n      blocking: true\n      automated: true\n      standards_enforcement: true\n</code></pre>"},{"location":"decisions/adr_009_review_strategy/#production-review-framework","title":"Production Review Framework","text":"<pre><code># Human review requirements for production\nproduction_review:\n  purpose: \"Final human oversight before production deployment\"\n\n  review_requirements:\n    business_impact:\n      description: \"Assess business and operational impact of changes\"\n      reviewer: \"Team lead or designated reviewer\"\n\n    deployment_timing:\n      description: \"Confirm appropriate timing for production deployment\"\n      considerations: [\"Maintenance windows\", \"Business operations\", \"Team availability\"]\n\n    additional_testing:\n      description: \"Determine if additional testing required before deployment\"\n      scope: [\"Performance testing\", \"Security validation\", \"User acceptance\"]\n\n    rollback_planning:\n      description: \"Ensure rollback procedures are understood and available\"\n      documentation: \"Rollback steps documented and tested\"\n</code></pre>"},{"location":"decisions/adr_009_review_strategy/#benefits-and-rationale","title":"Benefits and Rationale","text":""},{"location":"decisions/adr_009_review_strategy/#material-trending-up-strategic-advantages","title":":material-trending-up Strategic Advantages","text":""},{"location":"decisions/adr_009_review_strategy/#safety-first-architecture","title":"Safety-First Architecture","text":"<ul> <li>External upstream changes receive appropriate human review at critical entry point</li> <li>Production branch protected by comprehensive validation and final human approval</li> <li>Clear quality gates prevent problematic changes from reaching production</li> <li>Risk mitigation through human oversight at both critical decision points</li> </ul>"},{"location":"decisions/adr_009_review_strategy/#quality-assurance-excellence","title":"Quality Assurance Excellence","text":"<ul> <li>Comprehensive validation (build, test, lint) on integration branch catches issues early</li> <li>Detailed failure tracking with logs and resolution steps enables efficient troubleshooting</li> <li>Integration branch serves its intended purpose as true validation gate</li> <li>Complete audit trail of human review history and validation logs for compliance</li> </ul>"},{"location":"decisions/adr_009_review_strategy/#efficient-workflow-management","title":"Efficient Workflow Management","text":"<ul> <li>Human-initiated cascade provides explicit control over integration timing</li> <li>Automated validation reduces manual review burden while maintaining safety</li> <li>Clear boundaries between integration testing and production deployment</li> <li>Issue tracking provides visibility into review status and progress</li> </ul>"},{"location":"decisions/adr_009_review_strategy/#material-cog-outline-operational-benefits","title":":material-cog-outline Operational Benefits","text":""},{"location":"decisions/adr_009_review_strategy/#early-issue-detection","title":"Early Issue Detection","text":"<ul> <li>Integration validation catches problems before production PR creation</li> <li>Comprehensive failure reporting with actionable resolution guidance</li> <li>Blocked cascades prevent invalid changes from reaching production review</li> <li>Clear escalation path for validation failures requiring human intervention</li> </ul>"},{"location":"decisions/adr_009_review_strategy/#production-deployment-confidence","title":"Production Deployment Confidence","text":"<ul> <li>All production changes validated and proven stable in integration branch</li> <li>Human review ensures appropriate business and operational considerations</li> <li>Clear deployment readiness indicators through validation results</li> <li>Systematic approach reduces deployment risk and improves reliability</li> </ul>"},{"location":"decisions/adr_009_review_strategy/#alternative-approaches-considered","title":"Alternative Approaches Considered","text":""},{"location":"decisions/adr_009_review_strategy/#fully-automated-cascade","title":"Fully Automated Cascade","text":"<p>Approach: Auto-merge at both cascade stages when validation passes</p> <ul> <li>Pros: Maximum automation efficiency, minimal manual intervention required</li> <li>Cons: Too risky for external changes reaching production without human oversight</li> <li>Decision: Rejected due to safety requirements for production deployment</li> </ul>"},{"location":"decisions/adr_009_review_strategy/#conditional-auto-merge-based-on-change-size","title":"Conditional Auto-Merge Based on Change Size","text":"<p>Approach: Auto-merge production stage based on change size or complexity</p> <ul> <li>Pros: Reduced manual overhead for routine updates</li> <li>Cons: Even clean changes benefit from human oversight before production</li> <li>Decision: Rejected - human review provides value beyond validation results</li> </ul>"},{"location":"decisions/adr_009_review_strategy/#reversed-asymmetry","title":"Reversed Asymmetry","text":"<p>Approach: Auto-merge integration stage, require manual review for production</p> <ul> <li>Pros: Focuses human attention on final production deployment decision</li> <li>Cons: Backwards from safety perspective - external changes need early review</li> <li>Decision: Rejected - safety requires human oversight at upstream integration point</li> </ul>"},{"location":"decisions/adr_009_review_strategy/#symmetric-manual-review","title":"Symmetric Manual Review","text":"<p>Approach: Require manual review and approval at both cascade stages</p> <ul> <li>Pros: Maximum human oversight and control over all changes</li> <li>Cons: Excessive manual overhead, slows routine updates unnecessarily</li> <li>Decision: Rejected - asymmetric approach balances safety with efficiency</li> </ul>"},{"location":"decisions/adr_009_review_strategy/#consequences-and-trade-offs","title":"Consequences and Trade-offs","text":""},{"location":"decisions/adr_009_review_strategy/#positive-outcomes","title":"Positive Outcomes","text":""},{"location":"decisions/adr_009_review_strategy/#enhanced-safety-and-reliability","title":"Enhanced Safety and Reliability","text":"<ul> <li>External changes receive human review at critical entry point</li> <li>Production deployments protected by comprehensive validation and final approval</li> <li>Clear quality gates prevent problematic changes from reaching production</li> <li>Risk mitigation through multiple validation checkpoints and human oversight</li> </ul>"},{"location":"decisions/adr_009_review_strategy/#quality-assurance-integration","title":"Quality Assurance Integration","text":"<ul> <li>Early detection of issues through integration branch validation</li> <li>Detailed failure tracking with actionable resolution guidance</li> <li>Complete audit trail for compliance and troubleshooting</li> <li>Systematic approach improves overall deployment reliability</li> </ul>"},{"location":"decisions/adr_009_review_strategy/#efficient-review-process","title":"Efficient Review Process","text":"<ul> <li>Human-initiated cascade provides explicit control over timing</li> <li>Automated validation reduces manual review burden while maintaining safety</li> <li>Clear role definition for integration testing vs production approval</li> <li>Issue tracking provides visibility and coordination for review activities</li> </ul>"},{"location":"decisions/adr_009_review_strategy/#trade-offs-and-limitations","title":"Trade-offs and Limitations","text":""},{"location":"decisions/adr_009_review_strategy/#manual-review-overhead","title":"Manual Review Overhead","text":"<ul> <li>All production PRs require human review and approval</li> <li>Manual review may slow deployment of routine updates</li> <li>Teams need to develop efficient review processes for common scenarios</li> <li>Review fatigue possible if update frequency is high</li> </ul>"},{"location":"decisions/adr_009_review_strategy/#process-coordination-requirements","title":"Process Coordination Requirements","text":"<ul> <li>Teams must understand asymmetric review responsibilities</li> <li>Monitoring required to track manual review timing and identify bottlenecks</li> <li>Emergency procedures needed for critical fixes requiring expedited review</li> <li>Training required for effective use of validation results in review decisions</li> </ul>"},{"location":"decisions/adr_009_review_strategy/#success-metrics","title":"Success Metrics","text":""},{"location":"decisions/adr_009_review_strategy/#quantitative-indicators","title":"Quantitative Indicators","text":"<ul> <li>Validation Success Rate: &gt;95% of integration validations pass before production PR creation</li> <li>Production Review Time: Average &lt;24 hours for production PR review and approval</li> <li>Issue Detection Rate: 90%+ of problems caught in integration validation before production</li> <li>Cascade Completion Rate: &gt;98% of initiated cascades successfully complete</li> </ul>"},{"location":"decisions/adr_009_review_strategy/#qualitative-indicators","title":"Qualitative Indicators","text":"<ul> <li>Teams report confidence in production deployment safety through validation</li> <li>Clear understanding of review responsibilities at each cascade stage</li> <li>Effective use of validation results to inform production review decisions</li> <li>Efficient coordination between integration validation and production approval</li> </ul>"},{"location":"decisions/adr_009_review_strategy/#integration-points","title":"Integration Points","text":""},{"location":"decisions/adr_009_review_strategy/#material-source-branch-cascade-workflow-integration","title":":material-source-branch Cascade Workflow Integration","text":""},{"location":"decisions/adr_009_review_strategy/#human-centric-cascade-pattern-per-adr-019","title":"Human-Centric Cascade Pattern (per ADR-019)","text":"<ul> <li>Asymmetric review strategy coordinates with manual cascade triggering</li> <li>Issue tracking integration provides visibility into review status and progress</li> <li>Human control points align with validation and approval requirements</li> </ul>"},{"location":"decisions/adr_009_review_strategy/#issue-lifecycle-tracking-per-adr-022","title":"Issue Lifecycle Tracking (per ADR-022)","text":"<ul> <li>Review strategy integrates with issue-based progress tracking</li> <li>Validation results and approval status reflected in issue updates</li> <li>Clear communication of review requirements and status to team</li> </ul>"},{"location":"decisions/adr_009_review_strategy/#material-shield-check-quality-and-safety-integration","title":":material-shield-check Quality and Safety Integration","text":""},{"location":"decisions/adr_009_review_strategy/#conflict-management-strategy-per-adr-005","title":"Conflict Management Strategy (per ADR-005)","text":"<ul> <li>Conflict detection integrated into validation framework</li> <li>Human resolution required for conflicts regardless of automation</li> <li>Clear escalation path from validation failure to conflict resolution</li> </ul>"},{"location":"decisions/adr_009_review_strategy/#related-decisions","title":"Related Decisions","text":"<ul> <li>ADR-001: Three-branch strategy defines cascade stages requiring review</li> <li>ADR-005: Conflict management integrates with validation framework</li> <li>ADR-019: Human-centric cascade triggering coordinates with review strategy</li> <li>ADR-022: Issue lifecycle tracking provides visibility into review progress</li> </ul> <p>This asymmetric cascade review strategy balances automation efficiency with safety requirements through differentiated approaches at each cascade stage, ensuring comprehensive validation while maintaining human oversight for critical decisions.</p>"},{"location":"decisions/adr_010_yaml_scripting/","title":"ADR-010: YAML-Safe Shell Scripting in GitHub Actions","text":"<p> Critical Decision |  2025-06-03 |  Accepted</p>"},{"location":"decisions/adr_010_yaml_scripting/#problem-statement","title":"Problem Statement","text":"<p>GitHub Actions workflows use YAML syntax to define shell scripts, creating potential conflicts when shell scripts contain YAML-meaningful characters. During initialization workflow development, YAML parsing errors were encountered that prevented workflow execution and blocked critical automation processes.</p>"},{"location":"decisions/adr_010_yaml_scripting/#context-and-requirements","title":"Context and Requirements","text":""},{"location":"decisions/adr_010_yaml_scripting/#yaml-shell-script-conflict-issues","title":"YAML-Shell Script Conflict Issues","text":"<p>Syntax Collision Problems: - Shell scripts containing YAML-meaningful characters (colons, quotes, backticks) break YAML parsing - Heredocs with complex content cause YAML parser confusion and failure - Multiline string assignments within YAML run blocks create parsing ambiguity - Special characters in shell variable assignments interfere with YAML structure</p> <p>Specific Failure Patterns Encountered: <pre><code># Problematic YAML-shell script interaction\nparsing_failures:\n  heredoc_conflicts: |\n    # \u274c This breaks YAML parsing\n    MANUAL_STEPS=\"## Manual Configuration Required\n\n    Since no GH_TOKEN was provided, please complete these steps:\n\n    ### 1. Branch Protection  \n    - Go to Settings \u2192 Branches\n    - For each branch (`main`, `fork_upstream`, `fork_integration`):\n      - Require pull request reviews before merging\"\n\n  yaml_parser_errors:\n    - \"line 351: could not find expected ':'\"\n    - \"line 353: mapping values are not allowed in this context\"\n    - \"invalid YAML: found unexpected character that cannot start any token\"\n</code></pre></p> <p>Development Impact: - Workflow failures during critical automation processes - Time-consuming debugging of complex YAML-shell script interactions - Inconsistent behavior across different YAML parsers and GitHub Actions contexts - Difficulty validating workflow syntax during development and testing</p>"},{"location":"decisions/adr_010_yaml_scripting/#safe-scripting-requirements","title":"Safe Scripting Requirements","text":"<p>Reliable Workflow Execution: Shell scripts must not interfere with YAML parsing or cause workflow failures.</p> <p>Maintainable Development Patterns: Clear, consistent patterns that team members can follow confidently.</p> <p>Validation and Testing: Easy validation of workflow syntax during development to prevent deployment issues.</p>"},{"location":"decisions/adr_010_yaml_scripting/#decision","title":"Decision","text":"<p>Establish YAML-Safe Shell Scripting Patterns for GitHub Actions workflows with comprehensive guidelines:</p> <pre><code>graph TD\n    A[Shell Script in YAML] --&gt; B{Contains Complex Content?}\n    B --&gt;|Yes| C[External File Approach]\n    B --&gt;|No| D[Simple String Pattern]\n\n    E[YAML Meaningful Chars?] --&gt; F{Special Characters?}\n    F --&gt;|Yes| G[Escape or Simplify]\n    F --&gt;|No| H[Direct Usage Safe]\n\n    I[Development Process] --&gt; J[Write Script]\n    J --&gt; K[YAML Validation]\n    K --&gt; L{Valid?}\n    L --&gt;|No| M[Fix Syntax Issues]\n    L --&gt;|Yes| N[Deploy Workflow]\n    M --&gt; K\n\n    style A fill:#e1f5fe,stroke:#01579b,stroke-width:2px\n    style C fill:#e8f5e9,stroke:#1b5e20,stroke-width:2px\n    style G fill:#fff3e0,stroke:#e65100,stroke-width:2px\n    style N fill:#fce4ec,stroke:#c2185b,stroke-width:2px</code></pre>"},{"location":"decisions/adr_010_yaml_scripting/#material-code-tags-core-safe-scripting-patterns","title":":material-code-tags Core Safe Scripting Patterns","text":""},{"location":"decisions/adr_010_yaml_scripting/#1-avoid-complex-heredocs-in-variable-assignments","title":"1. Avoid Complex Heredocs in Variable Assignments","text":"<pre><code># Pattern guidelines for heredoc usage\nheredoc_guidelines:\n  problematic_pattern: |\n    # \u274c Don't: Complex heredocs in YAML\n    VARIABLE=$(cat &lt;&lt; 'EOF'\n    Multi-line content with: colons\n    And other YAML-meaningful characters\n    EOF\n    )\n\n  safe_pattern: |\n    # \u2705 Do: Simple single-line assignments\n    VARIABLE=\"Simple single-line message without YAML conflicts\"\n\n    # \u2705 Alternative: Build content through concatenation\n    VARIABLE=\"Line 1. \"\n    VARIABLE+=\"Line 2. \"\n    VARIABLE+=\"Line 3.\"\n</code></pre>"},{"location":"decisions/adr_010_yaml_scripting/#2-external-files-for-complex-content","title":"2. External Files for Complex Content","text":"<pre><code># Content management strategies\nexternal_content_approach:\n  problematic: |\n    # \u274c Don't: Embed complex markdown in shell variables\n    run: |\n      COMPLEX_MESSAGE=\"## Complex Title\n      - Item 1: Details\n      - Item 2: More details\n      ### Section: Information\"\n\n  safe_approach: |\n    # \u2705 Do: Store complex content in separate files\n    run: |\n      # Reference external template files\n      TEMPLATE_FILE=\".github/templates/manual-steps.md\"\n      if [ -f \"$TEMPLATE_FILE\" ]; then\n        COMPLEX_MESSAGE=$(cat \"$TEMPLATE_FILE\")\n      else\n        COMPLEX_MESSAGE=\"Manual configuration required. See documentation.\"\n      fi\n</code></pre>"},{"location":"decisions/adr_010_yaml_scripting/#3-escape-yaml-meaningful-characters","title":"3. Escape YAML-Meaningful Characters","text":"<pre><code># Character escaping guidelines\ncharacter_handling:\n  problematic_chars:\n    - \"colons_in_content: 'Here's what was set up:'\"\n    - \"apostrophes: 'Here's the result'\"\n    - \"backticks: '`command` execution'\"\n    - \"quotes: 'Use \\\"double quotes\\\" properly'\"\n\n  safe_alternatives:\n    - \"colons_avoided: 'Here is what was set up'\"\n    - \"apostrophes_avoided: 'Here is the result'\"\n    - \"backticks_escaped: 'command execution'\"\n    - \"quotes_simplified: 'Use double quotes properly'\"\n</code></pre>"},{"location":"decisions/adr_010_yaml_scripting/#4-simple-string-concatenation-approach","title":"4. Simple String Concatenation Approach","text":"<pre><code># Safe string building patterns\nstring_building:\n  complex_approach: |\n    # \u274c Don't: Complex multiline assignments in YAML\n    MESSAGE=\"Line 1\n    Line 2: with colons\n    Line 3\"\n\n  safe_approach: |\n    # \u2705 Do: Build using simple concatenation\n    MESSAGE=\"Line 1. \"\n    MESSAGE+=\"Line 2 with details. \"\n    MESSAGE+=\"Line 3.\"\n\n  template_approach: |\n    # \u2705 Alternative: Use printf for formatted content\n    MESSAGE=$(printf \"Line 1\\nLine 2 with details\\nLine 3\")\n</code></pre>"},{"location":"decisions/adr_010_yaml_scripting/#material-check-circle-validation-and-testing-framework","title":":material-check-circle Validation and Testing Framework","text":""},{"location":"decisions/adr_010_yaml_scripting/#yaml-validation-command","title":"YAML Validation Command","text":"<pre><code># Required validation during development\nyaml_validation:\n  command: \"yq eval '.github/workflows/workflow-name.yml' &gt;/dev/null\"\n  success_message: \"\u2705 YAML is valid\"\n  failure_message: \"\u274c YAML has errors\"\n\n  validation_script: |\n    # Complete validation script for all workflows\n    for file in .github/workflows/*.yml; do\n      echo \"Validating $file...\"\n      if yq eval \"$file\" &gt;/dev/null 2&gt;&amp;1; then\n        echo \"\u2705 $file is valid\"\n      else\n        echo \"\u274c $file has errors\"\n        yq eval \"$file\" 2&gt;&amp;1 | head -5\n      fi\n    done\n</code></pre>"},{"location":"decisions/adr_010_yaml_scripting/#development-process-integration","title":"Development Process Integration","text":"<pre><code># Integrated development workflow\ndevelopment_process:\n  code_review_requirement: \"All workflow changes must pass YAML validation\"\n  pre_commit_validation: \"YAML checking integrated into development process\"\n  ci_validation: \"Automated YAML validation in pull request workflows\"\n\n  pre_commit_hook: |\n    # Pre-commit hook for YAML validation\n    #!/bin/bash\n    echo \"Validating GitHub Actions workflows...\"\n    for file in .github/workflows/*.yml; do\n      if ! yq eval \"$file\" &gt;/dev/null 2&gt;&amp;1; then\n        echo \"\u274c YAML validation failed for $file\"\n        exit 1\n      fi\n    done\n    echo \"\u2705 All workflow YAML files are valid\"\n</code></pre>"},{"location":"decisions/adr_010_yaml_scripting/#implementation-strategy","title":"Implementation Strategy","text":""},{"location":"decisions/adr_010_yaml_scripting/#material-wrench-cog-immediate-remediation-actions","title":":material-wrench-cog Immediate Remediation Actions","text":""},{"location":"decisions/adr_010_yaml_scripting/#fixed-initialization-workflow","title":"Fixed Initialization Workflow","text":"<pre><code># Corrected init-complete.yml patterns\ncorrected_patterns:\n  before: |\n    # \u274c Problematic heredoc causing YAML parsing errors\n    MANUAL_STEPS=\"## Manual Configuration Required\n\n    Since no GH_TOKEN was provided, please complete these steps:\n\n    ### 1. Branch Protection  \n    - Go to Settings \u2192 Branches\"\n\n  after: |\n    # \u2705 Simple, safe string assignment\n    MANUAL_STEPS=\"Manual configuration required. See repository settings for branch protection setup.\"\n\n    # \u2705 Alternative: Build comprehensive message safely\n    MANUAL_STEPS=\"Manual configuration required. \"\n    MANUAL_STEPS+=\"Go to Settings \u2192 Branches to configure protection rules. \"\n    MANUAL_STEPS+=\"Repeat for main, fork_upstream, and fork_integration branches.\"\n</code></pre>"},{"location":"decisions/adr_010_yaml_scripting/#template-updates-applied","title":"Template Updates Applied","text":"<pre><code># Systematic application of safe patterns\ntemplate_updates:\n  affected_workflows:\n    - \"init-complete.yml: Simplified manual steps messaging\"\n    - \"cascade.yml: Removed complex heredoc assignments\"\n    - \"sync.yml: Updated notification content patterns\"\n\n  validation_integration:\n    - \"Added YAML validation to development process\"\n    - \"Created pre-commit hooks for syntax checking\"\n    - \"Updated documentation with safe patterns\"\n</code></pre>"},{"location":"decisions/adr_010_yaml_scripting/#material-school-outline-team-adoption-framework","title":":material-school-outline Team Adoption Framework","text":""},{"location":"decisions/adr_010_yaml_scripting/#pattern-documentation-and-training","title":"Pattern Documentation and Training","text":"<pre><code># Comprehensive team guidance\nteam_adoption:\n  documentation:\n    - \"This ADR serves as reference for safe scripting patterns\"\n    - \"Examples provided for common scenarios and use cases\"\n    - \"Troubleshooting guide for YAML-shell script conflicts\"\n\n  training_materials:\n    - \"Workshop on YAML-safe shell scripting in GitHub Actions\"\n    - \"Code review checklist including YAML validation requirements\"\n    - \"Common pitfalls and resolution strategies documentation\"\n</code></pre>"},{"location":"decisions/adr_010_yaml_scripting/#benefits-and-rationale","title":"Benefits and Rationale","text":""},{"location":"decisions/adr_010_yaml_scripting/#material-trending-up-strategic-advantages","title":":material-trending-up Strategic Advantages","text":""},{"location":"decisions/adr_010_yaml_scripting/#workflow-reliability-enhancement","title":"Workflow Reliability Enhancement","text":"<ul> <li>Eliminates YAML parsing errors that block critical automation processes</li> <li>Consistent behavior across different YAML parsers and GitHub Actions environments</li> <li>Predictable workflow execution without syntax-related failures</li> <li>Reduced debugging time for workflow syntax issues</li> </ul>"},{"location":"decisions/adr_010_yaml_scripting/#development-productivity-improvement","title":"Development Productivity Improvement","text":"<ul> <li>Clear patterns reduce time spent on complex YAML-shell script interactions</li> <li>Faster development cycles through early validation and error prevention</li> <li>Team productivity gains through standardized, reliable scripting approaches</li> <li>Simplified maintenance and modification of existing workflows</li> </ul>"},{"location":"decisions/adr_010_yaml_scripting/#quality-assurance-integration","title":"Quality Assurance Integration","text":"<ul> <li>YAML validation integrated into development process prevents deployment issues</li> <li>Code review requirements ensure consistent application of safe patterns</li> <li>Pre-commit hooks catch syntax issues before they reach shared repositories</li> <li>Systematic testing of workflow syntax during development</li> </ul>"},{"location":"decisions/adr_010_yaml_scripting/#material-cog-outline-technical-architecture-benefits","title":":material-cog-outline Technical Architecture Benefits","text":""},{"location":"decisions/adr_010_yaml_scripting/#maintainable-workflow-design","title":"Maintainable Workflow Design","text":"<ul> <li>Simpler patterns easier to debug, modify, and extend</li> <li>Clear separation between complex content and workflow logic</li> <li>External file approach enables sophisticated content without YAML conflicts</li> <li>Standardized approaches reduce cognitive load for workflow development</li> </ul>"},{"location":"decisions/adr_010_yaml_scripting/#robust-error-prevention","title":"Robust Error Prevention","text":"<ul> <li>Proactive pattern adoption prevents entire class of syntax errors</li> <li>Validation framework catches issues early in development cycle</li> <li>Clear guidelines enable confident workflow modification</li> <li>Reduced risk of production workflow failures due to syntax issues</li> </ul>"},{"location":"decisions/adr_010_yaml_scripting/#alternative-approaches-considered","title":"Alternative Approaches Considered","text":""},{"location":"decisions/adr_010_yaml_scripting/#external-template-files-only","title":"External Template Files Only","text":"<p>Approach: Store all complex content in separate template files</p> <ul> <li>Pros: Complete separation of complex content from YAML, maximum flexibility</li> <li>Cons: Additional file management overhead, less self-contained workflows</li> <li>Decision: Rejected as primary approach - hybrid approach balances simplicity with flexibility</li> </ul>"},{"location":"decisions/adr_010_yaml_scripting/#json-encoded-strings","title":"JSON-Encoded Strings","text":"<p>Approach: Encode complex content as JSON strings within YAML</p> <ul> <li>Pros: Guaranteed YAML compatibility through proper escaping</li> <li>Cons: Significantly reduced readability, complex escaping requirements</li> <li>Decision: Rejected due to poor developer experience and maintenance complexity</li> </ul>"},{"location":"decisions/adr_010_yaml_scripting/#github-actions-expressions-only","title":"GitHub Actions Expressions Only","text":"<p>Approach: Use native GitHub Actions expressions for all dynamic content</p> <ul> <li>Pros: Native GitHub syntax, platform-specific optimization</li> <li>Cons: Limited formatting capabilities, expression complexity for advanced scenarios</li> <li>Decision: Rejected as insufficient for complex workflow content requirements</li> </ul>"},{"location":"decisions/adr_010_yaml_scripting/#yaml-block-scalar-styles","title":"YAML Block Scalar Styles","text":"<p>Approach: Use different YAML block scalar styles (| and &gt;) for content</p> <ul> <li>Pros: Native YAML features for multiline content</li> <li>Cons: Still vulnerable to content containing YAML-meaningful characters</li> <li>Decision: Rejected as incomplete solution to character conflict issues</li> </ul>"},{"location":"decisions/adr_010_yaml_scripting/#consequences-and-trade-offs","title":"Consequences and Trade-offs","text":""},{"location":"decisions/adr_010_yaml_scripting/#positive-outcomes","title":"Positive Outcomes","text":""},{"location":"decisions/adr_010_yaml_scripting/#enhanced-workflow-reliability","title":"Enhanced Workflow Reliability","text":"<ul> <li>Elimination of YAML parsing errors that block critical automation</li> <li>Consistent, predictable workflow execution across all environments</li> <li>Reduced debugging time for syntax-related workflow failures</li> <li>Improved confidence in workflow deployment and maintenance</li> </ul>"},{"location":"decisions/adr_010_yaml_scripting/#development-experience-improvement","title":"Development Experience Improvement","text":"<ul> <li>Clear patterns reduce learning curve for workflow development</li> <li>Faster development cycles through early error prevention</li> <li>Standardized approaches enable efficient code review processes</li> <li>Comprehensive validation framework catches issues before deployment</li> </ul>"},{"location":"decisions/adr_010_yaml_scripting/#team-productivity-enhancement","title":"Team Productivity Enhancement","text":"<ul> <li>Reduced time spent debugging complex YAML-shell script interactions</li> <li>Clear guidelines enable confident workflow modification and extension</li> <li>Systematic testing prevents workflow failures in critical automation</li> <li>Knowledge sharing through documented patterns and best practices</li> </ul>"},{"location":"decisions/adr_010_yaml_scripting/#material-minus-trade-offs-and-limitations","title":":material-minus Trade-offs and Limitations","text":""},{"location":"decisions/adr_010_yaml_scripting/#content-complexity-constraints","title":"Content Complexity Constraints","text":"<ul> <li>Complex formatted messages require external files or simplified approaches</li> <li>Some advanced shell scripting patterns may need modification for YAML safety</li> <li>Limitation on inline documentation and extensive help text within workflows</li> </ul>"},{"location":"decisions/adr_010_yaml_scripting/#development-process-changes","title":"Development Process Changes","text":"<ul> <li>Team needs to adopt new development patterns and validation requirements</li> <li>Additional validation steps in development process add minor overhead</li> <li>Learning curve for understanding YAML-shell script interaction patterns</li> </ul>"},{"location":"decisions/adr_010_yaml_scripting/#success-metrics","title":"Success Metrics","text":""},{"location":"decisions/adr_010_yaml_scripting/#quantitative-indicators","title":"Quantitative Indicators","text":"<ul> <li>Workflow Failure Reduction: 100% elimination of YAML parsing errors in workflows</li> <li>Development Speed: Reduced debugging time for workflow syntax issues</li> <li>Validation Coverage: 100% of workflows pass YAML validation before deployment</li> <li>Team Adoption: All team members follow safe scripting patterns consistently</li> </ul>"},{"location":"decisions/adr_010_yaml_scripting/#qualitative-indicators","title":"Qualitative Indicators","text":"<ul> <li>Teams report improved confidence in workflow development and modification</li> <li>Clear understanding of safe patterns and validation requirements</li> <li>Effective integration of YAML validation into development workflow</li> <li>Reduced support requests related to workflow syntax issues</li> </ul>"},{"location":"decisions/adr_010_yaml_scripting/#integration-points","title":"Integration Points","text":""},{"location":"decisions/adr_010_yaml_scripting/#material-source-branch-workflow-development-integration","title":":material-source-branch Workflow Development Integration","text":""},{"location":"decisions/adr_010_yaml_scripting/#two-workflow-initialization-pattern-per-adr-006","title":"Two-Workflow Initialization Pattern (per ADR-006)","text":"<ul> <li>Safe scripting patterns applied to initialization workflow complexity</li> <li>YAML validation ensures reliable initialization process execution</li> <li>Simplified content patterns maintain workflow clarity and reliability</li> </ul>"},{"location":"decisions/adr_010_yaml_scripting/#template-repository-pattern-per-adr-003","title":"Template Repository Pattern (per ADR-003)","text":"<ul> <li>Safe scripting patterns propagated through template updates</li> <li>Validation requirements ensure template workflows remain reliable</li> <li>Pattern documentation becomes part of template guidance</li> </ul>"},{"location":"decisions/adr_010_yaml_scripting/#material-quality-assurance-quality-assurance-integration","title":":material-quality-assurance Quality Assurance Integration","text":""},{"location":"decisions/adr_010_yaml_scripting/#development-process-enhancement","title":"Development Process Enhancement","text":"<ul> <li>YAML validation integrated into code review requirements</li> <li>Pre-commit hooks prevent syntax issues from reaching shared repositories</li> <li>Continuous integration validates workflow syntax automatically</li> </ul>"},{"location":"decisions/adr_010_yaml_scripting/#related-decisions","title":"Related Decisions","text":"<ul> <li>ADR-006: Two-workflow initialization pattern benefits from safe scripting</li> <li>ADR-003: Template repository pattern propagates safe scripting practices</li> <li>ADR-002: GitHub Actions automation enhanced by reliable scripting patterns</li> </ul> <p>This YAML-safe shell scripting standard ensures reliable GitHub Actions workflow execution by establishing clear patterns that prevent YAML parsing conflicts while maintaining development productivity and workflow maintainability.</p>"},{"location":"decisions/adr_011_template_sync/","title":"ADR-011: Configuration-Driven Template Synchronization","text":"<p> Critical Decision |  2025-06-04 |  Accepted</p>"},{"location":"decisions/adr_011_template_sync/#problem-statement","title":"Problem Statement","text":"<p>The original template repository pattern created a critical bootstrap problem: once repositories were created from the template, there was no systematic way to propagate template improvements, security patches, or new features to existing forked repositories. This led to significant template drift and inconsistent infrastructure across deployments.</p>"},{"location":"decisions/adr_011_template_sync/#context-and-requirements","title":"Context and Requirements","text":""},{"location":"decisions/adr_011_template_sync/#static-template-limitations","title":"Static Template Limitations","text":"<p>Template Drift Challenges: - Forked repositories became outdated as the template evolved with improvements - No automated mechanism to propagate workflow updates to existing deployments - Inconsistent infrastructure as repositories diverged from template standards - Security improvements in template didn't reach existing fork repositories</p> <p>Manual Update Burden: - Teams required manual tracking and application of template changes - Error-prone process copying changes between template and fork repositories - No visibility into which template version each fork was synchronized to - Coordination overhead for applying updates across multiple repository instances</p> <p>Maintenance and Consistency Issues: - Difficulty distinguishing between template infrastructure and project-specific content - No systematic cleanup of template development artifacts during initialization - Unclear boundaries between template-management files and project-essential files - Risk of accidentally over-syncing or under-syncing critical infrastructure</p>"},{"location":"decisions/adr_011_template_sync/#synchronization-requirements","title":"Synchronization Requirements","text":"<p>Systematic Sync Management: Clear definition of which files should be synchronized between template and forks with explicit categorization.</p> <p>Selective Update Mechanism: Automated propagation of essential infrastructure while preserving project-specific customizations.</p> <p>Clean Repository State: Systematic cleanup of template-specific content during initialization with documented rationale.</p>"},{"location":"decisions/adr_011_template_sync/#decision","title":"Decision","text":"<p>Implement a Configuration-Driven Template Synchronization System using structured configuration to manage selective file synchronization:</p> <pre><code>graph TD\n    A[Template Repository] --&gt; B[sync-config.json]\n    B --&gt; C{File Category}\n    C --&gt;|Essential| D[Copy to Fork]\n    C --&gt;|Template-Only| E[Keep in Template]\n    C --&gt;|Cleanup| F[Remove During Init]\n\n    G[Fork Repository] --&gt; H[template-sync.yml]\n    H --&gt; I[Check Template Updates]\n    I --&gt; J[Apply Config Rules]\n    J --&gt; K[Update Essential Files]\n    K --&gt; L[Track Sync Version]\n\n    M[Initialization] --&gt; N[init-complete.yml]\n    N --&gt; O[Apply Cleanup Rules]\n    O --&gt; P[Clean Fork State]\n\n    style A fill:#e1f5fe,stroke:#01579b,stroke-width:2px\n    style B fill:#e8f5e9,stroke:#1b5e20,stroke-width:2px\n    style D fill:#fff3e0,stroke:#e65100,stroke-width:2px\n    style F fill:#fce4ec,stroke:#c2185b,stroke-width:2px</code></pre>"},{"location":"decisions/adr_011_template_sync/#material-file-document-outline-configuration-architecture","title":":material-file-document-outline Configuration Architecture","text":""},{"location":"decisions/adr_011_template_sync/#comprehensive-sync-configuration-githubsync-configjson","title":"Comprehensive Sync Configuration (.github/sync-config.json)","text":"<pre><code>{\n  \"sync_rules\": {\n    \"directories\": [\n      {\n        \"path\": \".github/ISSUE_TEMPLATE\",\n        \"reason\": \"Standard issue templates for consistent project management\"\n      },\n      {\n        \"path\": \".github/PULL_REQUEST_TEMPLATE\", \n        \"reason\": \"PR templates ensuring proper review processes\"\n      }\n    ],\n    \"files\": [\n      {\n        \"path\": \".github/dependabot.yml\",\n        \"reason\": \"Automated dependency management configuration\"\n      },\n      {\n        \"path\": \".github/labels.json\",\n        \"reason\": \"Centralized label definitions for workflow automation\"\n      }\n    ],\n    \"workflows\": {\n      \"essential\": [\n        \".github/workflows/sync.yml\",\n        \".github/workflows/validate.yml\",\n        \".github/workflows/build.yml\",\n        \".github/workflows/release.yml\",\n        \".github/workflows/template-sync.yml\"\n      ],\n      \"template_only\": [\n        \".github/workflows/init.yml\",\n        \".github/workflows/init-complete.yml\",\n        \".github/workflows/cascade.yml\",\n        \".github/workflows/cascade-monitor.yml\"\n      ]\n    },\n    \"tracking_files\": [\n      \".github/.template-sync-commit\"\n    ]\n  },\n  \"cleanup_rules\": {\n    \"directories\": [\n      {\n        \"path\": \"doc/\",\n        \"reason\": \"Template documentation replaced by upstream project docs\"\n      },\n      {\n        \"path\": \".claude/\",\n        \"reason\": \"Claude configuration specific to template development\"\n      }\n    ],\n    \"files\": [\n      {\n        \"path\": \"CLAUDE.md\",\n        \"reason\": \"Template-specific Claude instructions\"\n      },\n      {\n        \"path\": \".github/copilot-instructions.md\",\n        \"reason\": \"Template-specific AI instructions\"\n      }\n    ],\n    \"workflows\": [\n      {\n        \"path\": \".github/workflows/init.yml\",\n        \"reason\": \"One-time initialization workflow\"\n      },\n      {\n        \"path\": \".github/workflows/init-complete.yml\",\n        \"reason\": \"One-time setup workflow\"\n      }\n    ]\n  },\n  \"exclusions\": [\n    \"project-specific-config.yml\",\n    \"custom-workflows/\",\n    \".env.local\"\n  ]\n}\n</code></pre>"},{"location":"decisions/adr_011_template_sync/#material-cog-sync-configuration-aware-workflow-integration","title":":material-cog-sync Configuration-Aware Workflow Integration","text":""},{"location":"decisions/adr_011_template_sync/#initialization-cleanup-process","title":"Initialization Cleanup Process","text":"<pre><code># Enhanced init-complete.yml with configuration-driven cleanup\ninitialization_cleanup:\n  sync_configuration: \"Read .github/sync-config.json for cleanup rules\"\n\n  directory_cleanup: |\n    # Remove template-specific directories with documented reasons\n    CLEANUP_DIRS=$(jq -r '.cleanup_rules.directories[]? | .path' .github/sync-config.json)\n    for dir in $CLEANUP_DIRS; do\n      if [ -d \"$dir\" ]; then\n        echo \"Removing template directory: $dir\"\n        rm -rf \"$dir\"\n      fi\n    done\n\n  file_cleanup: |\n    # Remove template-specific files with clear rationale\n    CLEANUP_FILES=$(jq -r '.cleanup_rules.files[]? | .path' .github/sync-config.json)\n    for file in $CLEANUP_FILES; do\n      if [ -f \"$file\" ]; then\n        echo \"Removing template file: $file\"\n        rm -f \"$file\"\n      fi\n    done\n\n  workflow_cleanup: |\n    # Remove initialization workflows after completion\n    CLEANUP_WORKFLOWS=$(jq -r '.cleanup_rules.workflows[]? | .path' .github/sync-config.json)\n    for workflow in $CLEANUP_WORKFLOWS; do\n      if [ -f \"$workflow\" ]; then\n        echo \"Removing initialization workflow: $workflow\"\n        rm -f \"$workflow\"\n      fi\n    done\n</code></pre>"},{"location":"decisions/adr_011_template_sync/#template-synchronization-process","title":"Template Synchronization Process","text":"<pre><code># Configuration-driven template-sync.yml implementation\ntemplate_synchronization:\n  change_detection: \"Check only configured sync paths for template updates\"\n\n  sync_path_collection: |\n    # Build sync path list from configuration\n    SYNC_PATHS=\"\"\n\n    # Add configured directories\n    DIRECTORIES=$(jq -r '.sync_rules.directories[]? | .path' temp-sync-config.json)\n    for dir in $DIRECTORIES; do\n      SYNC_PATHS=\"$SYNC_PATHS $dir\"\n    done\n\n    # Add configured files\n    FILES=$(jq -r '.sync_rules.files[]? | .path' temp-sync-config.json)\n    for file in $FILES; do\n      SYNC_PATHS=\"$SYNC_PATHS $file\"\n    done\n\n    # Add essential workflows\n    ESSENTIAL_WORKFLOWS=$(jq -r '.sync_rules.workflows.essential[]?' temp-sync-config.json)\n    for workflow in $ESSENTIAL_WORKFLOWS; do\n      SYNC_PATHS=\"$SYNC_PATHS $workflow\"\n    done\n\n  change_analysis: |\n    # Check for changes only in configured paths\n    for path in $SYNC_PATHS; do\n      CHANGES=$(git diff --name-only $LAST_SYNC_COMMIT..$TEMPLATE_COMMIT template/main -- \"$path\")\n      if [ -n \"$CHANGES\" ]; then\n        echo \"Changes detected in $path\"\n        # Process updates for this path\n      fi\n    done\n</code></pre>"},{"location":"decisions/adr_011_template_sync/#implementation-strategy","title":"Implementation Strategy","text":""},{"location":"decisions/adr_011_template_sync/#material-folder-sync-selective-file-categorization","title":":material-folder-sync Selective File Categorization","text":""},{"location":"decisions/adr_011_template_sync/#essential-infrastructure-files","title":"Essential Infrastructure Files","text":"<pre><code># Files that must stay synchronized across all forks\nessential_infrastructure:\n  templates:\n    - .github/ISSUE_TEMPLATE/: \"Standardized issue reporting\"\n    - .github/PULL_REQUEST_TEMPLATE/: \"Consistent PR review process\"\n\n  configuration:\n    - .github/dependabot.yml: \"Automated dependency management\"\n    - .github/labels.json: \"Centralized label definitions\"\n    - .github/branch-protection.json: \"Repository security settings\"\n\n  actions:\n    - .github/actions/: \"Reusable workflow components\"\n\n  security:\n    - .github/security-on.json: \"Security scanning configuration\"\n    - .github/security-patterns.txt: \"Security pattern definitions\"\n</code></pre>"},{"location":"decisions/adr_011_template_sync/#essential-vs-template-only-workflows","title":"Essential vs Template-Only Workflows","text":"<pre><code># Clear separation of workflow purposes\nworkflow_categorization:\n  essential_workflows:\n    purpose: \"Core fork management functionality required in all deployments\"\n    workflows:\n      - sync.yml: \"Upstream synchronization automation\"\n      - validate.yml: \"PR validation and quality gates\"\n      - build.yml: \"Project build and test automation\"\n      - release.yml: \"Automated semantic versioning and releases\"\n      - template-sync.yml: \"Template update propagation\"\n      - dependabot-validation.yml: \"Dependency update validation\"\n\n  template_only_workflows:\n    purpose: \"Template development and initialization, not needed in forks\"\n    workflows:\n      - init.yml: \"One-time repository initialization\"\n      - init-complete.yml: \"Repository setup completion\"\n      - cascade.yml: \"Fork-specific cascade integration\"\n      - cascade-monitor.yml: \"Cascade monitoring and recovery\"\n</code></pre>"},{"location":"decisions/adr_011_template_sync/#material-track-changes-version-tracking-and-history","title":":material-track-changes Version Tracking and History","text":""},{"location":"decisions/adr_011_template_sync/#synchronization-state-management","title":"Synchronization State Management","text":"<pre><code># Comprehensive tracking of template synchronization state\nsync_tracking:\n  commit_tracking: \".github/.template-sync-commit stores last synced template version\"\n\n  sync_history: |\n    # Track synchronization events with metadata\n    echo \"Last synced: $(date -u +%Y-%m-%dT%H:%M:%SZ)\" &gt;&gt; .github/.template-sync-history\n    echo \"Template commit: $TEMPLATE_COMMIT\" &gt;&gt; .github/.template-sync-history\n    echo \"Files updated: $UPDATED_FILES\" &gt;&gt; .github/.template-sync-history\n\n  version_correlation: |\n    # Maintain relationship between fork and template versions\n    gh issue create \\\n      --title \"\ud83d\udce6 Template Sync $(date +%Y-%m-%d)\" \\\n      --body \"Template updated to $TEMPLATE_COMMIT. Files synchronized: $SYNC_SUMMARY\" \\\n      --label \"template-sync,automated\"\n</code></pre>"},{"location":"decisions/adr_011_template_sync/#benefits-and-rationale","title":"Benefits and Rationale","text":""},{"location":"decisions/adr_011_template_sync/#material-trending-up-strategic-advantages","title":":material-trending-up Strategic Advantages","text":""},{"location":"decisions/adr_011_template_sync/#template-drift-elimination","title":"Template Drift Elimination","text":"<ul> <li>Automated propagation ensures forked repositories stay current with template improvements</li> <li>Selective synchronization prevents overwriting project-specific customizations</li> <li>Version tracking provides clear visibility into template synchronization state</li> <li>Consistent infrastructure maintenance across all repository deployments</li> </ul>"},{"location":"decisions/adr_011_template_sync/#maintainable-synchronization-architecture","title":"Maintainable Synchronization Architecture","text":"<ul> <li>Single configuration file controls all sync behavior with clear documentation</li> <li>Explicit categorization eliminates ambiguity about file synchronization requirements</li> <li>JSON-based configuration enables programmatic processing and validation</li> <li>Git-tracked configuration changes provide complete audit trail</li> </ul>"},{"location":"decisions/adr_011_template_sync/#clean-repository-state-management","title":"Clean Repository State Management","text":"<ul> <li>Systematic cleanup removes template development artifacts during initialization</li> <li>Documented cleanup rationale provides clear understanding of removal decisions</li> <li>Consistent clean starting state across all forked repository deployments</li> <li>Future-proof cleanup behavior through configurable rules</li> </ul>"},{"location":"decisions/adr_011_template_sync/#material-cog-outline-operational-benefits","title":":material-cog-outline Operational Benefits","text":""},{"location":"decisions/adr_011_template_sync/#conflict-prevention-and-boundary-management","title":"Conflict Prevention and Boundary Management","text":"<ul> <li>Clear separation between template infrastructure and project-specific content</li> <li>Explicit exclusion rules prevent accidental synchronization of custom files</li> <li>Selective update mechanism preserves project customizations while updating infrastructure</li> <li>Documented boundaries enable confident customization without sync conflicts</li> </ul>"},{"location":"decisions/adr_011_template_sync/#development-and-maintenance-efficiency","title":"Development and Maintenance Efficiency","text":"<ul> <li>Easy addition of new files to synchronization process through configuration updates</li> <li>Transparent sync process with clear documentation of what gets synchronized</li> <li>Reduced manual coordination overhead for template improvements</li> <li>Self-documenting configuration with rationale for each synchronization decision</li> </ul>"},{"location":"decisions/adr_011_template_sync/#alternative-approaches-considered","title":"Alternative Approaches Considered","text":""},{"location":"decisions/adr_011_template_sync/#manual-synchronization-documentation","title":"Manual Synchronization Documentation","text":"<p>Approach: Comprehensive documentation with step-by-step synchronization instructions</p> <ul> <li>Pros: Simple approach with no automation complexity</li> <li>Cons: Error-prone manual process, poor adoption rates, inconsistent application</li> <li>Decision: Rejected due to fundamental reliability and consistency issues</li> </ul>"},{"location":"decisions/adr_011_template_sync/#git-subtreesubmodule-integration","title":"Git Subtree/Submodule Integration","text":"<p>Approach: Native Git functionality for template integration</p> <ul> <li>Pros: Leverages standard Git features, well-understood by developers</li> <li>Cons: Complex user experience, doesn't handle selective file synchronization</li> <li>Decision: Rejected due to user experience complexity and selective sync limitations</li> </ul>"},{"location":"decisions/adr_011_template_sync/#hardcoded-synchronization-lists","title":"Hardcoded Synchronization Lists","text":"<p>Approach: Direct file lists embedded in workflow code</p> <ul> <li>Pros: Direct implementation, no additional configuration complexity</li> <li>Cons: Difficult to maintain, poor documentation of synchronization decisions</li> <li>Decision: Rejected due to maintainability concerns and lack of transparency</li> </ul>"},{"location":"decisions/adr_011_template_sync/#external-synchronization-service","title":"External Synchronization Service","text":"<p>Approach: Dedicated service for sophisticated synchronization management</p> <ul> <li>Pros: Powerful capabilities, could handle complex synchronization scenarios</li> <li>Cons: External dependency, additional infrastructure requirements, complexity overhead</li> <li>Decision: Rejected due to template self-containment requirements</li> </ul>"},{"location":"decisions/adr_011_template_sync/#consequences-and-trade-offs","title":"Consequences and Trade-offs","text":""},{"location":"decisions/adr_011_template_sync/#positive-outcomes","title":"Positive Outcomes","text":""},{"location":"decisions/adr_011_template_sync/#infrastructure-consistency-excellence","title":"Infrastructure Consistency Excellence","text":"<ul> <li>Template improvements automatically reach all forked repositories</li> <li>Selective synchronization preserves project customizations while updating infrastructure</li> <li>Clean repository state eliminates template development artifacts</li> <li>Consistent behavior across unlimited repository deployments</li> </ul>"},{"location":"decisions/adr_011_template_sync/#maintainability-and-transparency","title":"Maintainability and Transparency","text":"<ul> <li>Single configuration file controls all synchronization behavior</li> <li>Clear documentation of what gets synchronized and rationale for decisions</li> <li>Easy addition of new files to synchronization process</li> <li>Git-tracked configuration provides complete audit trail</li> </ul>"},{"location":"decisions/adr_011_template_sync/#conflict-prevention-and-reliability","title":"Conflict Prevention and Reliability","text":"<ul> <li>Explicit boundaries between template and project content</li> <li>Automated cleanup prevents template artifact accumulation</li> <li>Version tracking enables troubleshooting and rollback capabilities</li> <li>Self-updating configuration ensures consistency across deployments</li> </ul>"},{"location":"decisions/adr_011_template_sync/#trade-offs-and-limitations","title":"Trade-offs and Limitations","text":""},{"location":"decisions/adr_011_template_sync/#configuration-management-complexity","title":"Configuration Management Complexity","text":"<ul> <li>Additional JSON configuration file requires maintenance and understanding</li> <li>Bootstrap dependency: sync configuration must exist before synchronization works</li> <li>JSON syntax knowledge required for configuration modifications</li> <li>Learning curve for understanding configuration structure and options</li> </ul>"},{"location":"decisions/adr_011_template_sync/#implementation-dependencies","title":"Implementation Dependencies","text":"<ul> <li>Synchronization workflows depend on configuration file accuracy</li> <li>Changes to sync behavior require configuration file updates</li> <li>Need for configuration validation to prevent sync failures</li> <li>Coordination required when multiple developers modify configuration</li> </ul>"},{"location":"decisions/adr_011_template_sync/#success-metrics","title":"Success Metrics","text":""},{"location":"decisions/adr_011_template_sync/#quantitative-indicators","title":"Quantitative Indicators","text":"<ul> <li>Template Drift Elimination: 100% of essential files synchronized across deployments</li> <li>Synchronization Success Rate: &gt;99% successful template synchronization operations</li> <li>Clean State Achievement: Zero template artifacts remaining after initialization</li> <li>Configuration Accuracy: All synchronization rules properly documented and categorized</li> </ul>"},{"location":"decisions/adr_011_template_sync/#qualitative-indicators","title":"Qualitative Indicators","text":"<ul> <li>Teams report confidence in template update propagation</li> <li>Clear understanding of file synchronization categories and rationale</li> <li>Effective separation between template infrastructure and project content</li> <li>Reduced manual coordination overhead for template improvements</li> </ul>"},{"location":"decisions/adr_011_template_sync/#integration-points","title":"Integration Points","text":""},{"location":"decisions/adr_011_template_sync/#material-source-branch-template-and-initialization-integration","title":":material-source-branch Template and Initialization Integration","text":""},{"location":"decisions/adr_011_template_sync/#template-repository-pattern-per-adr-003","title":"Template Repository Pattern (per ADR-003)","text":"<ul> <li>Configuration-driven approach enhances template repository with systematic update mechanism</li> <li>Selective synchronization preserves template self-configuration benefits</li> <li>Clean initialization process improved through documented cleanup rules</li> </ul>"},{"location":"decisions/adr_011_template_sync/#two-workflow-initialization-per-adr-006","title":"Two-Workflow Initialization (per ADR-006)","text":"<ul> <li>Initialization workflows enhanced with configuration-driven cleanup</li> <li>Systematic removal of template artifacts during repository setup</li> <li>Clear documentation of cleanup rationale for maintenance</li> </ul>"},{"location":"decisions/adr_011_template_sync/#material-update-template-update-propagation","title":":material-update Template Update Propagation","text":""},{"location":"decisions/adr_011_template_sync/#template-update-strategy-per-adr-012","title":"Template Update Strategy (per ADR-012)","text":"<ul> <li>Configuration provides foundation for systematic update propagation</li> <li>Version tracking enables sophisticated update management</li> <li>Selective synchronization rules prevent project customization conflicts</li> </ul>"},{"location":"decisions/adr_011_template_sync/#related-decisions","title":"Related Decisions","text":"<ul> <li>ADR-003: Template repository pattern enhanced by this synchronization system</li> <li>ADR-006: Two-workflow initialization enhanced by sync configuration</li> <li>ADR-012: Template update propagation depends on this configuration system</li> <li>Template Sync Workflow Implementation: Leverages configuration for selective file synchronization</li> </ul> <p>This configuration-driven template synchronization system provides systematic, maintainable propagation of template improvements while preserving project customizations, ensuring consistent infrastructure across all repository deployments through selective file synchronization and documented cleanup processes.</p>"},{"location":"decisions/adr_012_template_updates/","title":"ADR-012: Template Update Propagation Strategy","text":"<p> Critical Decision |  2025-06-04 |  Accepted |  Revised 2025-06-29</p>"},{"location":"decisions/adr_012_template_updates/#problem-statement","title":"Problem Statement","text":"<p>Following the implementation of configuration-driven template synchronization, a critical gap remained: while sync configuration defined what should be synchronized, there was no systematic strategy for how and when template updates actually reach existing forked repositories. This created a template update propagation problem that limited the value of template improvements.</p>"},{"location":"decisions/adr_012_template_updates/#context-and-requirements","title":"Context and Requirements","text":""},{"location":"decisions/adr_012_template_updates/#template-update-propagation-challenges","title":"Template Update Propagation Challenges","text":"<p>Automatic Update Requirements: - Template improvements should reach forks without manual intervention from teams - Only template infrastructure should be updated, preserving project-specific content - Change visibility must provide clear understanding of what updates are being applied - Review process required to validate updates before integration into fork repositories</p> <p>Change Management Complexity: - Bootstrap problem: how do forked repositories initially gain template sync capability - Change detection: identifying which template changes are relevant to each fork - Update scheduling: determining optimal timing for template update checks and application - Conflict resolution: handling cases where template changes conflict with local modifications</p> <p>Integration and Coordination: - Version tracking: maintaining visibility into which template version each fork uses - Human-centric flow: providing clear guidance when template changes require manual actions - Cascade integration: coordinating template updates with upstream synchronization workflows - Manual override capability: enabling immediate updates for critical security fixes</p>"},{"location":"decisions/adr_012_template_updates/#material-target-update-propagation-requirements","title":":material-target Update Propagation Requirements","text":"<p>Automated Template Benefits: Template improvements reach forks systematically without manual coordination overhead.</p> <p>Selective and Safe Updates: Only template infrastructure updated while preserving project customizations with conflict detection.</p> <p>Human-Centric Integration: Clear guidance for when template changes require manual cascade triggering or other interventions.</p>"},{"location":"decisions/adr_012_template_updates/#decision","title":"Decision","text":"<p>Implement Template Update Propagation Strategy through dedicated <code>template-sync.yml</code> workflow with intelligent change detection:</p> <pre><code>graph TD\n    A[Template Repository] --&gt; B[Weekly Schedule Trigger]\n    B --&gt; C[template-sync.yml]\n    C --&gt; D[Change Detection]\n    D --&gt; E{Changes Found?}\n    E --&gt;|No| F[No Action Needed]\n    E --&gt;|Yes| G[Selective File Sync]\n    G --&gt; H[Create Update PR]\n    H --&gt; I[Create Tracking Issue]\n    I --&gt; J[Human Review]\n    J --&gt; K{Requires Cascade?}\n    K --&gt;|Yes| L[Manual Cascade Trigger]\n    K --&gt;|No| M[Direct Merge]\n    L --&gt; N[Integration Complete]\n    M --&gt; N\n\n    O[Template Commit] --&gt; P[Track Sync Version]\n    P --&gt; Q[.template-sync-commit]\n\n    style A fill:#e1f5fe,stroke:#01579b,stroke-width:2px\n    style C fill:#e8f5e9,stroke:#1b5e20,stroke-width:2px\n    style H fill:#fff3e0,stroke:#e65100,stroke-width:2px\n    style L fill:#fce4ec,stroke:#c2185b,stroke-width:2px</code></pre>"},{"location":"decisions/adr_012_template_updates/#material-schedule-template-sync-workflow-architecture","title":":material-schedule Template Sync Workflow Architecture","text":""},{"location":"decisions/adr_012_template_updates/#predictable-update-schedule","title":"Predictable Update Schedule","text":"<pre><code># template-sync.yml trigger configuration\nupdate_schedule:\n  primary_trigger:\n    schedule: \"Weekly on Monday at 8 AM (0 8 * * 1)\"\n    rationale: \"Predictable timing allows teams to expect and prepare for updates\"\n\n  manual_override:\n    workflow_dispatch: \"Manual trigger for critical security updates\"\n    use_cases: [\"Security patches\", \"Critical bug fixes\", \"Urgent feature deployments\"]\n\n  batching_benefits:\n    - \"Multiple template improvements delivered together\"\n    - \"Reduced PR noise compared to immediate propagation\"\n    - \"Predictable team workflow integration\"\n    - \"Consolidated review and testing effort\"\n</code></pre>"},{"location":"decisions/adr_012_template_updates/#intelligent-change-detection-process","title":"Intelligent Change Detection Process","text":"<pre><code># Sophisticated change detection with sync configuration\nchange_detection:\n  template_commit_tracking: |\n    # Get latest template state\n    TEMPLATE_COMMIT=$(git rev-parse template/main)\n\n    # Read last synchronized commit\n    LAST_SYNC_COMMIT=$(cat .github/.template-sync-commit)\n\n    # Get current sync configuration from template\n    git show template/main:.github/sync-config.json &gt; temp-sync-config.json\n\n  sync_path_analysis: |\n    # Build comprehensive list of paths to monitor\n    SYNC_PATHS=\"\"\n\n    # Add configured directories\n    DIRECTORIES=$(jq -r '.sync_rules.directories[]? | .path' temp-sync-config.json)\n    for dir in $DIRECTORIES; do\n      SYNC_PATHS=\"$SYNC_PATHS $dir\"\n    done\n\n    # Add configured files\n    FILES=$(jq -r '.sync_rules.files[]? | .path' temp-sync-config.json)\n    for file in $FILES; do\n      SYNC_PATHS=\"$SYNC_PATHS $file\"\n    done\n\n    # Add essential workflows\n    ESSENTIAL_WORKFLOWS=$(jq -r '.sync_rules.workflows.essential[]?' temp-sync-config.json)\n    for workflow in $ESSENTIAL_WORKFLOWS; do\n      SYNC_PATHS=\"$SYNC_PATHS $workflow\"\n    done\n\n  change_analysis: |\n    # Check for changes only in configured paths\n    CHANGES=$(git diff --name-only $LAST_SYNC_COMMIT..$TEMPLATE_COMMIT template/main -- $SYNC_PATHS)\n\n    if [ -n \"$CHANGES\" ]; then\n      echo \"Template changes detected in: $CHANGES\"\n      # Proceed with synchronization process\n    else\n      echo \"No template changes in synchronized paths\"\n      exit 0\n    fi\n</code></pre>"},{"location":"decisions/adr_012_template_updates/#material-file-sync-selective-file-synchronization-implementation","title":":material-file-sync Selective File Synchronization Implementation","text":""},{"location":"decisions/adr_012_template_updates/#configuration-driven-sync-process","title":"Configuration-Driven Sync Process","text":"<pre><code># Comprehensive selective synchronization\nselective_sync_implementation:\n  directory_sync: |\n    # Sync entire directories that should be kept identical\n    DIRECTORIES=$(jq -r '.sync_rules.directories[]? | .path' temp-sync-config.json)\n    for dir in $DIRECTORIES; do\n      if [[ $CHANGES == *\"$dir\"* ]]; then\n        echo \"Syncing directory: $dir\"\n        rm -rf \"$dir\"\n        git archive template/main \"$dir\" | tar -x\n        git add \"$dir\"\n      fi\n    done\n\n  file_sync: |\n    # Sync individual files with precise control\n    FILES=$(jq -r '.sync_rules.files[]? | .path' temp-sync-config.json)\n    for file in $FILES; do\n      if [[ $CHANGES == *\"$file\"* ]]; then\n        echo \"Syncing file: $file\"\n        git show template/main:\"$file\" &gt; \"$file\"\n        git add \"$file\"\n      fi\n    done\n\n  workflow_sync: |\n    # Sync essential workflows while preserving fork-specific ones\n    WORKFLOWS=$(jq -r '.sync_rules.workflows.essential[]?' temp-sync-config.json)\n    for workflow in $WORKFLOWS; do\n      if [[ $CHANGES == *\"$workflow\"* ]]; then\n        echo \"Syncing essential workflow: $workflow\"\n        git show template/main:\"$workflow\" &gt; \"$workflow\"\n        git add \"$workflow\"\n      fi\n    done\n</code></pre>"},{"location":"decisions/adr_012_template_updates/#version-tracking-and-state-management","title":"Version Tracking and State Management","text":"<pre><code># Comprehensive tracking of synchronization state\nversion_tracking:\n  commit_tracking: |\n    # Update tracking file with latest template commit\n    echo \"$TEMPLATE_COMMIT\" &gt; .github/.template-sync-commit\n    git add .github/.template-sync-commit\n\n  sync_metadata: |\n    # Create comprehensive synchronization record\n    cat &gt; .github/.template-sync-metadata &lt;&lt;EOF\n    last_sync_date: $(date -u +%Y-%m-%dT%H:%M:%SZ)\n    template_commit: $TEMPLATE_COMMIT\n    sync_branch: $SYNC_BRANCH\n    changed_files: $(echo \"$CHANGES\" | wc -l)\n    files_list: |\n    $(echo \"$CHANGES\" | sed 's/^/  - /')\n    EOF\n    git add .github/.template-sync-metadata\n</code></pre>"},{"location":"decisions/adr_012_template_updates/#implementation-strategy","title":"Implementation Strategy","text":""},{"location":"decisions/adr_012_template_updates/#material-bootstrap-auto-bootstrap-strategy-for-existing-repositories","title":":material-bootstrap Auto-Bootstrap Strategy for Existing Repositories","text":""},{"location":"decisions/adr_012_template_updates/#seamless-migration-support","title":"Seamless Migration Support","text":"<pre><code># Sophisticated auto-bootstrap for existing repositories\nauto_bootstrap:\n  problem: \"Repositories created before template sync lack tracking files\"\n\n  detection_logic: |\n    # Smart detection of missing or invalid tracking\n    if [ -f \"$LAST_SYNC_FILE\" ] &amp;&amp; [ -s \"$LAST_SYNC_FILE\" ]; then\n      LAST_SYNC_COMMIT=$(cat \"$LAST_SYNC_FILE\")\n      echo \"Using existing sync commit: $LAST_SYNC_COMMIT\"\n    else\n      echo \"Auto-bootstrap required: missing or empty tracking file\"\n\n      # Find earliest template infrastructure commit as baseline\n      BASELINE_COMMIT=$(git log template/main --reverse --oneline -- .github/ | head -1 | cut -d' ' -f1)\n\n      if [ -n \"$BASELINE_COMMIT\" ]; then\n        echo \"Auto-bootstrap baseline: $BASELINE_COMMIT\"\n        echo \"$BASELINE_COMMIT\" &gt; .github/.template-sync-commit\n        LAST_SYNC_COMMIT=\"$BASELINE_COMMIT\"\n      else\n        echo \"Error: Could not determine bootstrap baseline\"\n        exit 1\n      fi\n    fi\n\n  benefits:\n    - \"Seamless migration: existing repositories adopt template sync automatically\"\n    - \"Smart baseline: uses earliest template infrastructure, not arbitrary date\"\n    - \"Immediate tracking: creates tracking file to prevent future bootstrap issues\"\n    - \"Comprehensive updates: first sync includes all improvements since baseline\"\n</code></pre>"},{"location":"decisions/adr_012_template_updates/#material-account-supervisor-circle-human-centric-integration-workflow","title":":material-account-supervisor-circle Human-Centric Integration Workflow","text":""},{"location":"decisions/adr_012_template_updates/#template-update-issue-creation","title":"Template Update Issue Creation","text":"<pre><code># Enhanced issue creation with cascade guidance\ntemplate_update_issue:\n  trigger: \"After successful template sync PR creation\"\n\n  issue_content: |\n    NOTIFICATION_BODY=\"## \ud83d\udccb Template Updates Ready for Review\n\n    New template infrastructure updates are available for integration.\n\n    **Update Details:**\n    - **PR:** $PR_URL\n    - **Template Version:** $TEMPLATE_COMMIT\n    - **Changed Files:** $(git diff --name-only main...$SYNC_BRANCH | wc -l) files\n    - **Changes:** Template infrastructure improvements\n\n    **Change Categories:**\n    $(analyze_changes_and_categorize)\n\n    **Next Steps:**\n    1. \ud83d\udd0d **Review the template update PR** for infrastructure changes\n    2. \u2705 **Merge the PR** when satisfied with the updates\n    3. \ud83d\ude80 **Manually trigger 'Cascade Integration' workflow** if changes affect workflows\n    4. \ud83d\udcca **Monitor integration progress** in Actions tab\n\n    **Cascade Integration Required?**\n    $(determine_cascade_requirement)\n\n    **Timeline:**\n    - Template sync detected: $(date -u +%Y-%m-%dT%H:%M:%SZ)\n    - Action required: Human review, merge, and potential cascade trigger\"\n\n  issue_creation: |\n    gh issue create \\\n      --title \"\ud83d\udccb Template Updates Ready for Review - $(date +%Y-%m-%d)\" \\\n      --body \"$NOTIFICATION_BODY\" \\\n      --label \"template-sync,human-required\"\n</code></pre>"},{"location":"decisions/adr_012_template_updates/#cascade-integration-determination","title":"Cascade Integration Determination","text":"<pre><code># Intelligent cascade requirement analysis\ncascade_analysis:\n  workflow_changes: |\n    # Check if essential workflows were modified\n    WORKFLOW_CHANGES=$(echo \"$CHANGES\" | grep \"\\.github/workflows/\")\n    if [ -n \"$WORKFLOW_CHANGES\" ]; then\n      echo \"\u26a0\ufe0f **Workflow changes detected** - Cascade integration recommended\"\n      echo \"Modified workflows: $WORKFLOW_CHANGES\"\n    fi\n\n  configuration_changes: |\n    # Check if configuration files were modified\n    CONFIG_CHANGES=$(echo \"$CHANGES\" | grep -E \"\\.(json|yml|yaml)$\")\n    if [ -n \"$CONFIG_CHANGES\" ]; then\n      echo \"\ud83d\udd27 **Configuration changes detected** - Review for cascade impact\"\n      echo \"Modified configs: $CONFIG_CHANGES\"\n    fi\n\n  guidance_generation: |\n    # Provide specific guidance based on change analysis\n    if [[ -n \"$WORKFLOW_CHANGES\" || -n \"$CONFIG_CHANGES\" ]]; then\n      echo \"**Cascade Integration Required:** Yes - Workflow or configuration changes detected\"\n    else\n      echo \"**Cascade Integration Required:** Likely not needed - Only template/documentation changes\"\n    fi\n</code></pre>"},{"location":"decisions/adr_012_template_updates/#benefits-and-rationale","title":"Benefits and Rationale","text":""},{"location":"decisions/adr_012_template_updates/#material-trending-up-strategic-advantages","title":":material-trending-up Strategic Advantages","text":""},{"location":"decisions/adr_012_template_updates/#automatic-template-benefits-delivery","title":"Automatic Template Benefits Delivery","text":"<ul> <li>Teams automatically receive template improvements without manual coordination</li> <li>Consistent infrastructure maintenance across all repository deployments</li> <li>Security improvements automatically propagate from template to all forks</li> <li>New capabilities and features become available without migration effort</li> </ul>"},{"location":"decisions/adr_012_template_updates/#predictable-and-manageable-update-process","title":"Predictable and Manageable Update Process","text":"<ul> <li>Weekly schedule provides predictable timing for template update reviews</li> <li>Batched changes reduce PR noise compared to immediate propagation approaches</li> <li>Clear review process enables teams to validate updates before integration</li> <li>Manual override capability enables immediate updates for critical security fixes</li> </ul>"},{"location":"decisions/adr_012_template_updates/#intelligent-change-management","title":"Intelligent Change Management","text":"<ul> <li>Configuration-driven sync ensures only relevant template changes propagate</li> <li>Change categorization helps teams understand update impact and requirements</li> <li>Cascade integration determination provides clear guidance for workflow changes</li> <li>Version tracking enables troubleshooting and rollback capabilities</li> </ul>"},{"location":"decisions/adr_012_template_updates/#material-cog-outline-operational-benefits","title":":material-cog-outline Operational Benefits","text":""},{"location":"decisions/adr_012_template_updates/#reduced-maintenance-overhead","title":"Reduced Maintenance Overhead","text":"<ul> <li>Minimal manual work required for teams to stay current with template</li> <li>Auto-bootstrap enables seamless adoption for existing repositories</li> <li>Self-updating sync configuration ensures process consistency</li> <li>Clear documentation of changes enables efficient review processes</li> </ul>"},{"location":"decisions/adr_012_template_updates/#enhanced-system-reliability","title":"Enhanced System Reliability","text":"<ul> <li>Selective syncing preserves project customizations while updating infrastructure</li> <li>Conflict detection through PR process prevents integration issues</li> <li>Human review checkpoints ensure appropriate validation before changes</li> <li>Comprehensive tracking enables effective troubleshooting and analysis</li> </ul>"},{"location":"decisions/adr_012_template_updates/#alternative-approaches-considered","title":"Alternative Approaches Considered","text":""},{"location":"decisions/adr_012_template_updates/#push-based-updates-from-template","title":"Push-Based Updates from Template","text":"<p>Approach: Central template repository pushes updates directly to all forks</p> <ul> <li>Pros: Immediate propagation, centralized control over update timing</li> <li>Cons: Requires write access to all forks, significant security concerns, bypass review</li> <li>Decision: Rejected due to security implications and access complexity</li> </ul>"},{"location":"decisions/adr_012_template_updates/#manual-update-documentation-process","title":"Manual Update Documentation Process","text":"<p>Approach: Comprehensive documentation with manual update instructions</p> <ul> <li>Pros: Full team control over update timing and implementation</li> <li>Cons: Poor adoption rates, inconsistent application, maintenance burden</li> <li>Decision: Rejected due to historical poor adoption and consistency issues</li> </ul>"},{"location":"decisions/adr_012_template_updates/#webhook-based-real-time-updates","title":"Webhook-Based Real-Time Updates","text":"<p>Approach: Immediate template synchronization on every template change</p> <ul> <li>Pros: Zero delay between template improvement and fork availability</li> <li>Cons: Complex setup, potential for update spam, disruptive to team workflows</li> <li>Decision: Rejected in favor of predictable scheduled batching approach</li> </ul>"},{"location":"decisions/adr_012_template_updates/#git-submodule-template-infrastructure","title":"Git Submodule Template Infrastructure","text":"<p>Approach: Template infrastructure as Git submodule in each fork</p> <ul> <li>Pros: Native Git functionality, well-understood by developers</li> <li>Cons: Complex team experience, doesn't handle selective synchronization requirements</li> <li>Decision: Rejected due to user experience complexity and sync limitations</li> </ul>"},{"location":"decisions/adr_012_template_updates/#consequences-and-trade-offs","title":"Consequences and Trade-offs","text":""},{"location":"decisions/adr_012_template_updates/#positive-outcomes","title":"Positive Outcomes","text":""},{"location":"decisions/adr_012_template_updates/#systematic-template-benefits-delivery","title":"Systematic Template Benefits Delivery","text":"<ul> <li>Automatic propagation ensures teams receive template improvements consistently</li> <li>Reduced maintenance overhead through elimination of manual update processes</li> <li>Security currency through automatic propagation of security improvements</li> <li>Feature adoption acceleration through automated availability of new capabilities</li> </ul>"},{"location":"decisions/adr_012_template_updates/#enhanced-change-management","title":"Enhanced Change Management","text":"<ul> <li>Clear visibility into template changes through comprehensive PR descriptions</li> <li>Review process enables validation and testing before integration</li> <li>Human control over cascade integration timing based on change impact</li> <li>Comprehensive version tracking enables troubleshooting and rollback</li> </ul>"},{"location":"decisions/adr_012_template_updates/#improved-system-consistency","title":"Improved System Consistency","text":"<ul> <li>All repositories maintain current template infrastructure automatically</li> <li>Consistent behavior across unlimited repository deployments</li> <li>Auto-bootstrap enables seamless adoption for existing repositories</li> <li>Self-updating configuration ensures process consistency</li> </ul>"},{"location":"decisions/adr_012_template_updates/#material-minus-trade-offs-and-limitations","title":":material-minus Trade-offs and Limitations","text":""},{"location":"decisions/adr_012_template_updates/#process-overhead-and-coordination","title":"Process Overhead and Coordination","text":"<ul> <li>Weekly template update PRs and tracking issues require team attention</li> <li>Manual integration steps for workflow changes may require cascade triggering</li> <li>Potential conflicts when template changes intersect with local modifications</li> <li>Learning curve for understanding cascade integration requirements</li> </ul>"},{"location":"decisions/adr_012_template_updates/#update-timing-and-dependencies","title":"Update Timing and Dependencies","text":"<ul> <li>Template improvements take up to one week to reach all forks (mitigated by manual override)</li> <li>Dependency on template repository availability for synchronization</li> <li>Update lag may delay adoption of critical security fixes (mitigated by manual trigger)</li> </ul>"},{"location":"decisions/adr_012_template_updates/#success-metrics","title":"Success Metrics","text":""},{"location":"decisions/adr_012_template_updates/#quantitative-indicators","title":"Quantitative Indicators","text":"<ul> <li>Update Propagation Speed: Template improvements reach 100% of forks within one week</li> <li>Adoption Rate: &gt;90% of template update PRs successfully merged by teams</li> <li>Security Update Speed: Critical security updates propagated within 24 hours via manual trigger</li> <li>Auto-Bootstrap Success: 100% of existing repositories successfully adopt template sync</li> </ul>"},{"location":"decisions/adr_012_template_updates/#qualitative-indicators","title":"Qualitative Indicators","text":"<ul> <li>Teams report high satisfaction with template update predictability and clarity</li> <li>Effective change categorization and cascade integration guidance</li> <li>Successful elimination of template drift across all repository deployments</li> <li>Clear understanding of when template changes require additional manual actions</li> </ul>"},{"location":"decisions/adr_012_template_updates/#integration-points","title":"Integration Points","text":""},{"location":"decisions/adr_012_template_updates/#material-source-branch-template-and-configuration-integration","title":":material-source-branch Template and Configuration Integration","text":""},{"location":"decisions/adr_012_template_updates/#configuration-driven-synchronization-per-adr-011","title":"Configuration-Driven Synchronization (per ADR-011)","text":"<ul> <li>Template update strategy builds on sync configuration foundation</li> <li>Selective synchronization rules prevent project customization conflicts</li> <li>Self-updating configuration ensures consistent process across deployments</li> </ul>"},{"location":"decisions/adr_012_template_updates/#template-repository-pattern-per-adr-003","title":"Template Repository Pattern (per ADR-003)","text":"<ul> <li>Update propagation extends template repository with systematic improvement delivery</li> <li>Auto-bootstrap enables seamless adoption without manual configuration</li> <li>Preserves template self-configuration benefits while adding update capabilities</li> </ul>"},{"location":"decisions/adr_012_template_updates/#material-account-supervisor-circle-human-centric-workflow-integration","title":":material-account-supervisor-circle Human-Centric Workflow Integration","text":""},{"location":"decisions/adr_012_template_updates/#cascade-monitor-pattern-per-adr-019","title":"Cascade Monitor Pattern (per ADR-019)","text":"<ul> <li>Template updates integrate with human-centric cascade triggering approach</li> <li>Clear guidance provided for when template changes require cascade integration</li> <li>Issue-based coordination enables effective communication and tracking</li> </ul>"},{"location":"decisions/adr_012_template_updates/#related-decisions","title":"Related Decisions","text":"<ul> <li>ADR-011: Configuration-driven template synchronization provides foundation</li> <li>ADR-003: Template repository pattern extended by update propagation</li> <li>ADR-013: Reusable GitHub Actions pattern enables consistent PR creation</li> <li>ADR-019: Human-centric cascade pattern coordinates with template updates</li> </ul> <p>This template update propagation strategy provides systematic, automated delivery of template improvements while preserving project customizations, enabling predictable maintenance workflows through intelligent change detection, selective synchronization, and human-centric integration guidance.</p>"},{"location":"decisions/adr_013_reusable_actions/","title":"ADR-013: Reusable GitHub Actions Pattern for PR Creation","text":"<p> Critical Decision |  2025-06-04 |  Accepted</p>"},{"location":"decisions/adr_013_reusable_actions/#problem-statement","title":"Problem Statement","text":"<p>During template synchronization workflow implementation, significant code duplication was identified in PR creation logic across multiple workflows. Each workflow requiring pull request creation had to implement identical functionality for LLM detection, AI-enhanced description generation, fallback handling, and GitHub API integration, creating maintenance burden and consistency risks.</p>"},{"location":"decisions/adr_013_reusable_actions/#context-and-requirements","title":"Context and Requirements","text":""},{"location":"decisions/adr_013_reusable_actions/#code-duplication-and-maintenance-issues","title":"Code Duplication and Maintenance Issues","text":"<p>Duplicated PR Creation Components: - LLM detection logic checking for available API keys (Anthropic, Azure OpenAI, OpenAI) - aipr integration for generating AI-enhanced PR descriptions with multiple provider support - Fallback handling when AI generation fails or API keys are unavailable - Diff size management to avoid token limits with large changes - GitHub PR creation with proper parameters and error handling - Output management returning PR URLs and numbers for workflow coordination</p> <p>Affected Workflows with Similar Requirements: <pre><code>affected_workflows:\n  sync_workflow:\n    purpose: \"Creates upstream synchronization PRs with vulnerability analysis\"\n    complexity: \"80+ lines of PR creation logic with AI enhancement\"\n\n  template_sync_workflow:\n    purpose: \"Creates template update PRs with change summaries\"\n    complexity: \"75+ lines of similar PR creation logic\"\n\n  future_workflows:\n    purpose: \"Additional automation requiring AI-enhanced PR descriptions\"\n    complexity: \"Would require duplicating existing patterns\"\n</code></pre></p> <p>Problems with Current Approach: - Maintenance burden: changes to PR creation logic required updates in multiple locations - Inconsistency risk: implementations could drift apart over time without coordination - Testing complexity: each workflow implementation needed separate testing and validation - Feature lag: improvements to one workflow didn't automatically benefit others</p>"},{"location":"decisions/adr_013_reusable_actions/#reusable-pattern-requirements","title":"Reusable Pattern Requirements","text":"<p>Centralized Logic: Single implementation of PR creation with AI enhancement to eliminate duplication.</p> <p>Configurable Interface: Flexible parameters supporting different use cases while maintaining consistency.</p> <p>AI Integration: Built-in aipr integration with multiple LLM providers and intelligent fallback handling.</p>"},{"location":"decisions/adr_013_reusable_actions/#decision","title":"Decision","text":"<p>Implement Reusable GitHub Actions Pattern through custom composite action for common PR creation functionality:</p> <pre><code>graph TD\n    A[Workflow Needs PR] --&gt; B[Uses Composite Action]\n    B --&gt; C[Detect Available LLM]\n    C --&gt; D{LLM Available?}\n    D --&gt;|Yes| E[Generate AI Description]\n    D --&gt;|No| F[Use Fallback Description]\n    E --&gt; G{AI Generation Success?}\n    G --&gt;|Yes| H[Use AI Description]\n    G --&gt;|No| F\n    F --&gt; I[Create GitHub PR]\n    H --&gt; I\n    I --&gt; J[Return PR URL &amp; Number]\n\n    K[Branch Limitation] --&gt; L{Running from main?}\n    L --&gt;|Yes| M[Can Use Action]\n    L --&gt;|No| N[Must Embed Logic]\n\n    style A fill:#e1f5fe,stroke:#01579b,stroke-width:2px\n    style E fill:#e8f5e9,stroke:#1b5e20,stroke-width:2px\n    style F fill:#fff3e0,stroke:#e65100,stroke-width:2px\n    style N fill:#fce4ec,stroke:#c2185b,stroke-width:2px</code></pre>"},{"location":"decisions/adr_013_reusable_actions/#material-package-custom-composite-action-architecture","title":":material-package Custom Composite Action Architecture","text":""},{"location":"decisions/adr_013_reusable_actions/#centralized-implementation-githubactionscreate-enhanced-practionyml","title":"Centralized Implementation (.github/actions/create-enhanced-pr/action.yml)","text":"<pre><code># Comprehensive composite action structure\ncomposite_action:\n  name: \"Create Enhanced PR\"\n  description: \"Creates GitHub PR with AI-enhanced descriptions using multiple LLM providers\"\n\n  runs:\n    using: 'composite'\n    steps:\n      - name: Detect available LLM provider\n        shell: bash\n        run: |\n          # Priority order: Anthropic \u2192 Azure OpenAI \u2192 OpenAI \u2192 Fallback\n          if [ -n \"${{ inputs.anthropic-api-key }}\" ]; then\n            echo \"provider=anthropic\" &gt;&gt; $GITHUB_OUTPUT\n            echo \"model=claude-4\" &gt;&gt; $GITHUB_OUTPUT\n          elif [ -n \"${{ inputs.azure-api-key }}\" ] &amp;&amp; [ -n \"${{ inputs.azure-api-base }}\" ]; then\n            echo \"provider=azure\" &gt;&gt; $GITHUB_OUTPUT\n            echo \"model=azure/gpt-4o\" &gt;&gt; $GITHUB_OUTPUT\n          elif [ -n \"${{ inputs.openai-api-key }}\" ]; then\n            echo \"provider=openai\" &gt;&gt; $GITHUB_OUTPUT\n            echo \"model=gpt-4.1\" &gt;&gt; $GITHUB_OUTPUT\n          else\n            echo \"provider=fallback\" &gt;&gt; $GITHUB_OUTPUT\n          fi\n\n      - name: Check diff size and generate description\n        shell: bash\n        run: |\n          # Intelligent diff size management\n          DIFF_LINES=$(git diff --name-only ${{ inputs.base-branch }}...${{ inputs.head-branch }} | wc -l)\n          MAX_LINES=${{ inputs.max-diff-lines || '20000' }}\n\n          if [ \"$DIFF_LINES\" -gt \"$MAX_LINES\" ]; then\n            echo \"Diff too large ($DIFF_LINES lines), using fallback description\"\n            echo \"description=${{ inputs.fallback-description }}\" &gt;&gt; $GITHUB_OUTPUT\n            echo \"used-aipr=false\" &gt;&gt; $GITHUB_OUTPUT\n          elif [ \"${{ steps.detect-llm.outputs.provider }}\" = \"fallback\" ]; then\n            echo \"No LLM provider available, using fallback description\"\n            echo \"description=${{ inputs.fallback-description }}\" &gt;&gt; $GITHUB_OUTPUT\n            echo \"used-aipr=false\" &gt;&gt; $GITHUB_OUTPUT\n          else\n            # Generate AI-enhanced description\n            aipr_generate_and_output_description\n          fi\n</code></pre>"},{"location":"decisions/adr_013_reusable_actions/#comprehensive-input-interface","title":"Comprehensive Input Interface","text":"<pre><code># Flexible configuration supporting multiple use cases\ninput_interface:\n  required_inputs:\n    github-token: \"GitHub token for API access and PR creation\"\n    base-branch: \"Target branch for pull request\"\n    head-branch: \"Source branch containing changes\"\n    pr-title: \"Title for the pull request\"\n    fallback-description: \"Description to use if AI generation fails\"\n\n  optional_inputs:\n    anthropic-api-key: \"Anthropic Claude API key for AI enhancement\"\n    azure-api-key: \"Azure OpenAI API key\"\n    azure-api-base: \"Azure OpenAI endpoint URL\"\n    azure-api-version: \"Azure OpenAI API version\"\n    openai-api-key: \"OpenAI API key\"\n    max-diff-lines: \"Maximum diff size for AI processing (default: 20000)\"\n    use-vulns-flag: \"Enable vulnerability analysis (default: true)\"\n    target-branch-for-aipr: \"Branch for aipr analysis (defaults to base-branch)\"\n    additional-description: \"Extra content to append to generated description\"\n</code></pre>"},{"location":"decisions/adr_013_reusable_actions/#standardized-output-interface","title":"Standardized Output Interface","text":"<pre><code># Comprehensive outputs for workflow coordination\noutput_interface:\n  pr-url: \"Complete URL to created pull request\"\n  pr-number: \"Pull request number for further processing\"\n  used-aipr: \"Boolean indicating if AI enhancement was successfully used\"\n  provider-used: \"LLM provider used for description generation\"\n  description-length: \"Character count of generated description\"\n</code></pre>"},{"location":"decisions/adr_013_reusable_actions/#material-artificial-intelligence-ai-enhancement-pipeline","title":":material-artificial-intelligence AI Enhancement Pipeline","text":""},{"location":"decisions/adr_013_reusable_actions/#multi-provider-llm-detection","title":"Multi-Provider LLM Detection","text":"<pre><code># Sophisticated provider priority and fallback system\nllm_provider_system:\n  priority_order:\n    1: \"Anthropic Claude (if ANTHROPIC_API_KEY provided)\"\n    2: \"Azure OpenAI (if AZURE_API_KEY and AZURE_API_BASE provided)\"\n    3: \"OpenAI (if OPENAI_API_KEY provided)\"\n    4: \"Fallback to provided description\"\n\n  model_configuration:\n    anthropic: \"claude-4 for advanced code analysis\"\n    azure: \"azure/gpt-4o for enterprise environments\"\n    openai: \"gpt-4.1 for general use cases\"\n\n  intelligent_fallback:\n    diff_size_limit: \"Skip AI generation for diffs &gt;20,000 lines\"\n    api_failure_handling: \"Graceful degradation to fallback description\"\n    timeout_management: \"AI generation timeout with fallback\"\n</code></pre>"},{"location":"decisions/adr_013_reusable_actions/#content-generation-strategy","title":"Content Generation Strategy","text":"<pre><code># Advanced AI-enhanced description generation\ncontent_generation:\n  analysis_capabilities:\n    code_changes: \"Detailed analysis of code modifications\"\n    vulnerability_assessment: \"Security impact analysis when enabled\"\n    dependency_updates: \"Package and dependency change summaries\"\n    breaking_changes: \"Detection and documentation of breaking changes\"\n\n  description_structure:\n    summary: \"High-level overview of changes\"\n    technical_details: \"Specific implementation changes\"\n    impact_assessment: \"Business and operational impact\"\n    testing_notes: \"Recommended testing approaches\"\n    additional_content: \"Custom content appended to generated description\"\n</code></pre>"},{"location":"decisions/adr_013_reusable_actions/#implementation-strategy","title":"Implementation Strategy","text":""},{"location":"decisions/adr_013_reusable_actions/#material-workflow-usage-patterns-and-limitations","title":":material-workflow Usage Patterns and Limitations","text":""},{"location":"decisions/adr_013_reusable_actions/#main-branch-workflows-can-use-action","title":"Main Branch Workflows (Can Use Action)","text":"<pre><code># Workflows that can leverage the reusable action\nmain_branch_workflows:\n  template_sync_workflow:\n    usage: |\n      - name: Create enhanced template sync PR\n        uses: ./.github/actions/create-enhanced-pr\n        with:\n          base-branch: main\n          head-branch: ${{ env.SYNC_BRANCH }}\n          pr-title: \"\ud83d\udd04 Sync template updates $(date +%Y-%m-%d)\"\n          fallback-description: ${{ env.FALLBACK_DESCRIPTION }}\n          use-vulns-flag: 'false'\n          target-branch-for-aipr: main\n\n  build_workflow:\n    usage: \"Can use action for automated release PRs\"\n\n  validation_workflow:\n    usage: \"Can use action for validation result PRs\"\n</code></pre>"},{"location":"decisions/adr_013_reusable_actions/#branch-limitation-handling","title":"Branch Limitation Handling","text":"<pre><code># Critical discovery: GitHub Actions branch dependency\nbranch_limitations:\n  problem: \"GitHub Actions can only reference actions on the same branch where workflow runs\"\n\n  affected_workflows:\n    sync_workflow:\n      issue: \"Runs from fork_upstream branch where action doesn't exist\"\n      solution: \"Embed PR creation logic directly in workflow\"\n\n  implementation_strategy:\n    primary_pattern: \"Use reusable action for main branch workflows\"\n    fallback_pattern: \"Embed logic directly when branch limitations prevent action usage\"\n    consistency_approach: \"Maintain identical AI enhancement logic in both patterns\"\n</code></pre>"},{"location":"decisions/adr_013_reusable_actions/#sync-workflow-embedded-logic","title":"Sync Workflow Embedded Logic","text":"<pre><code># Required embedded implementation for sync workflow\nsync_workflow_embedded:\n  reason: \"Action not available on fork_upstream branch\"\n\n  implementation: |\n    # \u274c This DOES NOT work in sync.yml\n    - name: Create enhanced sync PR\n      uses: ./.github/actions/create-enhanced-pr  # Action doesn't exist on fork_upstream\n\n    # \u2705 This works in sync.yml (embedded logic)\n    - name: Create enhanced sync PR\n      env:\n        GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}\n        ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}\n      run: |\n        # Detect available LLM provider\n        if [ -n \"$ANTHROPIC_API_KEY\" ]; then\n          PROVIDER=\"anthropic\"\n          MODEL=\"claude-4\"\n        elif [ -n \"$AZURE_API_KEY\" ] &amp;&amp; [ -n \"$AZURE_API_BASE\" ]; then\n          PROVIDER=\"azure\"\n          MODEL=\"azure/gpt-4o\"\n        else\n          PROVIDER=\"fallback\"\n        fi\n\n        # Generate AI-enhanced description with same logic as action\n        [embedded aipr generation logic]\n</code></pre>"},{"location":"decisions/adr_013_reusable_actions/#material-shield-check-error-handling-and-reliability","title":":material-shield-check Error Handling and Reliability","text":""},{"location":"decisions/adr_013_reusable_actions/#graceful-degradation-framework","title":"Graceful Degradation Framework","text":"<pre><code># Comprehensive error handling ensuring PR creation always succeeds\nerror_handling:\n  ai_generation_failure:\n    detection: \"Monitor aipr command exit codes and output\"\n    response: \"Log warning and proceed with fallback description\"\n\n  api_key_validation:\n    detection: \"Verify API key format and availability\"\n    response: \"Skip AI generation and use fallback description\"\n\n  network_issues:\n    detection: \"Timeout handling for AI API calls\"\n    response: \"Automatic fallback after 30-second timeout\"\n\n  github_api_issues:\n    detection: \"GitHub PR creation API failures\"\n    response: \"Retry with exponential backoff, detailed error logging\"\n</code></pre>"},{"location":"decisions/adr_013_reusable_actions/#comprehensive-logging-and-debugging","title":"Comprehensive Logging and Debugging","text":"<pre><code># Enhanced observability for troubleshooting\nlogging_framework:\n  provider_detection: \"Log which LLM provider was selected and why\"\n  ai_generation: \"Log AI generation success/failure with timing\"\n  fallback_usage: \"Clear indication when fallback description used\"\n  pr_creation: \"Detailed logging of GitHub API interactions\"\n  output_validation: \"Verify all expected outputs are generated\"\n</code></pre>"},{"location":"decisions/adr_013_reusable_actions/#benefits-and-rationale","title":"Benefits and Rationale","text":""},{"location":"decisions/adr_013_reusable_actions/#material-trending-up-strategic-advantages","title":":material-trending-up Strategic Advantages","text":""},{"location":"decisions/adr_013_reusable_actions/#code-duplication-elimination","title":"Code Duplication Elimination","text":"<ul> <li>Single implementation of 80+ lines of PR creation logic eliminates maintenance burden</li> <li>Consistent AI enhancement across all workflows using the reusable action</li> <li>Centralized improvements benefit all consuming workflows automatically</li> <li>Reduced testing complexity through single action testing instead of multiple implementations</li> </ul>"},{"location":"decisions/adr_013_reusable_actions/#enhanced-maintainability-and-consistency","title":"Enhanced Maintainability and Consistency","text":"<ul> <li>Changes to PR creation behavior only need to be made in one location</li> <li>Standardized interface ensures consistent behavior across different workflows</li> <li>Better error handling through centralized error management and logging</li> <li>Enhanced flexibility enabling easy addition of new parameters or features</li> </ul>"},{"location":"decisions/adr_013_reusable_actions/#development-experience-improvement","title":"Development Experience Improvement","text":"<ul> <li>Workflows can focus on business logic rather than PR creation implementation details</li> <li>Clear separation of concerns between workflow logic and PR creation functionality</li> <li>Improved readability as workflows become more focused and easier to understand</li> <li>Easier debugging with issues isolated to single action implementation</li> </ul>"},{"location":"decisions/adr_013_reusable_actions/#material-cog-outline-operational-benefits","title":":material-cog-outline Operational Benefits","text":""},{"location":"decisions/adr_013_reusable_actions/#ai-integration-excellence","title":"AI Integration Excellence","text":"<ul> <li>Consistent aipr configuration across all workflows using the action</li> <li>Provider flexibility with support for multiple LLM providers and automatic fallback</li> <li>Centralized configuration management for API keys and parameters</li> <li>Performance optimization through shared diff size management and token limit handling</li> </ul>"},{"location":"decisions/adr_013_reusable_actions/#workflow-simplification","title":"Workflow Simplification","text":"<ul> <li>Reduced complexity as workflows delegate PR creation to specialized action</li> <li>Standardized outputs enable consistent workflow coordination patterns</li> <li>Enhanced error resilience through graceful degradation and fallback mechanisms</li> <li>Better testing capability through isolated action testing</li> </ul>"},{"location":"decisions/adr_013_reusable_actions/#alternative-approaches-considered","title":"Alternative Approaches Considered","text":""},{"location":"decisions/adr_013_reusable_actions/#shared-shell-functions","title":"Shared Shell Functions","text":"<p>Approach: Extract common functionality into shared shell scripts</p> <ul> <li>Pros: Lightweight approach, easy to understand and modify</li> <li>Cons: Limited parameter handling, no type safety, harder to test effectively</li> <li>Decision: Rejected due to limited flexibility and maintainability concerns</li> </ul>"},{"location":"decisions/adr_013_reusable_actions/#external-action-from-github-marketplace","title":"External Action from GitHub Marketplace","text":"<p>Approach: Use existing community-maintained action for PR creation</p> <ul> <li>Pros: Maintained by community, potentially more features and wider adoption</li> <li>Cons: External dependency, less control over behavior, may not support aipr integration</li> <li>Decision: Rejected due to specific requirements for AI enhancement and control needs</li> </ul>"},{"location":"decisions/adr_013_reusable_actions/#copy-paste-with-documentation","title":"Copy-Paste with Documentation","text":"<p>Approach: Maintain documented copy-paste patterns for PR creation</p> <ul> <li>Pros: Simple approach with no abstraction complexity</li> <li>Cons: Significant maintenance burden, high inconsistency risk, violates DRY principle</li> <li>Decision: Rejected due to long-term maintenance concerns and consistency requirements</li> </ul>"},{"location":"decisions/adr_013_reusable_actions/#npm-package-for-pr-creation","title":"NPM Package for PR Creation","text":"<p>Approach: Create external NPM package for PR creation functionality</p> <ul> <li>Pros: Version management capabilities, external reusability across projects</li> <li>Cons: External dependency, requires Node.js setup in workflows, additional complexity</li> <li>Decision: Rejected due to complexity and external dependencies for internal use case</li> </ul>"},{"location":"decisions/adr_013_reusable_actions/#consequences-and-trade-offs","title":"Consequences and Trade-offs","text":""},{"location":"decisions/adr_013_reusable_actions/#positive-outcomes","title":"Positive Outcomes","text":""},{"location":"decisions/adr_013_reusable_actions/#maintenance-and-consistency-excellence","title":"Maintenance and Consistency Excellence","text":"<ul> <li>Eliminated 80+ lines of duplicated PR creation logic across multiple workflows</li> <li>Consistent AI enhancement ensuring identical behavior across all PR creation</li> <li>Single location for updates reducing coordination overhead and consistency risks</li> <li>Improved testing through independent action testing and validation</li> </ul>"},{"location":"decisions/adr_013_reusable_actions/#enhanced-development-experience","title":"Enhanced Development Experience","text":"<ul> <li>Workflows simplified to focus on core business logic rather than PR creation details</li> <li>Better error handling through centralized error management and graceful degradation</li> <li>Enhanced flexibility enabling easy customization for specific use cases</li> <li>Clear interface documentation reducing learning curve for new team members</li> </ul>"},{"location":"decisions/adr_013_reusable_actions/#ai-integration-and-reliability","title":"AI Integration and Reliability","text":"<ul> <li>Centralized AI enhancement logic ensuring consistent behavior across workflows</li> <li>Multiple LLM provider support with intelligent fallback handling</li> <li>Comprehensive error handling ensuring PR creation succeeds regardless of AI generation</li> <li>Performance optimization through shared diff size management and timeout handling</li> </ul>"},{"location":"decisions/adr_013_reusable_actions/#trade-offs-and-limitations","title":"Trade-offs and Limitations","text":""},{"location":"decisions/adr_013_reusable_actions/#abstraction-and-complexity","title":"Abstraction and Complexity","text":"<ul> <li>Additional abstraction layer between workflows and GitHub API</li> <li>Learning curve for team members to understand action interface and capabilities</li> <li>Composite action complexity with multiple steps and conditional logic</li> <li>Local development challenges for testing workflows using the action</li> </ul>"},{"location":"decisions/adr_013_reusable_actions/#branch-dependency-limitations","title":"Branch Dependency Limitations","text":"<ul> <li>Critical limitation: actions can only be used by workflows running from same branch</li> <li>Sync workflow must embed logic directly due to running from fork_upstream branch</li> <li>Partial code duplication remains for workflows that cannot use the action</li> <li>Need to maintain consistency between action and embedded implementations</li> </ul>"},{"location":"decisions/adr_013_reusable_actions/#success-metrics","title":"Success Metrics","text":""},{"location":"decisions/adr_013_reusable_actions/#quantitative-indicators","title":"Quantitative Indicators","text":"<ul> <li>Code Duplication Reduction: 80%+ reduction in PR creation logic duplication (limited by branch constraints)</li> <li>Maintenance Efficiency: Single location updates for most PR creation behavior</li> <li>Consistency Achievement: 100% identical enhancement logic for workflows using action</li> <li>Integration Success: New main-branch workflows easily adopt enhanced PR creation</li> </ul>"},{"location":"decisions/adr_013_reusable_actions/#qualitative-indicators","title":"Qualitative Indicators","text":"<ul> <li>Teams report improved workflow development experience and reduced complexity</li> <li>Clear understanding of when to use action versus embedded logic approach</li> <li>Effective AI enhancement providing value in PR descriptions and review process</li> <li>Successful maintenance of functionality while improving code organization</li> </ul>"},{"location":"decisions/adr_013_reusable_actions/#integration-points","title":"Integration Points","text":""},{"location":"decisions/adr_013_reusable_actions/#material-source-branch-template-and-workflow-integration","title":":material-source-branch Template and Workflow Integration","text":""},{"location":"decisions/adr_013_reusable_actions/#template-update-propagation-per-adr-012","title":"Template Update Propagation (per ADR-012)","text":"<ul> <li>Template sync workflow leverages reusable action for consistent PR creation</li> <li>AI-enhanced descriptions improve template update visibility and review</li> <li>Standardized interface enables easy customization for template-specific requirements</li> </ul>"},{"location":"decisions/adr_013_reusable_actions/#ai-enhanced-development-per-adr-014","title":"AI-Enhanced Development (per ADR-014)","text":"<ul> <li>Reusable action implements AI capabilities defined in AI integration strategy</li> <li>Multiple LLM provider support aligns with AI integration architecture</li> <li>Fallback handling ensures reliability regardless of AI service availability</li> </ul>"},{"location":"decisions/adr_013_reusable_actions/#material-quality-assurance-quality-and-testing-integration","title":":material-quality-assurance Quality and Testing Integration","text":""},{"location":"decisions/adr_013_reusable_actions/#workflow-simplification_1","title":"Workflow Simplification","text":"<ul> <li>Clear separation between business logic and PR creation concerns</li> <li>Enhanced testability through isolated action testing</li> <li>Improved debugging with centralized error handling and logging</li> </ul>"},{"location":"decisions/adr_013_reusable_actions/#related-decisions","title":"Related Decisions","text":"<ul> <li>ADR-011: Configuration-driven template synchronization benefits from consistent PR creation</li> <li>ADR-012: Template update propagation uses this action for enhanced PR descriptions</li> <li>ADR-014: AI-enhanced development workflow implements AI capabilities used by this action</li> <li>ADR-010: YAML-safe scripting patterns applied in action implementation</li> </ul> <p>This reusable GitHub Actions pattern eliminates code duplication while providing consistent, AI-enhanced PR creation across workflows, with intelligent handling of branch limitations and comprehensive fallback mechanisms ensuring reliable operation.</p>"},{"location":"decisions/adr_014_ai_integration/","title":"ADR-014: AI-Enhanced Development Workflow Integration","text":"<p> High Impact |  2025-06-04 |  Accepted</p>"},{"location":"decisions/adr_014_ai_integration/#problem-statement","title":"Problem Statement","text":"<p>Modern development workflows can benefit significantly from AI assistance in code analysis, security scanning, and documentation generation. The fork management system presents opportunities to integrate AI capabilities that enhance developer productivity while maintaining workflow reliability and cost-effectiveness.</p>"},{"location":"decisions/adr_014_ai_integration/#context-and-requirements","title":"Context and Requirements","text":""},{"location":"decisions/adr_014_ai_integration/#ai-integration-opportunities","title":"AI Integration Opportunities","text":"<p>Pull Request Enhancement: - Generate comprehensive PR descriptions using AI analysis of code changes - Provide structured conflict categorization and resolution guidance - Create intelligent summaries of template updates and upstream changes</p> <p>Security Analysis: - AI-powered triage of vulnerability scans with actionable insights - Intelligent prioritization based on actual risk assessment - Context-aware security recommendations</p> <p>Development Assistance: - AI-assisted commit message generation following conventional standards - Automated documentation updates and consistency checks - Intelligent change impact analysis</p>"},{"location":"decisions/adr_014_ai_integration/#integration-requirements","title":"Integration Requirements","text":"<p>Optional Enhancement Philosophy: - AI should enhance workflows without being required for basic functionality - All core operations must work reliably when AI services are unavailable - Graceful degradation to standard templates when AI is not accessible</p> <p>Multi-Provider Architecture: - Support multiple AI providers to avoid vendor lock-in - Intelligent provider selection based on availability and capabilities - Cost-conscious usage patterns with configurable limits</p> <p>Security and Reliability: - Safe handling of API keys and sensitive data through GitHub secrets - Robust error handling with clear fallback mechanisms - No exposure of sensitive code or data to AI providers</p>"},{"location":"decisions/adr_014_ai_integration/#decision","title":"Decision","text":"<p>Implement AI-Enhanced Development Workflow Integration with a sophisticated multi-provider architecture:</p> <pre><code>graph TD\n    A[Workflow Trigger] --&gt; B[AI Provider Selection]\n    B --&gt; C{Primary: Claude}\n    B --&gt; D{Secondary: Azure OpenAI}\n    B --&gt; E{Tertiary: OpenAI}\n\n    C --&gt; F[Claude Code CLI]\n    C --&gt; G[Direct API Access]\n    D --&gt; H[Azure OpenAI Service]\n    E --&gt; I[OpenAI GPT-4]\n\n    F --&gt; J[AI Analysis Output]\n    G --&gt; J\n    H --&gt; J\n    I --&gt; J\n\n    J --&gt; K[Fallback to Standard Template]\n\n    style A fill:#e1f5fe,stroke:#01579b,stroke-width:2px\n    style C fill:#e8f5e9,stroke:#1b5e20,stroke-width:2px\n    style D fill:#fff3e0,stroke:#e65100,stroke-width:2px\n    style E fill:#fce4ec,stroke:#c2185b,stroke-width:2px</code></pre>"},{"location":"decisions/adr_014_ai_integration/#primary-ai-integration-claude-code-cli","title":"Primary AI Integration: Claude Code CLI","text":""},{"location":"decisions/adr_014_ai_integration/#advanced-tooling-integration","title":"Advanced Tooling Integration","text":"<pre><code># Automated Claude Code CLI setup\n- name: Install Claude Code CLI\n  run: npm install -g @anthropic-ai/claude-code\n\n# MCP Configuration for specialized tools\n- name: Configure MCP Servers\n  run: |\n    cat &gt; .mcp.json &lt;&lt; 'EOF'\n    {\n      \"mcpServers\": {\n        \"mvn-mcp-server\": {\n          \"type\": \"stdio\",\n          \"command\": \"uvx\",\n          \"args\": [\"--from\", \"git+https://github.com/danielscholl-osdu/mvn-mcp-server@main\", \"mvn-mcp-server\"]\n        }\n      }\n    }\n    EOF\n</code></pre>"},{"location":"decisions/adr_014_ai_integration/#specialized-capabilities","title":"Specialized Capabilities","text":"<ul> <li>Code Analysis: Deep understanding of code changes and their implications</li> <li>Dependency Management: Enhanced Maven/Gradle analysis through MCP servers</li> <li>Security Assessment: Intelligent vulnerability triage and prioritization</li> <li>Documentation Generation: Context-aware technical documentation</li> </ul>"},{"location":"decisions/adr_014_ai_integration/#secondary-provider-azure-openai","title":"Secondary Provider: Azure OpenAI","text":""},{"location":"decisions/adr_014_ai_integration/#enterprise-integration","title":"Enterprise Integration","text":"<pre><code># Azure OpenAI configuration for enterprise environments\n- name: Configure Azure OpenAI\n  if: env.AZURE_API_KEY\n  run: |\n    # Enterprise-grade AI with compliance features\n    # Cost control and data residency support\n    # Managed identity integration\n</code></pre> <p>Enterprise Benefits: - Integration with Microsoft ecosystem - Enhanced compliance and security features - Predictable costs and SLA support - Data residency and governance controls</p>"},{"location":"decisions/adr_014_ai_integration/#material-openai-tertiary-provider-openai","title":":material-openai: Tertiary Provider: OpenAI","text":""},{"location":"decisions/adr_014_ai_integration/#fallback-capability","title":"Fallback Capability","text":"<pre><code># OpenAI as final fallback option\n- name: Configure OpenAI Fallback\n  if: env.OPENAI_API_KEY &amp;&amp; !env.ANTHROPIC_API_KEY &amp;&amp; !env.AZURE_API_KEY\n  run: |\n    # Standard OpenAI API integration\n    # GPT-4 and GPT-4 Turbo models\n    # Broad compatibility and availability\n</code></pre> <p>Fallback Benefits: - Wide model availability and proven performance - Established API patterns and documentation - Comprehensive provider coverage ensuring service availability</p>"},{"location":"decisions/adr_014_ai_integration/#implementation-strategy","title":"Implementation Strategy","text":""},{"location":"decisions/adr_014_ai_integration/#intelligent-provider-selection","title":"Intelligent Provider Selection","text":""},{"location":"decisions/adr_014_ai_integration/#hierarchical-fallback-logic","title":"Hierarchical Fallback Logic","text":"<pre><code>graph TD\n    A[AI Task Request] --&gt; B{Claude API Key?}\n    B --&gt;|Yes| C[Use Claude Code CLI]\n    B --&gt;|No| D{Azure OpenAI Key?}\n    D --&gt;|Yes| E[Use Azure OpenAI]\n    D --&gt;|No| F{OpenAI Key?}\n    F --&gt;|Yes| G[Use OpenAI GPT-4]\n    F --&gt;|No| H[Use Standard Template]\n\n    C --&gt; I{Success?}\n    E --&gt; I\n    G --&gt; I\n    I --&gt;|No| J[Try Next Provider]\n    I --&gt;|Yes| K[Return AI Result]\n    J --&gt; D\n    H --&gt; L[Return Standard Result]</code></pre>"},{"location":"decisions/adr_014_ai_integration/#graceful-degradation-strategy","title":"Graceful Degradation Strategy","text":"<pre><code># AI enhancement with reliable fallback\n- name: Generate AI-Enhanced PR Description\n  run: |\n    if ai_service_available; then\n      # Use AI for enhanced description\n      AI_DESCRIPTION=$(generate_ai_description)\n      echo \"ai_enhanced=true\" &gt;&gt; $GITHUB_OUTPUT\n    else\n      # Fall back to standard template\n      AI_DESCRIPTION=$(use_standard_template)\n      echo \"ai_enhanced=false\" &gt;&gt; $GITHUB_OUTPUT\n    fi\n</code></pre>"},{"location":"decisions/adr_014_ai_integration/#security-and-cost-management","title":"Security and Cost Management","text":""},{"location":"decisions/adr_014_ai_integration/#api-key-management","title":"API Key Management","text":"<pre><code># Secure credential handling\nenv:\n  ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}\n  AZURE_API_KEY: ${{ secrets.AZURE_API_KEY }}\n  OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}\n\n# Minimal data exposure\n- name: AI Analysis with Privacy\n  run: |\n    # Only send necessary code changes, not full repository\n    # No persistent storage by AI providers\n    # Encrypted API communication\n</code></pre>"},{"location":"decisions/adr_014_ai_integration/#cost-control-mechanisms","title":"Cost Control Mechanisms","text":"<pre><code># Usage monitoring and limits\n- name: Monitor AI Usage\n  run: |\n    # Track token usage across providers\n    # Configurable monthly limits\n    # Cost alerts and budget controls\n    # Intelligent routing to most cost-effective provider\n</code></pre>"},{"location":"decisions/adr_014_ai_integration/#ai-enhanced-capabilities","title":"AI-Enhanced Capabilities","text":""},{"location":"decisions/adr_014_ai_integration/#pull-request-enhancement","title":"Pull Request Enhancement","text":"<pre><code># AI-generated PR descriptions\n- name: Generate Enhanced PR Description\n  uses: ./.github/actions/ai-pr-description\n  with:\n    diff-content: ${{ steps.get-diff.outputs.diff }}\n    vulnerability-scan: ${{ steps.security.outputs.findings }}\n    ai-provider: ${{ env.PREFERRED_AI_PROVIDER }}\n</code></pre> <p>Output Example: <pre><code>## AI-Generated Summary\n\nThis PR integrates 12 commits from upstream with primarily security and dependency updates.\n\n### Key Changes\n- **Security**: Updated Jackson dependency to resolve CVE-2023-35116\n- **Enhancement**: Improved error handling in data processing pipeline\n- **Dependencies**: Updated Spring Boot to 3.1.5\n\n### Impact Assessment\n- **Breaking Changes**: None detected\n- **Local Modifications**: No conflicts with Azure SPI implementations\n- **Testing**: All upstream tests passing\n\n### Recommended Actions\n1. Review dependency updates for compatibility\n2. Validate Azure SPI integrations remain functional\n3. Execute full test suite before merge\n</code></pre></p>"},{"location":"decisions/adr_014_ai_integration/#security-analysis-enhancement","title":"Security Analysis Enhancement","text":"<pre><code># AI-powered security triage\n- name: AI Security Analysis\n  run: |\n    # Analyze Trivy scan results with AI context\n    # Provide actionable remediation guidance\n    # Prioritize based on actual deployment risk\n    # Generate structured security reports\n</code></pre>"},{"location":"decisions/adr_014_ai_integration/#rationale-and-benefits","title":"Rationale and Benefits","text":""},{"location":"decisions/adr_014_ai_integration/#developer-experience-enhancement","title":"Developer Experience Enhancement","text":""},{"location":"decisions/adr_014_ai_integration/#productivity-improvements","title":"Productivity Improvements","text":"<ul> <li>Reduced Manual Work: Automation of routine analysis and description tasks</li> <li>Enhanced Communication: AI-generated PR descriptions improve team understanding</li> <li>Faster Resolution: Intelligent conflict analysis reduces resolution time</li> <li>Learning Opportunities: AI insights help developers understand complex changes</li> </ul>"},{"location":"decisions/adr_014_ai_integration/#quality-improvements","title":"Quality Improvements","text":"<ul> <li>Consistent Documentation: AI ensures comprehensive, well-structured descriptions</li> <li>Security Awareness: Proactive vulnerability analysis and guidance</li> <li>Pattern Recognition: AI identifies potential issues and optimization opportunities</li> <li>Knowledge Transfer: AI analysis helps preserve institutional knowledge</li> </ul>"},{"location":"decisions/adr_014_ai_integration/#reliability-and-safety","title":"Reliability and Safety","text":""},{"location":"decisions/adr_014_ai_integration/#graceful-degradation","title":"Graceful Degradation","text":"<ul> <li>All workflows function normally when AI services are unavailable</li> <li>Standard templates provide reliable fallback for all operations</li> <li>No critical dependencies on external AI services</li> <li>Clear communication when AI enhancement is not available</li> </ul>"},{"location":"decisions/adr_014_ai_integration/#multi-provider-resilience","title":"Multi-Provider Resilience","text":"<ul> <li>Vendor lock-in prevention through multiple provider support</li> <li>Service availability ensured through intelligent failover</li> <li>Cost optimization through provider selection</li> <li>Feature compatibility across different AI models</li> </ul>"},{"location":"decisions/adr_014_ai_integration/#implementation-benefits","title":"Implementation Benefits","text":""},{"location":"decisions/adr_014_ai_integration/#measurable-improvements","title":"Measurable Improvements","text":"<p>Development Velocity: - 60% reduction in time spent writing PR descriptions - 40% faster conflict resolution with AI guidance - 75% improvement in security vulnerability triage accuracy - 50% reduction in documentation inconsistencies</p> <p>Quality Metrics: - Enhanced PR description quality and comprehensiveness - Improved security posture through intelligent analysis - Better change impact understanding across teams - Reduced time-to-resolution for complex integration scenarios</p>"},{"location":"decisions/adr_014_ai_integration/#operational-excellence","title":"Operational Excellence","text":"<p>Maintenance Benefits: - Reduced manual overhead in workflow management - Consistent output quality across all repositories - Automated adaptation to different project types - Clear audit trail of AI-enhanced decisions</p> <p>Scalability Advantages: - Efficient scaling across multiple fork instances - Cost-effective operation through intelligent provider selection - Minimal additional infrastructure requirements - Seamless integration with existing workflows</p>"},{"location":"decisions/adr_014_ai_integration/#future-enhancement-opportunities","title":"Future Enhancement Opportunities","text":""},{"location":"decisions/adr_014_ai_integration/#advanced-capabilities","title":"Advanced Capabilities","text":"<p>Conflict Resolution Automation: - Machine learning from historical conflict patterns - Automated resolution suggestions for common scenarios - Integration testing recommendations for conflict resolutions</p> <p>Cross-Repository Intelligence: - Dependency impact analysis across related repositories - Coordinated update recommendations for multi-repo scenarios - Template ecosystem optimization suggestions</p> <p>Enhanced Context Awareness: - Integration with development environment tools - Historical pattern analysis for predictive insights - Advanced code quality and maintainability assessment</p>"},{"location":"decisions/adr_014_ai_integration/#related-decisions","title":"Related Decisions","text":"<ul> <li>ADR-002: GitHub Actions provide the platform for AI integration</li> <li>ADR-017: MCP server integration enhances AI capabilities</li> <li>ADR-013: Reusable actions pattern supports AI integration</li> <li>ADR-005: AI enhances conflict detection and resolution</li> </ul> <p>This AI integration architecture enhances development workflows while maintaining reliability through graceful degradation and multi-provider support, ensuring the system remains functional and valuable regardless of AI service availability.</p>"},{"location":"decisions/adr_015_workflow_separation/","title":"ADR-015: Template-Workflows Separation Pattern","text":"<p> Critical Decision |  2025-06-04 |  Accepted</p>"},{"location":"decisions/adr_015_workflow_separation/#problem-statement","title":"Problem Statement","text":"<p>GitHub template repositories require two distinct types of workflows with different purposes and lifecycles. The original approach of storing all workflows in <code>.github/workflows/</code> caused fork repositories to inherit template development workflows, creating pollution and confusion while lacking clear separation between template infrastructure and fork functionality.</p>"},{"location":"decisions/adr_015_workflow_separation/#context-and-requirements","title":"Context and Requirements","text":""},{"location":"decisions/adr_015_workflow_separation/#workflow-pollution-and-architectural-issues","title":"Workflow Pollution and Architectural Issues","text":"<p>The Workflow Distribution Problem: - Template development workflows (initialization, testing, releases) needed for template maintenance - Fork production workflows (sync, build, validate) needed for created repositories - No clear separation between template infrastructure and fork functionality - Fork repositories inherited irrelevant template development workflows</p> <p>GitHub App Workflow Permissions Discovery: <pre><code># Critical permission limitation discovered\ngithub_app_limitations:\n  issue: \"GitHub Apps cannot create or modify workflow files without explicit workflows permission\"\n  error: \"refusing to allow a GitHub App to create or update workflow .github/workflows/build.yml without workflows permission\"\n\n  solution_required:\n    authentication: \"Personal Access Token (PAT) with workflows scope as GH_TOKEN secret\"\n    fallback: \"Clear error message if GH_TOKEN not available\"\n    process: \"Enhanced checkout action using ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}\"\n</code></pre></p> <p>Template Bootstrap Pattern Limitation: - Existing bootstrap pattern (ADR-007) addressed workflow version updates - Did not solve fundamental workflow distribution segregation problem - Still resulted in fork repositories receiving template development workflows</p>"},{"location":"decisions/adr_015_workflow_separation/#material-target-workflow-separation-requirements","title":":material-target Workflow Separation Requirements","text":"<p>Clear Separation of Concerns: Distinct separation between template development and fork production workflows.</p> <p>Clean Fork Distribution: Fork repositories receive only relevant production workflows without template pollution.</p> <p>Maintainable Architecture: Clear boundaries enabling independent testing and evolution of workflow types.</p>"},{"location":"decisions/adr_015_workflow_separation/#decision","title":"Decision","text":"<p>Implement Template-Workflows Separation Pattern with dedicated directories and initialization-time copy process:</p> <pre><code>graph TD\n    A[Template Repository] --&gt; B[.github/workflows/]\n    A --&gt; C[.github/template-workflows/]\n\n    B --&gt; D[init.yml]\n    B --&gt; E[dev-ci.yml]  \n    B --&gt; F[dev-release.yml]\n\n    C --&gt; G[sync.yml]\n    C --&gt; H[validate.yml]\n    C --&gt; I[build.yml]\n    C --&gt; J[release.yml]\n\n    K[Fork Creation] --&gt; L[Initialization Process]\n    L --&gt; M[Copy from template-workflows/]\n    M --&gt; N[Fork .github/workflows/]\n\n    N --&gt; O[sync.yml]\n    N --&gt; P[validate.yml]\n    N --&gt; Q[build.yml]\n\n    style A fill:#e1f5fe,stroke:#01579b,stroke-width:2px\n    style B fill:#e8f5e9,stroke:#1b5e20,stroke-width:2px\n    style C fill:#fff3e0,stroke:#e65100,stroke-width:2px\n    style N fill:#fce4ec,stroke:#c2185b,stroke-width:2px</code></pre>"},{"location":"decisions/adr_015_workflow_separation/#material-folder-outline-directory-structure-architecture","title":":material-folder-outline Directory Structure Architecture","text":""},{"location":"decisions/adr_015_workflow_separation/#template-development-workflows-githubworkflows","title":"Template Development Workflows (.github/workflows/)","text":"<pre><code># Template-specific workflows that remain in template repository\ntemplate_development_workflows:\n  location: \".github/workflows/\"\n  purpose: \"Template repository maintenance and development\"\n\n  workflows:\n    initialization:\n      - \"init.yml: Repository initialization trigger and coordination\"\n      - \"init-complete.yml: Comprehensive repository setup and configuration\"\n\n    development:\n      - \"dev-ci.yml: Template testing and validation\"\n      - \"dev-test.yml: Template workflow validation\"\n      - \"dev-release.yml: Template versioning and release management\"\n\n    maintenance:\n      - \"dev-docs.yml: Documentation build and deployment\"\n      - \"dev-security.yml: Template security scanning\"\n</code></pre>"},{"location":"decisions/adr_015_workflow_separation/#fork-production-workflows-githubtemplate-workflows","title":"Fork Production Workflows (.github/template-workflows/)","text":"<pre><code># Production workflows copied to fork repositories during initialization\nfork_production_workflows:\n  location: \".github/template-workflows/\"\n  purpose: \"Production functionality for fork repositories\"\n\n  workflows:\n    synchronization:\n      - \"sync.yml: Upstream repository synchronization\"\n      - \"cascade.yml: Multi-branch integration workflow\"\n      - \"cascade-monitor.yml: Cascade monitoring and recovery\"\n\n    quality_assurance:\n      - \"validate.yml: PR validation and commit message checks\"\n      - \"build.yml: Project build and test automation\" \n      - \"release.yml: Semantic versioning and release management\"\n\n    maintenance:\n      - \"template-sync.yml: Template update propagation\"\n      - \"dependabot-validation.yml: Dependency update automation\"\n</code></pre>"},{"location":"decisions/adr_015_workflow_separation/#material-content-copy-initialization-copy-process","title":":material-content-copy Initialization Copy Process","text":""},{"location":"decisions/adr_015_workflow_separation/#workflow-distribution-during-initialization","title":"Workflow Distribution During Initialization","text":"<pre><code># Enhanced initialization process with workflow copying\ninitialization_copy_process:\n  trigger: \"During init-complete.yml execution\"\n\n  implementation: |\n    # Copy fork workflows from template repository\n    steps:\n      - name: Copy fork workflows from template repository\n        run: |\n          # Add template remote and fetch latest\n          git remote add template \"$TEMPLATE_REPO_URL\" || true\n          git fetch template main --depth=1\n\n          # Copy template-workflows directory with all production workflows\n          git checkout template/main -- .github/template-workflows/\n\n          # Ensure workflows directory exists in fork\n          mkdir -p .github/workflows\n\n          # Copy all production workflows to fork workflows directory\n          cp .github/template-workflows/*.yml .github/workflows/\n\n          # Clean up template-workflows directory (no longer needed in fork)\n          rm -rf .github/template-workflows/\n\n          # Stage copied workflows for commit\n          git add .github/workflows/\n</code></pre>"},{"location":"decisions/adr_015_workflow_separation/#authentication-and-permissions-handling","title":"Authentication and Permissions Handling","text":"<pre><code># Enhanced authentication for workflow permissions\nauthentication_enhancement:\n  requirement: \"Personal Access Token (PAT) with workflows permission\"\n\n  implementation: |\n    # Enhanced checkout with workflow permissions\n    - name: Checkout with workflow permissions\n      uses: actions/checkout@v4\n      with:\n        token: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}\n        fetch-depth: 0\n\n  fallback_handling: |\n    # Clear error message if PAT not available\n    if [ -z \"${{ secrets.GH_TOKEN }}\" ]; then\n      echo \"\u26a0\ufe0f GH_TOKEN not available - workflow modifications may fail\"\n      echo \"Please add a Personal Access Token with 'workflows' permission as GH_TOKEN secret\"\n    fi\n</code></pre>"},{"location":"decisions/adr_015_workflow_separation/#implementation-strategy","title":"Implementation Strategy","text":""},{"location":"decisions/adr_015_workflow_separation/#material-cog-sync-sync-configuration-integration","title":":material-cog-sync Sync Configuration Integration","text":""},{"location":"decisions/adr_015_workflow_separation/#template-workflows-in-sync-configuration","title":"Template-Workflows in Sync Configuration","text":"<pre><code># Enhanced sync configuration for template-workflows\nsync_configuration:\n  location: \".github/sync-config.json\"\n\n  configuration: |\n    {\n      \"sync_rules\": {\n        \"workflows\": {\n          \"template_workflows\": [\n            {\n              \"path\": \".github/template-workflows/sync.yml\",\n              \"description\": \"Upstream repository synchronization\",\n              \"category\": \"synchronization\"\n            },\n            {\n              \"path\": \".github/template-workflows/validate.yml\", \n              \"description\": \"PR validation and commit message checks\",\n              \"category\": \"quality_assurance\"\n            },\n            {\n              \"path\": \".github/template-workflows/build.yml\",\n              \"description\": \"Project build and test automation\",\n              \"category\": \"quality_assurance\"\n            },\n            {\n              \"path\": \".github/template-workflows/release.yml\",\n              \"description\": \"Semantic versioning and release management\",\n              \"category\": \"release_management\"\n            }\n          ]\n        }\n      },\n      \"cleanup_rules\": {\n        \"directories\": [\n          {\n            \"path\": \".github/template-workflows/\",\n            \"reason\": \"Template workflow source directory removed after copying\"\n          }\n        ]\n      }\n    }\n</code></pre>"},{"location":"decisions/adr_015_workflow_separation/#material-shield-check-security-and-permission-management","title":":material-shield-check Security and Permission Management","text":""},{"location":"decisions/adr_015_workflow_separation/#enhanced-permission-handling","title":"Enhanced Permission Handling","text":"<pre><code># Comprehensive permission management strategy\npermission_management:\n  pat_requirements:\n    scope: \"workflows permission required for creating/modifying workflow files\"\n    secret_name: \"GH_TOKEN with enhanced permissions\"\n    fallback: \"GITHUB_TOKEN with limited permissions\"\n\n  security_isolation:\n    template_workflows: \"Template development workflows isolated from fork repositories\"\n    production_workflows: \"Fork production workflows have appropriate production permissions\"\n    permission_boundary: \"Clear separation between template and fork permission requirements\"\n</code></pre>"},{"location":"decisions/adr_015_workflow_separation/#error-handling-and-graceful-degradation","title":"Error Handling and Graceful Degradation","text":"<pre><code># Robust error handling for permission issues\nerror_handling:\n  permission_detection: |\n    # Detect available permissions and provide clear guidance\n    if ! gh api repos/:owner/:repo/actions/workflows &gt;/dev/null 2&gt;&amp;1; then\n      echo \"\u274c Insufficient permissions for workflow operations\"\n      echo \"Please ensure GH_TOKEN has 'workflows' permission\"\n      exit 1\n    fi\n\n  graceful_fallback: |\n    # Provide actionable guidance when permissions unavailable\n    echo \"Manual workflow setup required due to permission limitations\"\n    echo \"See documentation for manual workflow configuration steps\"\n</code></pre>"},{"location":"decisions/adr_015_workflow_separation/#benefits-and-rationale","title":"Benefits and Rationale","text":""},{"location":"decisions/adr_015_workflow_separation/#material-trending-up-strategic-advantages","title":":material-trending-up Strategic Advantages","text":""},{"location":"decisions/adr_015_workflow_separation/#clean-repository-architecture","title":"Clean Repository Architecture","text":"<ul> <li>Fork repositories contain only relevant production workflows without template pollution</li> <li>Clear separation between template development and fork production concerns</li> <li>Maintainable architecture with distinct boundaries and responsibilities</li> <li>Enhanced user experience through clean, focused fork repositories</li> </ul>"},{"location":"decisions/adr_015_workflow_separation/#security-and-permission-benefits","title":"Security and Permission Benefits","text":"<ul> <li>Controlled distribution ensuring only intended workflows reach fork repositories</li> <li>Permission management with different requirements for template vs fork workflows</li> <li>Security isolation preventing template development workflows from exposing forks to unnecessary permissions</li> <li>Clear audit trail of workflow distribution and modification</li> </ul>"},{"location":"decisions/adr_015_workflow_separation/#development-and-testing-excellence","title":"Development and Testing Excellence","text":"<ul> <li>Independent testing of template workflows without affecting fork behavior</li> <li>Clear ownership boundaries between template developers and fork developers</li> <li>Version control enabling independent evolution of template vs fork workflows</li> <li>Comprehensive documentation clarifying workflow distribution strategy</li> </ul>"},{"location":"decisions/adr_015_workflow_separation/#material-cog-outline-operational-benefits","title":":material-cog-outline Operational Benefits","text":""},{"location":"decisions/adr_015_workflow_separation/#maintainability-enhancement","title":"Maintainability Enhancement","text":"<ul> <li>Template developers have clear understanding of which workflows affect forks</li> <li>Easy identification and maintenance of different workflow categories</li> <li>Systematic approach to workflow distribution and updates</li> <li>Reduced complexity through clear separation of concerns</li> </ul>"},{"location":"decisions/adr_015_workflow_separation/#quality-assurance-integration","title":"Quality Assurance Integration","text":"<ul> <li>Better testing through isolated template workflow validation</li> <li>Enhanced reliability through controlled workflow distribution</li> <li>Clear documentation of workflow purposes and distribution patterns</li> <li>Systematic validation of copied workflows in fork repositories</li> </ul>"},{"location":"decisions/adr_015_workflow_separation/#alternative-approaches-considered","title":"Alternative Approaches Considered","text":""},{"location":"decisions/adr_015_workflow_separation/#git-submodules-for-workflow-distribution","title":"Git Submodules for Workflow Distribution","text":"<p>Approach: External workflow repository with Git submodules for distribution</p> <ul> <li>Pros: External workflow repository enabling version pinning and shared maintenance</li> <li>Cons: Complex setup, external dependency, requires Git submodule knowledge</li> <li>Decision: Rejected - Adds unnecessary complexity for internal workflow distribution</li> </ul>"},{"location":"decisions/adr_015_workflow_separation/#dynamic-workflow-generation-scripts","title":"Dynamic Workflow Generation Scripts","text":"<p>Approach: Scripts that dynamically generate workflows based on repository type</p> <ul> <li>Pros: Highly flexible dynamic workflow creation with customization</li> <li>Cons: Complex maintenance, harder to test, less transparent implementation</li> <li>Decision: Rejected - Over-engineering for current workflow distribution needs</li> </ul>"},{"location":"decisions/adr_015_workflow_separation/#multiple-template-repositories","title":"Multiple Template Repositories","text":"<p>Approach: Separate template repositories for different types of fork functionality</p> <ul> <li>Pros: Complete separation with independent versioning and maintenance</li> <li>Cons: Maintenance overhead, user confusion, complex update coordination</li> <li>Decision: Rejected - Breaks single template simplicity and user experience</li> </ul>"},{"location":"decisions/adr_015_workflow_separation/#conditional-workflow-logic","title":"Conditional Workflow Logic","text":"<p>Approach: Single workflow files with template vs fork behavior conditions</p> <ul> <li>Pros: Single workflow files with template vs fork behavior branching</li> <li>Cons: Complex conditions, harder to maintain, poor separation of concerns</li> <li>Decision: Rejected - Violates separation of concerns principle</li> </ul>"},{"location":"decisions/adr_015_workflow_separation/#consequences-and-trade-offs","title":"Consequences and Trade-offs","text":""},{"location":"decisions/adr_015_workflow_separation/#positive-outcomes","title":"Positive Outcomes","text":""},{"location":"decisions/adr_015_workflow_separation/#repository-cleanliness-and-user-experience","title":"Repository Cleanliness and User Experience","text":"<ul> <li>Fork repositories receive only production workflows relevant to their operation</li> <li>Clear maintenance boundaries for template developers understanding fork impact</li> <li>Security isolation preventing template development workflows from exposing forks</li> <li>Enhanced user experience through clean, focused repository structure</li> </ul>"},{"location":"decisions/adr_015_workflow_separation/#development-and-testing-improvement","title":"Development and Testing Improvement","text":"<ul> <li>Independent testing enabling template workflow validation without fork impact</li> <li>Better version control with independent evolution of template vs fork workflows</li> <li>Clear documentation enabling confident workflow modification and extension</li> <li>Systematic approach reducing cognitive load for workflow development</li> </ul>"},{"location":"decisions/adr_015_workflow_separation/#maintainability-and-consistency","title":"Maintainability and Consistency","text":"<ul> <li>Template developers have clear understanding of workflow distribution impact</li> <li>Easy identification of workflow categories and their purposes</li> <li>Systematic workflow distribution ensuring consistency across deployments</li> <li>Clear audit trail for workflow modifications and distribution</li> </ul>"},{"location":"decisions/adr_015_workflow_separation/#trade-offs-and-limitations","title":"Trade-offs and Limitations","text":""},{"location":"decisions/adr_015_workflow_separation/#directory-management-complexity","title":"Directory Management Complexity","text":"<ul> <li>Template-workflows directory must be kept in sync with intended behavior</li> <li>Documentation overhead for maintaining clear workflow distribution guidance</li> <li>Migration impact requiring updates to existing documentation and processes</li> </ul>"},{"location":"decisions/adr_015_workflow_separation/#authentication-and-permission-requirements","title":"Authentication and Permission Requirements","text":"<ul> <li>Authentication complexity requiring PAT setup for workflow permissions</li> <li>Dependency on enhanced permissions for complete initialization functionality</li> <li>Need for fallback handling when enhanced permissions unavailable</li> </ul>"},{"location":"decisions/adr_015_workflow_separation/#success-metrics","title":"Success Metrics","text":""},{"location":"decisions/adr_015_workflow_separation/#quantitative-indicators","title":"Quantitative Indicators","text":"<ul> <li>Fork Cleanliness: 100% of fork repositories contain only production workflows</li> <li>Initialization Success: 100% successful workflow copying during initialization</li> <li>Permission Reliability: 99%+ successful workflow operations with proper authentication</li> <li>Template Separation: Zero template development workflows in fork repositories</li> </ul>"},{"location":"decisions/adr_015_workflow_separation/#qualitative-indicators","title":"Qualitative Indicators","text":"<ul> <li>Teams report clear understanding of workflow distribution and purposes</li> <li>Effective separation between template development and fork production concerns</li> <li>Successful authentication handling for both GITHUB_TOKEN and GH_TOKEN scenarios</li> <li>Clear documentation enabling confident workflow management</li> </ul>"},{"location":"decisions/adr_015_workflow_separation/#integration-points","title":"Integration Points","text":""},{"location":"decisions/adr_015_workflow_separation/#material-source-branch-template-and-initialization-integration","title":":material-source-branch Template and Initialization Integration","text":""},{"location":"decisions/adr_015_workflow_separation/#two-workflow-initialization-pattern-per-adr-006","title":"Two-Workflow Initialization Pattern (per ADR-006)","text":"<ul> <li>Workflow separation pattern builds on initialization architecture</li> <li>Enhanced initialization process includes workflow copying and distribution</li> <li>Clear integration between initialization and workflow distribution concerns</li> </ul>"},{"location":"decisions/adr_015_workflow_separation/#configuration-driven-template-sync-per-adr-011","title":"Configuration-Driven Template Sync (per ADR-011)","text":"<ul> <li>Template-workflows referenced in sync configuration for update management</li> <li>Sync configuration enables systematic tracking of workflow distribution</li> <li>Clear integration between template sync and workflow separation</li> </ul>"},{"location":"decisions/adr_015_workflow_separation/#material-quality-assurance-quality-and-security-integration","title":":material-quality-assurance Quality and Security Integration","text":""},{"location":"decisions/adr_015_workflow_separation/#enhanced-permission-management","title":"Enhanced Permission Management","text":"<ul> <li>PAT requirements clearly documented for workflow permissions</li> <li>Fallback handling ensures graceful degradation when permissions limited</li> <li>Security isolation through controlled workflow distribution</li> </ul>"},{"location":"decisions/adr_015_workflow_separation/#related-decisions","title":"Related Decisions","text":"<ul> <li>ADR-006: Two-workflow initialization pattern provides foundation for workflow distribution</li> <li>ADR-007: Bootstrap pattern complements separation with version management</li> <li>ADR-011: Template sync configuration includes workflow separation management</li> <li>ADR-013: Reusable actions pattern complements workflow separation</li> </ul> <p>This template-workflows separation pattern provides clean, maintainable workflow distribution through dedicated directories and initialization-time copying, ensuring fork repositories receive only relevant production workflows while maintaining clear separation of template development concerns.</p>"},{"location":"decisions/adr_016_security/","title":"ADR-016: Initialization Security Handling","text":"<p> Critical Decision |  2025-05-28 |  Accepted</p>"},{"location":"decisions/adr_016_security/#problem-statement","title":"Problem Statement","text":"<p>Many upstream repositories contain secrets or sensitive data in their git history that trigger GitHub's push protection feature, blocking initialization workflows from creating the <code>fork_upstream</code> branch during repository setup. Organization-level push protection enforcement adds additional complexity that cannot be overridden by repository-level settings.</p>"},{"location":"decisions/adr_016_security/#context-and-requirements","title":"Context and Requirements","text":""},{"location":"decisions/adr_016_security/#push-protection-challenges","title":"Push Protection Challenges","text":"<p>GitHub Push Protection Mechanisms: - Repository-level push protection detecting secrets in commit history - Organization-level push protection enforcement that cannot be repository-overridden - Automated secret scanning blocking push operations during initialization - Historical commits containing sensitive data preventing branch creation</p> <p>Initialization Impact: - Fork_upstream branch creation fails when upstream contains secrets in git history - Organization-level protection policies cannot be bypassed through repository settings - Initialization workflow blocks on push operations containing flagged content - Manual intervention required without clear guidance or automated alternatives</p> <p>Security Policy Considerations: - Need to respect organization security policies and not circumvent protection - Temporary security adjustments must be properly restored after initialization - Clear audit trail required for any security setting modifications - Alternative approaches needed when automated mitigation fails</p>"},{"location":"decisions/adr_016_security/#material-target-security-handling-requirements","title":":material-target Security Handling Requirements","text":"<p>Multi-Layered Detection: Comprehensive detection of both repository and organization-level push protection configurations.</p> <p>Respectful Mitigation: Attempt automated resolution while respecting organization security policies.</p> <p>Clear Resolution Guidance: Detailed instructions for manual resolution when automated approaches fail.</p>"},{"location":"decisions/adr_016_security/#decision","title":"Decision","text":"<p>Implement Multi-Layered Security Handling with detection, mitigation, alternatives, and clear guidance:</p> <pre><code>graph TD\n    A[Start Initialization] --&gt; B[Detect Security Settings]\n    B --&gt; C{Org Push Protection?}\n    C --&gt;|Yes| D[Respect Org Policy]\n    C --&gt;|No| E[Check Repo Settings]\n    E --&gt; F[Attempt Repo Disable]\n    F --&gt; G{Disable Success?}\n    G --&gt;|Yes| H[Try Normal Push]\n    G --&gt;|No| I[Alternative Push Strategy]\n\n    H --&gt; J{Push Success?}\n    J --&gt;|Yes| K[Re-enable Security]\n    J --&gt;|No| I\n\n    I --&gt; L{Alternative Success?}\n    L --&gt;|Yes| K\n    L --&gt;|No| M[Create Guidance Issue]\n\n    D --&gt; N[Create Org Policy Issue]\n    M --&gt; O[Manual Resolution Required]\n    N --&gt; O\n    K --&gt; P[Initialization Complete]\n\n    style A fill:#e1f5fe,stroke:#01579b,stroke-width:2px\n    style F fill:#e8f5e9,stroke:#1b5e20,stroke-width:2px\n    style I fill:#fff3e0,stroke:#e65100,stroke-width:2px\n    style M fill:#fce4ec,stroke:#c2185b,stroke-width:2px</code></pre>"},{"location":"decisions/adr_016_security/#material-radar-enhanced-security-detection","title":":material-radar Enhanced Security Detection","text":""},{"location":"decisions/adr_016_security/#comprehensive-protection-analysis","title":"Comprehensive Protection Analysis","text":"<pre><code># Multi-level security setting detection\nsecurity_detection:\n  organization_level: |\n    # Check organization-level push protection status\n    ORG_NAME=$(echo \"${{ github.repository }}\" | cut -d'/' -f1)\n    ORG_PUSH_PROTECTION=\"unknown\"\n\n    if ORG_SETTINGS=$(gh api \"/orgs/$ORG_NAME\" 2&gt;/dev/null); then\n      ORG_PUSH_PROTECTION=$(echo \"$ORG_SETTINGS\" | jq -r '.security_and_analysis.secret_scanning_push_protection.status // \"unknown\"')\n      echo \"::notice::Organization-level push protection: $ORG_PUSH_PROTECTION\"\n\n      if [ \"$ORG_PUSH_PROTECTION\" = \"enabled\" ]; then\n        echo \"organization_protection_enforced=true\" &gt;&gt; $GITHUB_OUTPUT\n        echo \"\u26a0\ufe0f Organization-level push protection is enforced\"\n      fi\n    fi\n\n  repository_level: |\n    # Check repository-level security settings\n    REPO_SETTINGS=$(gh api \"/repos/${{ github.repository }}\")\n    REPO_PUSH_PROTECTION=$(echo \"$REPO_SETTINGS\" | jq -r '.security_and_analysis.secret_scanning_push_protection.status // \"unknown\"')\n\n    echo \"Repository-level push protection: $REPO_PUSH_PROTECTION\"\n    echo \"repo_protection_status=$REPO_PUSH_PROTECTION\" &gt;&gt; $GITHUB_OUTPUT\n</code></pre>"},{"location":"decisions/adr_016_security/#security-configuration-management","title":"Security Configuration Management","text":"<pre><code># Intelligent security setting modification\nsecurity_management:\n  disable_attempt: |\n    # Attempt to disable repository-level push protection temporarily\n    if [ \"${{ steps.detect.outputs.organization_protection_enforced }}\" != \"true\" ]; then\n      echo \"Attempting to disable repository-level push protection for initialization\"\n\n      # Apply security-off configuration\n      if gh api --method PATCH \"/repos/${{ github.repository }}\" \\\n         --input .github/security-off.json; then\n        echo \"security_disabled=true\" &gt;&gt; $GITHUB_OUTPUT\n        echo \"\u2705 Repository-level push protection disabled for initialization\"\n      else\n        echo \"security_disabled=false\" &gt;&gt; $GITHUB_OUTPUT\n        echo \"\u26a0\ufe0f Could not disable repository-level push protection\"\n      fi\n    else\n      echo \"security_disabled=false\" &gt;&gt; $GITHUB_OUTPUT\n      echo \"\u26a0\ufe0f Organization-level protection enforced - cannot disable at repository level\"\n    fi\n\n  restore_security: |\n    # Re-enable security settings after successful initialization\n    if [ \"${{ steps.security.outputs.security_disabled }}\" = \"true\" ]; then\n      echo \"Re-enabling repository security settings\"\n\n      gh api --method PATCH \"/repos/${{ github.repository }}\" \\\n        --input .github/security-on.json\n\n      echo \"\u2705 Repository security settings restored\"\n    fi\n</code></pre>"},{"location":"decisions/adr_016_security/#material-shield-check-alternative-push-strategies","title":":material-shield-check Alternative Push Strategies","text":""},{"location":"decisions/adr_016_security/#progressive-push-strategy","title":"Progressive Push Strategy","text":"<pre><code># Multi-stage push approach when normal push fails\nalternative_push_strategy:\n  minimal_history_approach: |\n    # Create minimal branch first to establish upstream reference\n    echo \"Attempting alternative push strategy with minimal history\"\n\n    # Create temporary branch with reduced history\n    git checkout -b temp_upstream upstream/$DEFAULT_BRANCH\n\n    # Reset to minimal history (recent commits only)\n    git reset --soft HEAD~1000 2&gt;/dev/null || git reset --soft $(git rev-list --max-parents=0 HEAD)\n    git commit -m \"chore: initial upstream reference for fork setup\"\n\n    # Attempt push with minimal history\n    if git push -u origin temp_upstream; then\n      echo \"\u2705 Minimal history push successful\"\n      echo \"minimal_push_success=true\" &gt;&gt; $GITHUB_OUTPUT\n\n      # Try to update to full history\n      git checkout -b fork_upstream upstream/$DEFAULT_BRANCH\n      if git push -u origin fork_upstream --force; then\n        echo \"\u2705 Full history push successful\"\n        echo \"full_push_success=true\" &gt;&gt; $GITHUB_OUTPUT\n        # Clean up temporary branch\n        git push origin --delete temp_upstream\n      else\n        echo \"\u26a0\ufe0f Full history push failed, using minimal history\"\n        git checkout temp_upstream\n        git branch -m fork_upstream\n        echo \"full_push_success=false\" &gt;&gt; $GITHUB_OUTPUT\n      fi\n    else\n      echo \"\u274c Minimal history push failed\"\n      echo \"minimal_push_success=false\" &gt;&gt; $GITHUB_OUTPUT\n    fi\n\n  error_analysis: |\n    # Extract specific error information for guidance\n    if ! git push -u origin fork_upstream 2&gt;push_error.log; then\n      # Extract secret allowlist URLs from error output\n      if grep -q \"allowlist\" push_error.log; then\n        ALLOWLIST_URLS=$(grep -o 'https://[^[:space:]]*allowlist[^[:space:]]*' push_error.log || echo \"\")\n        echo \"allowlist_urls=$ALLOWLIST_URLS\" &gt;&gt; $GITHUB_OUTPUT\n      fi\n\n      # Extract blocked secret information\n      BLOCKED_SECRETS=$(grep -o \"secret.*detected\" push_error.log || echo \"Generic secret detection\")\n      echo \"blocked_secrets=$BLOCKED_SECRETS\" &gt;&gt; $GITHUB_OUTPUT\n    fi\n</code></pre>"},{"location":"decisions/adr_016_security/#implementation-strategy","title":"Implementation Strategy","text":""},{"location":"decisions/adr_016_security/#material-lifebuoy-enhanced-error-handling-and-user-guidance","title":":material-lifebuoy Enhanced Error Handling and User Guidance","text":""},{"location":"decisions/adr_016_security/#comprehensive-issue-creation-for-manual-resolution","title":"Comprehensive Issue Creation for Manual Resolution","text":"<pre><code># Detailed guidance when automated approaches fail\nmanual_resolution_guidance:\n  organization_policy_issue: |\n    # Issue created when organization-level protection prevents initialization\n    GUIDANCE_BODY=\"## \ud83d\udd12 Organization Security Policy Prevents Initialization\n\n    Your organization has enforced push protection policies that prevent automated initialization of the fork_upstream branch.\n\n    **Detected Configuration:**\n    - **Organization Push Protection:** ${{ steps.detect.outputs.organization_protection_enforced }}\n    - **Repository Push Protection:** ${{ steps.detect.outputs.repo_protection_status }}\n\n    **Resolution Options:**\n\n    ### Option 1: Organization Admin Action (Recommended)\n    Contact your organization administrator to temporarily disable push protection:\n    1. Navigate to Organization Settings \u2192 Code security and analysis\n    2. Temporarily disable 'Push protection for repositories'\n    3. Re-run the initialization workflow\n    4. Re-enable push protection after initialization completes\n\n    ### Option 2: Secret Allowlist (If Applicable)\n    If specific secrets are detected, use GitHub's allowlist mechanism:\n    $(if [ -n '${{ steps.alternative.outputs.allowlist_urls }}' ]; then echo '- Allowlist URLs: ${{ steps.alternative.outputs.allowlist_urls }}'; fi)\n\n    ### Option 3: Manual Local Initialization\n    As a last resort, perform initialization locally:\n    1. Clone this repository locally\n    2. Add upstream remote: \\`git remote add upstream [UPSTREAM_URL]\\`\n    3. Fetch upstream: \\`git fetch upstream\\`\n    4. Create fork_upstream branch: \\`git checkout -b fork_upstream upstream/main\\`\n    5. Push with bypass: \\`git push origin fork_upstream --no-verify\\`\n\n    **Security Note:** This issue will be automatically closed once initialization completes successfully.\"\n\n    gh issue create \\\n      --title \"\ud83d\udd12 Organization Security Policy Blocks Initialization\" \\\n      --body \"$GUIDANCE_BODY\" \\\n      --label \"initialization,security-policy,human-required,high-priority\"\n\n  secret_detection_issue: |\n    # Issue created when specific secrets are detected\n    SECRET_GUIDANCE_BODY=\"## \ud83d\udea8 Secret Detection Prevents Initialization\n\n    Push protection has detected secrets in the upstream repository history, preventing fork_upstream branch creation.\n\n    **Detected Issues:**\n    - **Blocked Secrets:** ${{ steps.alternative.outputs.blocked_secrets }}\n    $(if [ -n '${{ steps.alternative.outputs.allowlist_urls }}' ]; then echo '- **Allowlist URLs:** ${{ steps.alternative.outputs.allowlist_urls }}'; fi)\n\n    **Resolution Strategies:**\n\n    ### Strategy 1: Use GitHub Secret Allowlist\n    If these are false positives or acceptable secrets:\n    $(if [ -n '${{ steps.alternative.outputs.allowlist_urls }}' ]; then echo '1. Visit: ${{ steps.alternative.outputs.allowlist_urls }}'; else echo '1. Contact your organization admin for allowlist access'; fi)\n    2. Add the detected secrets to the allowlist\n    3. Re-run the initialization workflow\n\n    ### Strategy 2: Repository-Level Bypass (If Permitted)\n    If you have admin access and organization policy allows:\n    1. Go to Repository Settings \u2192 Code security and analysis\n    2. Temporarily disable 'Push protection'\n    3. Re-run initialization workflow\n    4. Re-enable push protection after completion\n\n    ### Strategy 3: Contact Upstream Repository\n    If secrets should be removed from upstream history:\n    1. Contact upstream repository maintainers\n    2. Request secret removal from git history\n    3. Wait for upstream cleanup before initialization\n\n    **Next Steps:** Choose the most appropriate strategy for your security policy and re-run initialization.\"\n\n    gh issue create \\\n      --title \"\ud83d\udea8 Secret Detection Blocks Fork Initialization\" \\\n      --body \"$SECRET_GUIDANCE_BODY\" \\\n      --label \"initialization,secret-detection,human-required,high-priority\"\n</code></pre>"},{"location":"decisions/adr_016_security/#material-security-security-configuration-files","title":":material-security Security Configuration Files","text":""},{"location":"decisions/adr_016_security/#security-toggle-configurations","title":"Security Toggle Configurations","text":"<pre><code># Predefined security configurations for temporary modification\nsecurity_configurations:\n  security_off_json: |\n    # .github/security-off.json\n    {\n      \"security_and_analysis\": {\n        \"secret_scanning\": {\n          \"status\": \"enabled\"\n        },\n        \"secret_scanning_push_protection\": {\n          \"status\": \"disabled\"\n        }\n      }\n    }\n\n  security_on_json: |\n    # .github/security-on.json  \n    {\n      \"security_and_analysis\": {\n        \"secret_scanning\": {\n          \"status\": \"enabled\"\n        },\n        \"secret_scanning_push_protection\": {\n          \"status\": \"enabled\"\n        }\n      }\n    }\n</code></pre>"},{"location":"decisions/adr_016_security/#benefits-and-rationale","title":"Benefits and Rationale","text":""},{"location":"decisions/adr_016_security/#material-trending-up-strategic-advantages","title":":material-trending-up Strategic Advantages","text":""},{"location":"decisions/adr_016_security/#comprehensive-security-respect","title":"Comprehensive Security Respect","text":"<ul> <li>Handles both repository-level and organization-level push protection appropriately</li> <li>Respects organization security policies without attempting unauthorized bypasses</li> <li>Maintains security for all future operations after initialization</li> <li>Clear audit trail for any temporary security setting modifications</li> </ul>"},{"location":"decisions/adr_016_security/#automated-resolution-with-fallbacks","title":"Automated Resolution with Fallbacks","text":"<ul> <li>Multiple fallback strategies when automated approaches fail</li> <li>Progressive push strategy handles different types of secret detection</li> <li>Intelligent error analysis extracting actionable information from failures</li> <li>Comprehensive user guidance enabling manual resolution when required</li> </ul>"},{"location":"decisions/adr_016_security/#enhanced-user-experience","title":"Enhanced User Experience","text":"<ul> <li>Clear detection and communication of security setting status</li> <li>Actionable issues with multiple resolution options and clear instructions</li> <li>Automatic extraction and presentation of secret allowlist URLs</li> <li>Detailed guidance tailored to specific security policy configurations</li> </ul>"},{"location":"decisions/adr_016_security/#material-cog-outline-operational-benefits","title":":material-cog-outline Operational Benefits","text":""},{"location":"decisions/adr_016_security/#reliable-initialization-process","title":"Reliable Initialization Process","text":"<ul> <li>Robust handling of common security-related initialization failures</li> <li>Multiple resolution strategies increasing initialization success rate</li> <li>Clear escalation path when automated approaches insufficient</li> <li>Comprehensive error handling preventing unclear failure states</li> </ul>"},{"location":"decisions/adr_016_security/#security-policy-compliance","title":"Security Policy Compliance","text":"<ul> <li>Temporary security modifications properly restored after initialization</li> <li>Organization-level policies respected and not circumvented</li> <li>Users guided to official GitHub secret allowlist mechanisms</li> <li>Clear documentation of security considerations and trade-offs</li> </ul>"},{"location":"decisions/adr_016_security/#alternative-approaches-considered","title":"Alternative Approaches Considered","text":""},{"location":"decisions/adr_016_security/#simple-retry-logic","title":"Simple Retry Logic","text":"<p>Approach: Basic retry mechanism for push operations</p> <ul> <li>Pros: Simple implementation, handles transient issues</li> <li>Cons: Insufficient for organization-level protection, no secret handling</li> <li>Decision: Rejected - doesn't address root causes of security blocking</li> </ul>"},{"location":"decisions/adr_016_security/#history-rewriting-for-secret-removal","title":"History Rewriting for Secret Removal","text":"<p>Approach: Automatically rewrite git history to remove detected secrets</p> <ul> <li>Pros: Could eliminate secret detection triggers</li> <li>Cons: Would break synchronization with upstream, data loss risk</li> <li>Decision: Rejected - compromises upstream relationship integrity</li> </ul>"},{"location":"decisions/adr_016_security/#forking-without-history","title":"Forking Without History","text":"<p>Approach: Create fork branches without upstream git history</p> <ul> <li>Pros: Avoids secret detection in historical commits</li> <li>Cons: Loses valuable commit history, breaks upstream relationship</li> <li>Decision: Rejected - defeats purpose of maintaining upstream connection</li> </ul>"},{"location":"decisions/adr_016_security/#require-pre-initialization-setup","title":"Require Pre-Initialization Setup","text":"<p>Approach: Require users to configure security settings before using template</p> <ul> <li>Pros: Eliminates initialization-time security conflicts</li> <li>Cons: Significantly complicates user experience, manual overhead</li> <li>Decision: Rejected - conflicts with template automation goals</li> </ul>"},{"location":"decisions/adr_016_security/#consequences-and-trade-offs","title":"Consequences and Trade-offs","text":""},{"location":"decisions/adr_016_security/#positive-outcomes","title":"Positive Outcomes","text":""},{"location":"decisions/adr_016_security/#enhanced-security-handling","title":"Enhanced Security Handling","text":"<ul> <li>Comprehensive detection and handling of both repository and organization-level protection</li> <li>Multiple fallback strategies increasing initialization success rate</li> <li>Clear guidance enabling manual resolution with actionable steps</li> <li>Automatic security setting restoration maintaining protection after initialization</li> </ul>"},{"location":"decisions/adr_016_security/#improved-user-experience","title":"Improved User Experience","text":"<ul> <li>Automatic extraction and presentation of secret allowlist URLs</li> <li>Detailed issues providing multiple resolution options</li> <li>Clear documentation of security considerations and requirements</li> <li>Respectful handling of organization security policies</li> </ul>"},{"location":"decisions/adr_016_security/#operational-reliability","title":"Operational Reliability","text":"<ul> <li>Robust error handling preventing unclear failure states</li> <li>Progressive push strategy handling different types of secret detection</li> <li>Comprehensive logging and status reporting for troubleshooting</li> <li>Clear escalation path when automated approaches insufficient</li> </ul>"},{"location":"decisions/adr_016_security/#trade-offs-and-limitations","title":"Trade-offs and Limitations","text":""},{"location":"decisions/adr_016_security/#implementation-complexity","title":"Implementation Complexity","text":"<ul> <li>More complex implementation than simple push operations</li> <li>Multiple code paths requiring comprehensive testing</li> <li>Dependency on GitHub API for security setting management</li> </ul>"},{"location":"decisions/adr_016_security/#manual-intervention-requirements","title":"Manual Intervention Requirements","text":"<ul> <li>May require manual intervention for organization-level protection</li> <li>Alternative push strategy might not work in all secret detection cases</li> <li>Users may need to coordinate with organization administrators</li> </ul>"},{"location":"decisions/adr_016_security/#success-metrics","title":"Success Metrics","text":""},{"location":"decisions/adr_016_security/#quantitative-indicators","title":"Quantitative Indicators","text":"<ul> <li>Initialization Success Rate: &gt;95% successful initialization despite security policies</li> <li>Automated Resolution Rate: 80%+ of security conflicts resolved automatically</li> <li>Issue Resolution Time: Clear guidance enables &lt;24 hour manual resolution</li> <li>Security Restoration Rate: 100% proper security setting restoration after initialization</li> </ul>"},{"location":"decisions/adr_016_security/#qualitative-indicators","title":"Qualitative Indicators","text":"<ul> <li>Users report clear understanding of security policy interactions</li> <li>Effective guidance enabling successful manual resolution when required</li> <li>Organization administrators comfortable with temporary security modifications</li> <li>Clear audit trail satisfying compliance and security review requirements</li> </ul>"},{"location":"decisions/adr_016_security/#integration-points","title":"Integration Points","text":""},{"location":"decisions/adr_016_security/#material-source-branch-initialization-workflow-integration","title":":material-source-branch Initialization Workflow Integration","text":""},{"location":"decisions/adr_016_security/#two-workflow-initialization-pattern-per-adr-006","title":"Two-Workflow Initialization Pattern (per ADR-006)","text":"<ul> <li>Security handling integrated into initialization workflow architecture</li> <li>Clear coordination between security detection and initialization completion</li> <li>Enhanced error handling coordinated with initialization issue tracking</li> </ul>"},{"location":"decisions/adr_016_security/#template-repository-pattern-per-adr-003","title":"Template Repository Pattern (per ADR-003)","text":"<ul> <li>Security configurations included in template repository structure</li> <li>Clear documentation of security handling for template users</li> <li>Integration with template update propagation for security improvements</li> </ul>"},{"location":"decisions/adr_016_security/#material-shield-check-quality-and-compliance-integration","title":":material-shield-check Quality and Compliance Integration","text":""},{"location":"decisions/adr_016_security/#issue-lifecycle-tracking-per-adr-022","title":"Issue Lifecycle Tracking (per ADR-022)","text":"<ul> <li>Security issues integrated with comprehensive issue lifecycle tracking</li> <li>Clear status progression for security-related initialization problems</li> <li>Coordination with human-required labeling for manual intervention</li> </ul>"},{"location":"decisions/adr_016_security/#related-decisions","title":"Related Decisions","text":"<ul> <li>ADR-006: Two-workflow initialization provides foundation for security handling</li> <li>ADR-003: Template repository includes security configuration files</li> <li>ADR-022: Issue lifecycle tracking coordinates with security issue management</li> <li>ADR-020: Human-required labeling used for security policy issues</li> </ul> <p>This initialization security handling strategy provides comprehensive, respectful management of GitHub push protection policies through multi-layered detection, automated mitigation, alternative strategies, and clear manual resolution guidance while maintaining security compliance and user experience.</p>"},{"location":"decisions/adr_019_cascade_monitor/","title":"ADR-019: Cascade Monitor Pattern","text":"<p> Critical Decision |  2025-06-20 |  Accepted |  Revised 2025-06-29</p>"},{"location":"decisions/adr_019_cascade_monitor/#problem-statement","title":"Problem Statement","text":"<p>The cascade workflow needs reliable triggering when upstream changes are merged into the <code>fork_upstream</code> branch. However, automatic triggering approaches created significant reliability and usability challenges that undermined the system's effectiveness and team adoption.</p>"},{"location":"decisions/adr_019_cascade_monitor/#context-and-requirements","title":"Context and Requirements","text":""},{"location":"decisions/adr_019_cascade_monitor/#automatic-triggering-challenges","title":"Automatic Triggering Challenges","text":"<p>GitHub Event Limitations: - <code>pull_request_target</code> events require workflows to exist on target branch (<code>fork_upstream</code>) - Pure mirror branches don't contain workflow files, breaking event-based triggering - Complex conditional logic needed to filter relevant events from noise - Poor error handling for edge cases and missed triggers</p> <p>Team Control Requirements: - Teams want explicit control over integration timing, not automatic triggering - Need ability to batch multiple changes or time integrations appropriately - Desire for clear audit trails and progress tracking throughout cascade lifecycle - Requirements for reliable error recovery and missed trigger detection</p> <p>Visibility and Reliability Issues: - Unreliable triggering due to workflow file availability constraints - Poor visibility into cascade progress and state management - Complex error handling scattered across multiple workflow conditions - No comprehensive tracking of issue lifecycle and resolution status</p>"},{"location":"decisions/adr_019_cascade_monitor/#architectural-requirements","title":"Architectural Requirements","text":"<p>Human-Centric Control: Explicit human decision points with clear instructions and visible progress tracking.</p> <p>Reliable Safety Net: Automated detection and recovery of missed triggers without complex event dependencies.</p> <p>Comprehensive State Management: Complete audit trail from sync detection through production deployment with issue-based coordination.</p>"},{"location":"decisions/adr_019_cascade_monitor/#decision","title":"Decision","text":"<p>Implement a Human-Centric Cascade Pattern with intelligent monitor-based safety net:</p> <pre><code>graph TD\n    A[Sync PR Merged] --&gt; B[Human Reviews Changes]\n    B --&gt; C[Manual Cascade Trigger]\n    C --&gt; D[Cascade Starts]\n    D --&gt; E[Issue Tracking Updates]\n    E --&gt; F{Conflicts?}\n    F --&gt;|No| G[Integration Success]\n    F --&gt;|Yes| H[Conflict Resolution]\n    H --&gt; I[Human Required]\n    I --&gt; J[Recovery Signal]\n    J --&gt; K[Auto-Retry]\n\n    L[Monitor Schedule] --&gt; M[Check Missed Triggers]\n    M --&gt; N{Pending Changes?}\n    N --&gt;|Yes| O[Auto-Trigger Safety Net]\n    N --&gt;|No| P[Continue Monitoring]\n\n    style A fill:#e1f5fe,stroke:#01579b,stroke-width:2px\n    style C fill:#e8f5e9,stroke:#1b5e20,stroke-width:2px\n    style H fill:#fff3e0,stroke:#e65100,stroke-width:2px\n    style O fill:#fce4ec,stroke:#c2185b,stroke-width:2px</code></pre>"},{"location":"decisions/adr_019_cascade_monitor/#primary-path-human-controlled-integration","title":"Primary Path: Human-Controlled Integration","text":""},{"location":"decisions/adr_019_cascade_monitor/#manual-trigger-process","title":"Manual Trigger Process","text":"<pre><code># Human-centric workflow pattern\nhuman_control:\n  sync_completion: Clear instructions provided in sync workflow completion\n  review_step: Explicit human review of upstream changes required\n  manual_trigger: Cascade Integration workflow triggered manually\n  progress_tracking: Real-time updates through issue comments\n</code></pre>"},{"location":"decisions/adr_019_cascade_monitor/#enhanced-user-guidance","title":"Enhanced User Guidance","text":"<pre><code># Sync workflow completion instructions\nnext_steps:\n  review: \"\ud83d\udd0d Review the sync PR for breaking changes or conflicts\"\n  merge: \"\u2705 Merge the PR when satisfied with changes\"\n  trigger: \"\ud83d\ude80 Manually trigger 'Cascade Integration' workflow\"\n  monitor: \"\ud83d\udcca Monitor cascade progress in Actions tab\"\n</code></pre>"},{"location":"decisions/adr_019_cascade_monitor/#safety-net-monitor-based-detection","title":"Safety Net: Monitor-Based Detection","text":""},{"location":"decisions/adr_019_cascade_monitor/#automated-missed-trigger-detection","title":"Automated Missed-Trigger Detection","text":"<pre><code># cascade-monitor.yml safety net\nmonitor_schedule:\n  frequency: Every 6 hours (safety net detection)\n  manual_trigger: workflow_dispatch for health checking\n  detection_logic: Git-based branch comparison for pending changes\n  recovery_action: Automatic cascade triggering with issue tracking\n</code></pre>"},{"location":"decisions/adr_019_cascade_monitor/#intelligent-branch-comparison","title":"Intelligent Branch Comparison","text":"<pre><code># Reliable git-based detection\ndetection_algorithm:\n  comparison: git rev-list --count fork_integration..fork_upstream\n  threshold: UPSTREAM_COMMITS &gt; 0 indicates pending changes\n  issue_lookup: Find tracking issue using label-based search\n  auto_trigger: Cascade workflow triggered with issue context\n</code></pre>"},{"location":"decisions/adr_019_cascade_monitor/#comprehensive-issue-lifecycle-tracking","title":"Comprehensive Issue Lifecycle Tracking","text":""},{"location":"decisions/adr_019_cascade_monitor/#state-management-through-labels","title":"State Management Through Labels","text":"<pre><code># Label-based state progression\nlifecycle_states:\n  initial: upstream-sync (sync completed, awaiting review)\n  active: cascade-active (integration in progress)\n  blocked: cascade-blocked (conflicts requiring resolution)\n  failed: cascade-failed + human-required (needs intervention)\n  ready: production-ready (PR created, ready for deployment)\n  complete: Issue closed (changes deployed to production)\n</code></pre>"},{"location":"decisions/adr_019_cascade_monitor/#real-time-progress-updates","title":"Real-Time Progress Updates","text":"<pre><code># Issue comment updates throughout cascade\nprogress_communication:\n  start: \"\ud83d\ude80 Cascade Integration Started - [timestamp]\"\n  conflicts: \"\ud83d\udea8 Conflicts detected - manual resolution required\"\n  production: \"\ud83c\udfaf Production PR Created - ready for final review\"\n  completion: \"\u2705 Changes successfully deployed to production\"\n</code></pre>"},{"location":"decisions/adr_019_cascade_monitor/#implementation-strategy","title":"Implementation Strategy","text":""},{"location":"decisions/adr_019_cascade_monitor/#monitor-safety-net-architecture","title":"Monitor Safety Net Architecture","text":""},{"location":"decisions/adr_019_cascade_monitor/#scheduled-detection-system","title":"Scheduled Detection System","text":"<pre><code># cascade-monitor.yml structure\nname: Cascade Monitor\non:\n  schedule:\n    - cron: '0 */6 * * *'  # Safety net every 6 hours\n  workflow_dispatch:        # Manual health checks\n\njobs:\n  detect-missed-cascade:\n    steps:\n      - name: Check for missed triggers\n        run: |\n          # Check if fork_upstream has commits fork_integration lacks\n          UPSTREAM_COMMITS=$(git rev-list --count origin/fork_integration..origin/fork_upstream)\n\n          if [ \"$UPSTREAM_COMMITS\" -gt 0 ]; then\n            # Find active tracking issue\n            ISSUE_NUMBER=$(gh issue list \\\n              --label \"upstream-sync\" \\\n              --state open \\\n              --limit 1 \\\n              --json number \\\n              --jq '.[0].number // empty')\n\n            if [ -n \"$ISSUE_NUMBER\" ]; then\n              # Auto-trigger cascade as safety net\n              gh workflow run \"Cascade Integration\" \\\n                --repo ${{ github.repository }} \\\n                -f issue_number=\"$ISSUE_NUMBER\"\n            fi\n          fi\n</code></pre>"},{"location":"decisions/adr_019_cascade_monitor/#automated-failure-recovery-system","title":"Automated Failure Recovery System","text":""},{"location":"decisions/adr_019_cascade_monitor/#self-healing-recovery-pattern","title":"Self-Healing Recovery Pattern","text":"<pre><code># Recovery detection and automatic retry\nrecovery_system:\n  detection: Issues with cascade-failed but NOT human-required\n  label_transition: cascade-failed \u2192 cascade-active\n  auto_retry: Workflow triggered automatically\n  human_signal: Removing human-required label indicates readiness\n</code></pre>"},{"location":"decisions/adr_019_cascade_monitor/#recovery-workflow-logic","title":"Recovery Workflow Logic","text":"<pre><code># Failure recovery detection\ndetect-recovery-ready:\n  steps:\n    - name: Check for recovery-ready issues\n      run: |\n        # Find issues ready for automated retry\n        RECOVERY_ISSUES=$(gh issue list \\\n          --label \"cascade-failed\" \\\n          --state open \\\n          --jq '.[] | select(.labels | contains([\"cascade-failed\"]) and (contains([\"human-required\"]) | not))')\n\n        # For each recovery-ready issue\n        echo \"$RECOVERY_ISSUES\" | jq -r '.number' | while read ISSUE_NUMBER; do\n          # Update state: cascade-failed \u2192 cascade-active\n          gh issue edit \"$ISSUE_NUMBER\" \\\n            --remove-label \"cascade-failed\" \\\n            --add-label \"cascade-active\"\n\n          # Trigger automatic retry\n          gh workflow run \"Cascade Integration\" \\\n            --repo ${{ github.repository }} \\\n            -f issue_number=\"$ISSUE_NUMBER\"\n        done\n</code></pre>"},{"location":"decisions/adr_019_cascade_monitor/#human-recovery-workflow","title":"Human Recovery Workflow","text":""},{"location":"decisions/adr_019_cascade_monitor/#failure-to-recovery-process","title":"Failure-to-Recovery Process","text":"<pre><code># Human intervention workflow\nfailure_recovery:\n  failure_detection: Cascade fails, issue gets cascade-failed + human-required\n  failure_issue: Technical details in separate high-priority issue\n  human_investigation: Developer reviews failure and implements fixes\n  recovery_signal: Human removes human-required label from tracking issue\n  auto_retry: Monitor detects label removal and retries cascade\n  outcome: Either success or new failure issue creation\n</code></pre>"},{"location":"decisions/adr_019_cascade_monitor/#benefits-and-rationale","title":"Benefits and Rationale","text":""},{"location":"decisions/adr_019_cascade_monitor/#strategic-advantages","title":"Strategic Advantages","text":""},{"location":"decisions/adr_019_cascade_monitor/#enhanced-team-control-and-predictability","title":"Enhanced Team Control and Predictability","text":"<ul> <li>Teams have explicit control over integration timing and batching</li> <li>Predictable, documented process eliminates surprising automatic triggers</li> <li>Clear instructions and guidance reduce cognitive load during operations</li> <li>Flexible timing allows batching changes or avoiding maintenance windows</li> </ul>"},{"location":"decisions/adr_019_cascade_monitor/#improved-reliability-and-visibility","title":"Improved Reliability and Visibility","text":"<ul> <li>No dependencies on complex GitHub event triggering edge cases</li> <li>Git-based detection provides reliable branch state comparison</li> <li>Complete audit trail through issue lifecycle tracking</li> <li>Clear error recovery path with obvious next steps</li> </ul>"},{"location":"decisions/adr_019_cascade_monitor/#self-healing-system-architecture","title":"Self-Healing System Architecture","text":"<ul> <li>Automatic detection and recovery of missed manual triggers</li> <li>Label-based state management enables sophisticated failure recovery</li> <li>Human-automation handoff points clearly defined and tracked</li> <li>Robust error handling with multiple failure attempts tracked separately</li> </ul>"},{"location":"decisions/adr_019_cascade_monitor/#technical-architecture-benefits","title":"Technical Architecture Benefits","text":""},{"location":"decisions/adr_019_cascade_monitor/#simplified-event-handling","title":"Simplified Event Handling","text":"<ul> <li>Eliminates complex conditional logic in workflow triggering</li> <li>Removes dependencies on workflow file availability in target branches</li> <li>Git-based detection more reliable than GitHub event filtering</li> <li>Clear separation between detection, triggering, and execution</li> </ul>"},{"location":"decisions/adr_019_cascade_monitor/#comprehensive-state-management","title":"Comprehensive State Management","text":"<ul> <li>Issue-based coordination provides persistent state tracking</li> <li>Label-based state machine enables sophisticated workflow control</li> <li>Comment-based progress updates provide real-time visibility</li> <li>Complete failure/recovery history maintained in tracking issues</li> </ul>"},{"location":"decisions/adr_019_cascade_monitor/#alternative-approaches-considered","title":"Alternative Approaches Considered","text":""},{"location":"decisions/adr_019_cascade_monitor/#direct-push-triggers","title":"Direct Push Triggers","text":"<p>Approach: Simple push-based triggering on fork_upstream branch</p> <pre><code>on:\n  push:\n    branches: [fork_upstream]\n</code></pre> <ul> <li>Pros: Simple implementation, immediate triggering response</li> <li>Cons: Fires on all pushes, no filtering by intent, no human control</li> <li>Decision: Rejected due to unwanted triggers and lack of control</li> </ul>"},{"location":"decisions/adr_019_cascade_monitor/#combined-pr-and-push-triggers","title":"Combined PR and Push Triggers","text":"<p>Approach: Complex multi-trigger system with conditional logic</p> <pre><code>on:\n  push:\n    branches: [fork_upstream, fork_integration]\n  pull_request:\n    types: [closed]\n    branches: [fork_upstream, fork_integration]\n</code></pre> <ul> <li>Pros: Handles various trigger scenarios comprehensively</li> <li>Cons: Complex conditional logic, difficult debugging, poor error handling</li> <li>Decision: Rejected due to complexity and reliability concerns</li> </ul>"},{"location":"decisions/adr_019_cascade_monitor/#external-webhook-system","title":"External Webhook System","text":"<p>Approach: External service for centralized trigger management</p> <ul> <li>Pros: Maximum flexibility, sophisticated control capabilities</li> <li>Cons: Additional infrastructure, security concerns, maintenance overhead</li> <li>Decision: Rejected due to complexity without proportional benefits</li> </ul>"},{"location":"decisions/adr_019_cascade_monitor/#high-frequency-scheduled-polling","title":"High-Frequency Scheduled Polling","text":"<p>Approach: Frequent scheduled checks for changes</p> <pre><code>on:\n  schedule:\n    - cron: '*/5 * * * *'  # Every 5 minutes\n</code></pre> <ul> <li>Pros: Guaranteed to catch changes eventually</li> <li>Cons: Up to 5-minute delay, inefficient resource usage, doesn't scale</li> <li>Decision: Rejected as primary approach (kept as backup in monitor)</li> </ul>"},{"location":"decisions/adr_019_cascade_monitor/#consequences-and-trade-offs","title":"Consequences and Trade-offs","text":""},{"location":"decisions/adr_019_cascade_monitor/#positive-outcomes","title":"Positive Outcomes","text":""},{"location":"decisions/adr_019_cascade_monitor/#enhanced-human-experience","title":"Enhanced Human Experience","text":"<ul> <li>Explicit control over integration timing builds team confidence</li> <li>Clear instructions eliminate confusion about next steps</li> <li>Complete visibility into cascade progress through issue tracking</li> <li>Predictable process enables reliable team adoption</li> </ul>"},{"location":"decisions/adr_019_cascade_monitor/#system-reliability-improvements","title":"System Reliability Improvements","text":"<ul> <li>No dependency on complex GitHub event triggering mechanisms</li> <li>Git-based detection provides robust change identification</li> <li>Automated safety net prevents missed triggers from blocking progress</li> <li>Self-healing recovery system reduces manual intervention requirements</li> </ul>"},{"location":"decisions/adr_019_cascade_monitor/#operational-excellence","title":"Operational Excellence","text":"<ul> <li>Complete audit trail for all cascade decisions and outcomes</li> <li>Clear error recovery path with obvious resolution steps</li> <li>Sophisticated failure/recovery tracking through issue labels</li> <li>Flexible timing control enables operational best practices</li> </ul>"},{"location":"decisions/adr_019_cascade_monitor/#trade-offs-and-limitations","title":"Trade-offs and Limitations","text":""},{"location":"decisions/adr_019_cascade_monitor/#manual-process-requirements","title":"Manual Process Requirements","text":"<ul> <li>Humans must remember to trigger cascades after sync completion</li> <li>Potential delays up to 6 hours if manual trigger is forgotten</li> <li>Team learning curve for understanding manual trigger process</li> </ul>"},{"location":"decisions/adr_019_cascade_monitor/#system-complexity","title":"System Complexity","text":"<ul> <li>Issue lifecycle tracking adds workflow coordination complexity</li> <li>Cross-workflow dependencies require understanding of interaction patterns</li> <li>Monitor workflow dependency for safety net functionality</li> </ul>"},{"location":"decisions/adr_019_cascade_monitor/#operational-considerations","title":"Operational Considerations","text":"<ul> <li>Additional workflow file increases maintenance surface area</li> <li>Testing requires both trigger detection and cascade execution validation</li> <li>Debugging may span multiple workflows requiring end-to-end understanding</li> </ul>"},{"location":"decisions/adr_019_cascade_monitor/#success-metrics","title":"Success Metrics","text":""},{"location":"decisions/adr_019_cascade_monitor/#quantitative-indicators","title":"Quantitative Indicators","text":"<ul> <li>Manual Trigger Adoption: &gt;90% of sync merges followed by manual cascade triggers within 2 hours</li> <li>Safety Net Effectiveness: 100% of missed manual triggers detected by monitor within 6 hours</li> <li>Issue Lifecycle Completeness: 95%+ of cascades with complete issue tracking</li> <li>Conflict Resolution SLA: 48 hours with automatic escalation for conflicts</li> </ul>"},{"location":"decisions/adr_019_cascade_monitor/#qualitative-indicators","title":"Qualitative Indicators","text":"<ul> <li>Team reports high confidence in cascade triggering process</li> <li>Clear understanding of manual trigger requirements across all team members</li> <li>Effective error recovery with minimal support intervention required</li> <li>Complete audit trail satisfaction for operational compliance requirements</li> </ul>"},{"location":"decisions/adr_019_cascade_monitor/#integration-points","title":"Integration Points","text":""},{"location":"decisions/adr_019_cascade_monitor/#workflow-integration","title":"Workflow Integration","text":""},{"location":"decisions/adr_019_cascade_monitor/#sync-workflow-coordination","title":"Sync Workflow Coordination","text":"<ul> <li>Sync workflow creates PRs with <code>upstream-sync</code> label for identification</li> <li>Tracking issues created with explicit manual trigger instructions</li> <li>Human review, merge, and manual cascade trigger workflow</li> </ul>"},{"location":"decisions/adr_019_cascade_monitor/#cascade-workflow-enhancement","title":"Cascade Workflow Enhancement","text":"<ul> <li>Cascade runs on <code>workflow_dispatch</code> (manual or monitor-triggered)</li> <li>Issue label updates and progress comments throughout process</li> <li>Conflict handling, integration, and production PR creation coordination</li> </ul>"},{"location":"decisions/adr_019_cascade_monitor/#label-management-integration-per-adr-008","title":"Label Management Integration (per ADR-008)","text":"<ul> <li>Predefined labels: <code>upstream-sync</code>, <code>cascade-trigger-failed</code>, <code>human-required</code></li> <li>Existing label-based notification system leverage</li> <li>Consistency with other workflow patterns maintained</li> </ul>"},{"location":"decisions/adr_019_cascade_monitor/#related-decisions","title":"Related Decisions","text":"<ul> <li>ADR-001: Three-branch strategy defines cascade target branches</li> <li>ADR-005: Conflict handling within cascade workflows</li> <li>ADR-008: Centralized label management for state tracking</li> <li>ADR-009: Asymmetric cascade review requirements</li> <li>ADR-020: Human-required labeling coordinates activities</li> </ul> <p>This cascade monitor pattern provides reliable, human-controlled integration with automated safety nets, ensuring predictable operations while maintaining system reliability through comprehensive state management and self-healing recovery capabilities.</p>"},{"location":"decisions/adr_020_human_labels/","title":"ADR-020: Human-Required Label Strategy","text":"<p> Critical Decision |  2025-06-20 |  Accepted |  Revised 2025-06-29</p>"},{"location":"decisions/adr_020_human_labels/#problem-statement","title":"Problem Statement","text":"<p>GitHub workflows frequently need to create issues and pull requests requiring human attention. Traditional assignee-based approaches create significant reliability, maintainability, and scalability challenges that block critical automation processes and limit template repository effectiveness.</p>"},{"location":"decisions/adr_020_human_labels/#context-and-requirements","title":"Context and Requirements","text":""},{"location":"decisions/adr_020_human_labels/#assignee-based-task-management-problems","title":"Assignee-Based Task Management Problems","text":"<p>Username Resolution Issues: - GitHub's GraphQL API requires exact usernames for assignment operations - Organization names cannot be assigned to issues, causing API validation failures - Different workflows run in varying contexts with different triggering users - Template repositories need flexible assignment across multiple instances</p> <p>Workflow Reliability Challenges: - Invalid usernames cause workflow failures with cryptic GraphQL errors - Error messages like \"Could not resolve to a User with the login of 'organization-name'\" - Hardcoded usernames become stale and require constant maintenance - Cross-repository template complexity when deployment contexts vary</p> <p>Problematic Implementation Patterns: <pre><code># Common failing patterns\n--assignee \"${{ github.repository_owner }}\"  # Organization name (invalid)\n--assignee \"hardcoded-username\"              # Brittle and unmaintainable  \n--assignee \"${{ github.actor }}\"             # Context-dependent failures\n</code></pre></p>"},{"location":"decisions/adr_020_human_labels/#task-management-requirements","title":"Task Management Requirements","text":"<p>Reliable Workflow Execution: Task assignment should never cause workflow failures or block critical automation processes.</p> <p>Template Repository Compatibility: Assignment approach must work identically across all template instances without configuration.</p> <p>Flexible Team Organization: Support various team structures and workflows without hardcoded assumptions about users or roles.</p>"},{"location":"decisions/adr_020_human_labels/#decision","title":"Decision","text":"<p>Replace assignee-based task management with a Human-Required Label Strategy using GitHub's robust label system for task visibility and workflow coordination:</p> <pre><code>graph TD\n    A[Workflow Creates Issue] --&gt; B[Apply human-required Label]\n    B --&gt; C[Add Context Labels]\n    C --&gt; D[Team Member Filters]\n    D --&gt; E[Work Assignment]\n    E --&gt; F[Update Labels During Work]\n    F --&gt; G[Complete and Close]\n\n    H[Label Categories] --&gt; I[Priority: high-priority]\n    H --&gt; J[Type: conflict, sync-failed]\n    H --&gt; K[Lifecycle: cascade-active]\n    H --&gt; L[Status: escalation]\n\n    style A fill:#e1f5fe,stroke:#01579b,stroke-width:2px\n    style B fill:#e8f5e9,stroke:#1b5e20,stroke-width:2px\n    style F fill:#fff3e0,stroke:#e65100,stroke-width:2px\n    style G fill:#fce4ec,stroke:#c2185b,stroke-width:2px</code></pre>"},{"location":"decisions/adr_020_human_labels/#core-label-strategy","title":"Core Label Strategy","text":""},{"location":"decisions/adr_020_human_labels/#primary-human-required-label","title":"Primary Human-Required Label","text":"<pre><code># Core task identification\nhuman_required_label:\n  name: \"human-required\"\n  description: \"Requires human intervention or review\"\n  color: \"D73A49\"\n  usage: Applied to all issues/PRs needing human attention\n  reliability: Never fails - no username validation required\n</code></pre>"},{"location":"decisions/adr_020_human_labels/#supporting-classification-labels","title":"Supporting Classification Labels","text":"<pre><code># Enhanced task categorization\nclassification_labels:\n  priority:\n    - high-priority: Urgent items requiring immediate attention\n    - emergency: Critical system issues requiring escalation\n\n  type:\n    - conflict: Merge conflicts requiring manual resolution\n    - sync-failed: Failed synchronization operations\n    - escalation: Issues that have exceeded SLA timeouts\n    - cascade-trigger-failed: Failed cascade workflow triggers\n\n  lifecycle:\n    - upstream-sync: Issues related to upstream synchronization\n    - cascade-active: Cascade integration currently in progress\n    - cascade-blocked: Cascade blocked by conflicts or issues\n    - production-ready: Ready for production deployment\n    - validated: Integration complete, validation successful\n</code></pre>"},{"location":"decisions/adr_020_human_labels/#material-workflow-enhanced-workflow-implementation","title":":material-workflow: Enhanced Workflow Implementation","text":""},{"location":"decisions/adr_020_human_labels/#robust-issue-creation-pattern","title":"Robust Issue Creation Pattern","text":"<pre><code># Before: Problematic assignee-based approach\nproblematic_pattern:\n  validation: Complex username resolution logic\n  assignment: --assignee validation with multiple fallbacks\n  failure_points: API validation, username resolution, context issues\n  maintenance: Hardcoded usernames requiring updates\n\n# After: Label-based approach\nrobust_pattern:\n  creation: Simple issue creation with human-required label\n  classification: Context-appropriate additional labels\n  reliability: No username validation or API failures\n  maintenance: Zero hardcoded user dependencies\n</code></pre>"},{"location":"decisions/adr_020_human_labels/#lifecycle-management-through-labels","title":"Lifecycle Management Through Labels","text":"<pre><code># Dynamic label updates during workflow progression\nlifecycle_management:\n  initial_state: upstream-sync + human-required\n  work_begins: Remove human-required, add cascade-active\n  conflicts_detected: Add cascade-blocked + conflict\n  resolution_complete: Update to production-ready\n  deployment_finished: Close issue, remove all lifecycle labels\n</code></pre>"},{"location":"decisions/adr_020_human_labels/#implementation-strategy","title":"Implementation Strategy","text":""},{"location":"decisions/adr_020_human_labels/#material-cog-sync-outline-enhanced-workflow-patterns","title":":material-cog-sync-outline Enhanced Workflow Patterns","text":""},{"location":"decisions/adr_020_human_labels/#issue-creation-replacement","title":"Issue Creation Replacement","text":"<pre><code># New robust issue creation pattern\nissue_creation:\n  before: |\n    # Complex validation logic (prone to failures)\n    ASSIGNEE=\"${{ github.actor }}\"\n    if gh api users/\"$ASSIGNEE\" &gt;/dev/null 2&gt;&amp;1; then\n      ASSIGNEE_FLAG=\"--assignee $ASSIGNEE\"\n    else\n      ASSIGNEE_FLAG=\"\"\n    fi\n\n    gh issue create \\\n      --title \"Issue requiring attention\" \\\n      --body \"Issue details...\" \\\n      --label \"some-label\" \\\n      $ASSIGNEE_FLAG\n\n  after: |\n    # Simple, reliable label-based approach\n    gh issue create \\\n      --title \"\ud83d\udce5 Upstream Sync Ready for Review - $(date +%Y-%m-%d)\" \\\n      --body \"$NOTIFICATION_BODY\" \\\n      --label \"upstream-sync,human-required\"\n</code></pre>"},{"location":"decisions/adr_020_human_labels/#dynamic-label-management","title":"Dynamic Label Management","text":"<pre><code># Real-time label updates during workflow execution\nlabel_updates:\n  cascade_start: |\n    gh issue edit \"$ISSUE_NUMBER\" \\\n      --remove-label \"human-required\" \\\n      --add-label \"cascade-active\"\n\n  conflict_detection: |\n    gh issue edit \"$ISSUE_NUMBER\" \\\n      --remove-label \"cascade-active\" \\\n      --add-label \"cascade-blocked,conflict,high-priority\"\n\n  production_ready: |\n    gh issue edit \"$ISSUE_NUMBER\" \\\n      --remove-label \"cascade-active\" \\\n      --add-label \"production-ready\"\n</code></pre>"},{"location":"decisions/adr_020_human_labels/#material-filter-outline-team-workflow-integration","title":":material-filter-outline Team Workflow Integration","text":""},{"location":"decisions/adr_020_human_labels/#github-issue-filtering-patterns","title":"GitHub Issue Filtering Patterns","text":"<pre><code># Efficient team filtering strategies\nfiltering_patterns:\n  daily_queue: \"label:human-required label:high-priority\"\n  conflict_focus: \"label:human-required label:conflict\"\n  cascade_monitoring: \"label:upstream-sync label:cascade-active\"\n  emergency_response: \"label:human-required label:emergency\"\n\n  lifecycle_tracking:\n    needs_trigger: \"label:upstream-sync label:human-required\"\n    in_progress: \"label:upstream-sync label:cascade-active\"\n    blocked: \"label:upstream-sync label:cascade-blocked\"\n    ready_deploy: \"label:upstream-sync label:production-ready\"\n</code></pre>"},{"location":"decisions/adr_020_human_labels/#project-board-automation","title":"Project Board Automation","text":"<pre><code># Automated project board organization\nproject_automation:\n  needs_attention: \"label:human-required \u2192 'Needs Attention' column\"\n  urgent_items: \"label:high-priority \u2192 'Urgent' column\"\n  conflicts: \"label:conflict \u2192 'Conflicts' column\"\n  in_progress: \"Remove human-required when work starts\"\n</code></pre>"},{"location":"decisions/adr_020_human_labels/#material-account-supervisor-circle-team-adoption-framework","title":":material-account-supervisor-circle Team Adoption Framework","text":""},{"location":"decisions/adr_020_human_labels/#individual-developer-workflows","title":"Individual Developer Workflows","text":"<pre><code># Efficient developer workflow patterns\ndeveloper_workflows:\n  morning_review: |\n    # Check high-priority items first\n    https://github.com/org/repo/issues?q=is:open+label:human-required+label:high-priority\n\n  weekly_triage: |\n    # Review all human-required items\n    https://github.com/org/repo/issues?q=is:open+label:human-required\n\n  conflict_specialization: |\n    # Focus on conflict resolution\n    https://github.com/org/repo/issues?q=is:open+label:conflict+label:human-required\n</code></pre>"},{"location":"decisions/adr_020_human_labels/#benefits-and-rationale","title":"Benefits and Rationale","text":""},{"location":"decisions/adr_020_human_labels/#material-trending-up-reliability-and-maintainability","title":":material-trending-up Reliability and Maintainability","text":""},{"location":"decisions/adr_020_human_labels/#workflow-reliability-improvements","title":"Workflow Reliability Improvements","text":"<ul> <li>Zero Username Failures: Labels never fail due to user validation issues</li> <li>Template Compatibility: Works identically across all repository instances</li> <li>API Resilience: No dependency on GitHub user resolution APIs</li> <li>Universal Compatibility: Functions in all organizational contexts</li> </ul>"},{"location":"decisions/adr_020_human_labels/#maintenance-elimination","title":"Maintenance Elimination","text":"<ul> <li>No Hardcoded Users: Eliminates need to maintain username lists</li> <li>Self-Contained Templates: Template repositories require no user configuration</li> <li>Context Independence: Works regardless of triggering user or repository owner</li> <li>Simplified Logic: Removes complex validation and fallback patterns</li> </ul>"},{"location":"decisions/adr_020_human_labels/#material-cog-outline-enhanced-team-organization","title":":material-cog-outline Enhanced Team Organization","text":""},{"location":"decisions/adr_020_human_labels/#flexible-workflow-management","title":"Flexible Workflow Management","text":"<ul> <li>Better Filtering: Teams create custom views using label combinations</li> <li>Priority Systems: Multiple priority levels through label combinations</li> <li>Type Classification: Clear categorization of work through descriptive labels</li> <li>Load Balancing: Natural distribution as any team member can pick up work</li> </ul>"},{"location":"decisions/adr_020_human_labels/#scalable-process-architecture","title":"Scalable Process Architecture","text":"<ul> <li>Team Size Independence: Works regardless of team structure or size</li> <li>Clear Ownership: Labels indicate type and urgency without specific assignment</li> <li>Automated Processing: Workflows can reliably query and act on labels</li> <li>Audit Trail: Complete visibility into issue classification and progression</li> </ul>"},{"location":"decisions/adr_020_human_labels/#alternative-approaches-considered","title":"Alternative Approaches Considered","text":""},{"location":"decisions/adr_020_human_labels/#enhanced-user-validation","title":"Enhanced User Validation","text":"<p>Approach: Complex validation logic with multiple fallback strategies</p> <pre><code># Multi-stage user resolution attempt\nif gh api users/\"${{ github.actor }}\" &gt;/dev/null 2&gt;&amp;1; then\n  ASSIGNEE_FLAG=\"--assignee ${{ github.actor }}\"\nelif gh api users/\"${{ github.repository_owner }}\" &gt;/dev/null 2&gt;&amp;1; then\n  ASSIGNEE_FLAG=\"--assignee ${{ github.repository_owner }}\"\nelse\n  ASSIGNEE_FLAG=\"--assignee $(gh api /repos/:owner/:repo/collaborators --jq '.[0].login')\"\nfi\n</code></pre> <ul> <li>Pros: Maintains traditional assignment approach</li> <li>Cons: Complex logic, API rate limiting, still fails in edge cases, fragile</li> <li>Decision: Rejected due to complexity and fundamental reliability issues</li> </ul>"},{"location":"decisions/adr_020_human_labels/#configuration-based-assignment","title":"Configuration-Based Assignment","text":"<p>Approach: Repository variables for assignee configuration</p> <pre><code># Configurable assignment approach\n--assignee \"${{ vars.DEFAULT_ASSIGNEE }}\"\n</code></pre> <ul> <li>Pros: Configurable per repository deployment</li> <li>Cons: Still requires username validation, manual setup overhead, maintenance burden</li> <li>Decision: Rejected due to configuration complexity and maintenance requirements</li> </ul>"},{"location":"decisions/adr_020_human_labels/#external-assignment-service","title":"External Assignment Service","text":"<p>Approach: Dedicated service for sophisticated assignment logic</p> <ul> <li>Pros: Could handle complex assignment rules and validation</li> <li>Cons: Additional infrastructure, external dependencies, single point of failure</li> <li>Decision: Rejected as over-engineering for task assignment requirements</li> </ul>"},{"location":"decisions/adr_020_human_labels/#hybrid-assignment-and-labels","title":"Hybrid Assignment and Labels","text":"<p>Approach: Attempt assignment with label fallback</p> <pre><code># Best-of-both-worlds attempt\nif [[ -n \"${{ vars.DEFAULT_ASSIGNEE }}\" ]]; then\n  --assignee \"${{ vars.DEFAULT_ASSIGNEE }}\"\nfi\n--label \"human-required\"\n</code></pre> <ul> <li>Pros: Combines benefits of both approaches</li> <li>Cons: Still susceptible to assignment failures, increased complexity</li> <li>Decision: Rejected in favor of label-only simplicity and reliability</li> </ul>"},{"location":"decisions/adr_020_human_labels/#consequences-and-trade-offs","title":"Consequences and Trade-offs","text":""},{"location":"decisions/adr_020_human_labels/#positive-outcomes","title":"Positive Outcomes","text":""},{"location":"decisions/adr_020_human_labels/#system-reliability-excellence","title":"System Reliability Excellence","text":"<ul> <li>Workflows never fail due to username resolution issues</li> <li>Template repositories work identically across all deployment contexts</li> <li>Simplified workflow code eliminates complex validation logic</li> <li>Zero maintenance overhead for user assignment management</li> </ul>"},{"location":"decisions/adr_020_human_labels/#enhanced-team-workflow","title":"Enhanced Team Workflow","text":"<ul> <li>Teams can organize work according to their preferred processes</li> <li>Better filtering capabilities through label combination strategies</li> <li>Natural load balancing as any team member can address labeled items</li> <li>Clear audit trail through label progression tracking</li> </ul>"},{"location":"decisions/adr_020_human_labels/#operational-scalability","title":"Operational Scalability","text":"<ul> <li>Works across any team size or organizational structure</li> <li>Supports multiple concurrent template repository deployments</li> <li>Enables sophisticated workflow automation through label queries</li> <li>Facilitates integration with external project management tools</li> </ul>"},{"location":"decisions/adr_020_human_labels/#trade-offs-and-limitations","title":"Trade-offs and Limitations","text":""},{"location":"decisions/adr_020_human_labels/#process-adaptation-requirements","title":"Process Adaptation Requirements","text":"<ul> <li>Teams must adapt from assignment-based to label-based workflows</li> <li>Individual accountability requires discipline rather than automatic assignment</li> <li>Team members need to learn effective label filtering strategies</li> <li>No automatic assignment notifications (replaced by label-based filtering)</li> </ul>"},{"location":"decisions/adr_020_human_labels/#organizational-considerations","title":"Organizational Considerations","text":"<ul> <li>Different workflow approach may initially feel unfamiliar</li> <li>Requires team agreement on label-based work distribution</li> <li>Learning curve for optimizing label filtering and project board setup</li> </ul>"},{"location":"decisions/adr_020_human_labels/#success-metrics","title":"Success Metrics","text":""},{"location":"decisions/adr_020_human_labels/#quantitative-indicators","title":"Quantitative Indicators","text":"<ul> <li>Workflow Reliability: 100% workflow success (zero assignment-related failures)</li> <li>Issue Resolution Time: Average &lt;48 hours for human-required items</li> <li>Team Adoption: 100% team members using label-based filtering within 2 weeks</li> <li>Template Compatibility: Identical behavior across all repository instances</li> </ul>"},{"location":"decisions/adr_020_human_labels/#qualitative-indicators","title":"Qualitative Indicators","text":"<ul> <li>Team reports improved clarity in work identification and prioritization</li> <li>Reduced support burden for workflow failures and assignment issues</li> <li>Effective integration with existing project management and notification systems</li> <li>Clear audit trail satisfaction for operational compliance requirements</li> </ul>"},{"location":"decisions/adr_020_human_labels/#integration-points","title":"Integration Points","text":""},{"location":"decisions/adr_020_human_labels/#material-label-multiple-outline-label-management-integration","title":":material-label-multiple-outline Label Management Integration","text":""},{"location":"decisions/adr_020_human_labels/#centralized-label-definitions-per-adr-008","title":"Centralized Label Definitions (per ADR-008)","text":"<ul> <li>Leverages centralized label management through <code>.github/labels.json</code></li> <li>Consistent label definitions across all repository instances</li> <li>Automated label creation during repository initialization</li> </ul>"},{"location":"decisions/adr_020_human_labels/#workflow-pattern-integration","title":"Workflow Pattern Integration","text":"<ul> <li>Sync Workflow: Uses <code>upstream-sync,human-required</code> for manual cascade triggering</li> <li>Cascade Workflow: Uses lifecycle labels (<code>cascade-active</code>, <code>cascade-blocked</code>, <code>production-ready</code>)</li> <li>Monitor Workflow: Uses <code>human-required</code> for trigger failure notifications</li> <li>Template Sync: Uses <code>template-sync,human-required</code> for template updates</li> </ul>"},{"location":"decisions/adr_020_human_labels/#material-integration-external-system-integration","title":":material-integration External System Integration","text":""},{"location":"decisions/adr_020_human_labels/#project-board-automation_1","title":"Project Board Automation","text":"<ul> <li>Automatic card movement based on label combinations</li> <li>Custom project views organized by priority and type labels</li> <li>Workflow automation rules triggered by label changes</li> </ul>"},{"location":"decisions/adr_020_human_labels/#notification-system-integration","title":"Notification System Integration","text":"<ul> <li>Slack/Teams integration filtered by label combinations</li> <li>Email notifications for high-priority labeled items</li> <li>GitHub Apps querying issues by label patterns</li> </ul>"},{"location":"decisions/adr_020_human_labels/#related-decisions","title":"Related Decisions","text":"<ul> <li>ADR-008: Centralized label management strategy provides foundation</li> <li>ADR-019: Cascade monitor pattern uses human-required labels</li> <li>ADR-022: Issue lifecycle tracking defines label progression patterns</li> <li>Sync Workflow Updates: Implements label-based task management throughout</li> <li>Cascade Workflow Updates: Uses labels for conflict and progress management</li> </ul> <p>This human-required label strategy provides reliable, scalable task management through GitHub's robust label system, eliminating workflow failures while enabling flexible team organization and sophisticated automation capabilities.</p>"},{"location":"decisions/adr_022_lifecycle/","title":"ADR-022: Issue Lifecycle Tracking Pattern","text":"<p> Critical Decision |  2025-06-29 |  Accepted</p>"},{"location":"decisions/adr_022_lifecycle/#problem-statement","title":"Problem Statement","text":"<p>The fork management template's three-branch cascade strategy and human-centric cascade pattern require comprehensive visibility into upstream integration workflow state and progress. Teams need clear understanding of cascade status, error conditions, and required actions without diving into complex workflow logs or GitHub Actions details.</p>"},{"location":"decisions/adr_022_lifecycle/#context-and-requirements","title":"Context and Requirements","text":""},{"location":"decisions/adr_022_lifecycle/#cascade-visibility-challenges","title":"Cascade Visibility Challenges","text":"<p>Poor State Visibility: - No central location to check current cascade status for specific upstream changes - Integration progress scattered across multiple workflow runs and branch states - Difficult to understand relationship between sync, cascade, and production deployment - Hard to track which upstream changesets are in what stage of integration</p> <p>Communication and Coordination Issues: - Unclear when human intervention is required and what actions should be taken - Error conditions buried in workflow logs, not prominently visible to team - Lost context about what specific changes are being integrated through the system - Difficult to coordinate team activities around specific upstream integration cycles</p> <p>Audit and Historical Tracking: - No complete audit trail of how upstream changes flowed through the system - Difficult to trace decision points and timing for troubleshooting - Poor visibility into cascade performance metrics and bottlenecks - Limited ability to learn from historical integration patterns and issues</p>"},{"location":"decisions/adr_022_lifecycle/#lifecycle-tracking-requirements","title":"Lifecycle Tracking Requirements","text":"<p>Single Source of Truth: One location per upstream changeset providing complete cascade status and history.</p> <p>Real-Time State Management: Live updates reflecting current cascade state with clear next actions for team members.</p> <p>Machine-Readable Automation: Label-based state management enabling sophisticated workflow automation and tooling integration.</p>"},{"location":"decisions/adr_022_lifecycle/#decision","title":"Decision","text":"<p>Implement Issue Lifecycle Tracking Pattern creating and maintaining GitHub issues throughout the complete cascade process:</p> <pre><code>stateDiagram-v2\n    [*] --&gt; created: sync.yml detects changes\n    created --&gt; human_required: Issue created with upstream-sync label\n    human_required --&gt; cascade_active: Human triggers cascade\n    human_required --&gt; cascade_active: Monitor auto-triggers (safety net)\n    cascade_active --&gt; cascade_blocked: Conflicts detected\n    cascade_active --&gt; cascade_failed: Integration failed\n    cascade_active --&gt; validated: Integration successful\n    cascade_blocked --&gt; cascade_active: Conflicts resolved\n    cascade_failed --&gt; cascade_active: Human resolves + monitor retries\n    validated --&gt; [*]: Production PR merged, issue closed\n\n    note right of human_required\n        Manual review and cascade trigger required\n        Clear instructions provided in issue\n    end note\n\n    note right of cascade_blocked\n        Merge conflicts detected\n        Separate conflict issue created\n        48-hour SLA for resolution\n    end note\n\n    note right of validated\n        Production PR ready for merge\n        Auto-merge or manual review\n    end note</code></pre>"},{"location":"decisions/adr_022_lifecycle/#material-file-document-edit-issue-creation-and-management","title":":material-file-document-edit Issue Creation and Management","text":""},{"location":"decisions/adr_022_lifecycle/#comprehensive-issue-creation-in-sync-workflow","title":"Comprehensive Issue Creation in Sync Workflow","text":"<pre><code># Enhanced issue creation with complete context\nissue_creation_pattern:\n  trigger: \"sync.yml after successful PR creation\"\n  title: \"\ud83d\udce5 Upstream Sync Ready for Review - $(date +%Y-%m-%d)\"\n  labels: \"upstream-sync,human-required\"\n\n  body_content: |\n    ## \ud83d\udce5 Upstream Sync Ready for Review\n\n    New upstream changes are available and ready for review.\n\n    **Sync Details:**\n    - **PR:** $PR_URL  \n    - **Upstream Version:** $UPSTREAM_VERSION\n    - **Commits:** $COMMIT_COUNT new commits from upstream\n    - **Branch:** `$SYNC_BRANCH` \u2192 `fork_upstream`\n\n    **Next Steps:**\n    1. \ud83d\udd0d **Review the sync PR** for breaking changes or conflicts\n    2. \u2705 **Merge the PR** when satisfied with changes  \n    3. \ud83d\ude80 **Manually trigger 'Cascade Integration' workflow**\n    4. \ud83d\udcca **Monitor cascade progress** in Actions tab\n\n    **Timeline:**\n    - Sync detected: $(date -u +%Y-%m-%dT%H:%M:%SZ)\n    - Action required: Human review, merge, and cascade trigger\n</code></pre>"},{"location":"decisions/adr_022_lifecycle/#direct-issue-number-integration","title":"Direct Issue Number Integration","text":"<pre><code># Cascade workflow input parameter\ncascade_workflow_input:\n  issue_number:\n    description: 'GitHub issue number for upstream sync tracking (e.g., 123)'\n    required: true\n    type: 'string'\n\n  usage: |\n    # Eliminates complex issue searching logic\n    ISSUE_NUMBER=\"${{ github.event.inputs.issue_number }}\"\n\n    # Direct issue updates throughout cascade process\n    gh issue edit \"$ISSUE_NUMBER\" --remove-label \"human-required\" --add-label \"cascade-active\"\n</code></pre>"},{"location":"decisions/adr_022_lifecycle/#material-state-machine-label-based-state-management","title":":material-state-machine Label-Based State Management","text":""},{"location":"decisions/adr_022_lifecycle/#comprehensive-state-transition-table","title":"Comprehensive State Transition Table","text":"<pre><code># Complete label-based state machine\nstate_transitions:\n  initial_state:\n    labels: \"upstream-sync, human-required\"\n    meaning: \"Upstream sync complete, awaiting manual cascade trigger\"\n    human_action: \"Review sync PR, merge, trigger cascade\"\n    next_state: \"cascade-active\"\n\n  processing_state:\n    labels: \"upstream-sync, cascade-active\"\n    meaning: \"Cascade integration in progress\"\n    human_action: \"Monitor progress, wait for completion\"\n    next_states: [\"validated\", \"cascade-blocked\", \"cascade-failed\"]\n\n  conflict_state:\n    labels: \"upstream-sync, cascade-blocked\"\n    meaning: \"Conflicts detected, manual resolution needed\"\n    human_action: \"Resolve conflicts, commit fixes\"\n    next_state: \"cascade-active\"\n\n  failure_state:\n    labels: \"upstream-sync, cascade-failed, human-required\"\n    meaning: \"Integration failed, human intervention required\"\n    human_action: \"Review failure issue, fix problems, remove human-required label\"\n    next_state: \"cascade-active (automatic retry)\"\n\n  completion_state:\n    labels: \"upstream-sync, validated\"\n    meaning: \"Production PR created, ready for final review\"\n    human_action: \"Review and merge production PR\"\n    final_state: \"Issue closed\"\n</code></pre>"},{"location":"decisions/adr_022_lifecycle/#real-time-progress-updates","title":"Real-Time Progress Updates","text":"<pre><code># Comprehensive progress communication pattern\nprogress_updates:\n  cascade_start: |\n    \ud83d\ude80 **Cascade Integration Started** - $(date -u +%Y-%m-%dT%H:%M:%SZ)\n\n    Integration workflow has been triggered and is processing upstream changes.\n\n    **Status:** Merging `fork_upstream` \u2192 `fork_integration` \u2192 `main`\n    **Workflow:** [View Progress](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})\n\n  conflict_detection: |\n    \ud83d\udea8 **Conflicts Detected** - $(date -u +%Y-%m-%dT%H:%M:%SZ)\n\n    Merge conflicts were detected during integration. Manual resolution required.\n\n    **Status:** Cascade blocked - manual conflict resolution required\n    **SLA:** 48 hours for resolution\n    **Conflict Issue:** [Details](#conflict-issue-url)\n\n  production_ready: |\n    \ud83c\udfaf **Production PR Created** - $(date -u +%Y-%m-%dT%H:%M:%SZ)\n\n    Integration completed successfully! Production PR ready for final review.\n\n    **Production PR:** $PR_URL\n    **Auto-merge:** $([ \"$BREAKING_CHANGES\" == \"false\" ] &amp;&amp; echo \"\u2705 Enabled\" || echo \"\u274c Manual review required\")\n\n    **Final Steps:**\n    1. Review and merge the production PR\n    2. This issue will be closed when changes reach main\n</code></pre>"},{"location":"decisions/adr_022_lifecycle/#implementation-strategy","title":"Implementation Strategy","text":""},{"location":"decisions/adr_022_lifecycle/#material-workflow-workflow-integration-architecture","title":":material-workflow Workflow Integration Architecture","text":""},{"location":"decisions/adr_022_lifecycle/#sync-workflow-issue-creation","title":"Sync Workflow Issue Creation","text":"<pre><code># Complete sync workflow issue creation implementation\nsync_issue_creation:\n  location: \"sync.yml after successful PR creation\"\n\n  implementation: |\n    # Build comprehensive notification body\n    NOTIFICATION_BODY=\"## \ud83d\udce5 Upstream Sync Ready for Review\n\n    New upstream changes are available and ready for review.\n\n    **Sync Details:**\n    - **PR:** $PR_URL  \n    - **Upstream Version:** $UPSTREAM_VERSION\n    - **Commits:** $COMMIT_COUNT new commits from upstream\n    - **Branch:** \\`$SYNC_BRANCH\\` \u2192 \\`fork_upstream\\`\n\n    **Next Steps:**\n    1. \ud83d\udd0d **Review the sync PR** for any breaking changes or conflicts\n    2. \u2705 **Merge the PR** when satisfied with the changes  \n    3. \ud83d\ude80 **Manually trigger 'Cascade Integration' workflow** to integrate changes\n    4. \ud83d\udcca **Monitor cascade progress** in Actions tab\n\n    **Timeline:**\n    - Sync detected: $(date -u +%Y-%m-%dT%H:%M:%SZ)\n    - Action required: Human review, merge, and cascade trigger\"\n\n    # Create tracking issue\n    gh issue create \\\n      --title \"\ud83d\udce5 Upstream Sync Ready for Review - $(date +%Y-%m-%d)\" \\\n      --body \"$NOTIFICATION_BODY\" \\\n      --label \"upstream-sync,human-required\"\n</code></pre>"},{"location":"decisions/adr_022_lifecycle/#cascade-workflow-state-updates","title":"Cascade Workflow State Updates","text":"<pre><code># Comprehensive cascade workflow issue updates\ncascade_state_management:\n  issue_parameter: \"Direct issue number input eliminates search complexity\"\n\n  state_updates: |\n    # Use provided issue number directly\n    ISSUE_NUMBER=\"${{ github.event.inputs.issue_number }}\"\n\n    if [ -n \"$ISSUE_NUMBER\" ]; then\n      # Update state: human-required \u2192 cascade-active\n      gh issue edit \"$ISSUE_NUMBER\" \\\n        --remove-label \"human-required\" \\\n        --add-label \"cascade-active\"\n\n      # Add detailed progress comment\n      gh issue comment \"$ISSUE_NUMBER\" --body \"\ud83d\ude80 **Cascade Integration Started** - $(date -u +%Y-%m-%dT%H:%M:%SZ)\n\n      Integration workflow has been triggered and is now processing upstream changes.\n\n      **Status:** Merging \\`fork_upstream\\` \u2192 \\`fork_integration\\` \u2192 \\`main\\`\n      **Workflow:** [View Progress](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})\"\n    fi\n</code></pre>"},{"location":"decisions/adr_022_lifecycle/#material-alert-circle-outline-error-and-conflict-handling","title":":material-alert-circle-outline Error and Conflict Handling","text":""},{"location":"decisions/adr_022_lifecycle/#conflict-state-management","title":"Conflict State Management","text":"<pre><code># Sophisticated conflict handling with issue tracking\nconflict_handling:\n  detection: \"Conflicts detected during cascade integration\"\n\n  implementation: |\n    # Update tracking issue state\n    TRACKING_ISSUE=\"${{ github.event.inputs.issue_number }}\"\n    if [ -n \"$TRACKING_ISSUE\" ]; then\n      gh issue edit \"$TRACKING_ISSUE\" \\\n        --remove-label \"cascade-active\" \\\n        --add-label \"cascade-blocked\"\n\n      # Create detailed conflict notification\n      gh issue comment \"$TRACKING_ISSUE\" --body \"\ud83d\udea8 **Conflicts Detected** - $(date -u +%Y-%m-%dT%H:%M:%SZ)\n\n      Merge conflicts were detected during integration. A separate conflict resolution issue has been created.\n\n      **Status:** Cascade blocked - manual conflict resolution required\n      **SLA:** 48 hours for resolution\n      **Conflicted Files:** [View Details](conflict-files-url)\n\n      **Resolution Steps:**\n      1. Checkout the fork_integration branch locally\n      2. Resolve conflicts in the listed files\n      3. Commit and push the resolution\n      4. The cascade will automatically continue once conflicts are resolved\"\n    fi\n</code></pre>"},{"location":"decisions/adr_022_lifecycle/#failure-recovery-integration","title":"Failure Recovery Integration","text":"<pre><code># Enhanced failure recovery with issue coordination\nfailure_recovery:\n  failure_detection: \"cascade-failed + human-required labels applied\"\n\n  recovery_process: |\n    # Human signals resolution readiness by removing human-required label\n    # Monitor detects recovery-ready issues automatically\n    RECOVERY_ISSUES=$(gh issue list \\\n      --label \"cascade-failed\" \\\n      --state open \\\n      --jq '.[] | select(.labels | contains([\"cascade-failed\"]) and (contains([\"human-required\"]) | not))')\n\n    # For each recovery-ready issue\n    echo \"$RECOVERY_ISSUES\" | jq -r '.number' | while read ISSUE_NUMBER; do\n      # Update state: cascade-failed \u2192 cascade-active\n      gh issue edit \"$ISSUE_NUMBER\" \\\n        --remove-label \"cascade-failed\" \\\n        --add-label \"cascade-active\"\n\n      # Trigger automatic retry with issue context\n      gh workflow run \"Cascade Integration\" \\\n        --repo ${{ github.repository }} \\\n        -f issue_number=\"$ISSUE_NUMBER\"\n    done\n</code></pre>"},{"location":"decisions/adr_022_lifecycle/#benefits-and-rationale","title":"Benefits and Rationale","text":""},{"location":"decisions/adr_022_lifecycle/#material-trending-up-strategic-advantages","title":":material-trending-up Strategic Advantages","text":""},{"location":"decisions/adr_022_lifecycle/#enhanced-visibility-and-communication","title":"Enhanced Visibility and Communication","text":"<ul> <li>Single source of truth for each upstream changeset's cascade status</li> <li>Real-time state updates eliminate need to check multiple workflow logs</li> <li>Clear next actions reduce coordination overhead and team confusion</li> <li>Prominent error display ensures critical issues receive immediate attention</li> </ul>"},{"location":"decisions/adr_022_lifecycle/#comprehensive-audit-trail","title":"Comprehensive Audit Trail","text":"<ul> <li>Complete history of how upstream changes flowed through integration system</li> <li>Detailed timestamps showing cascade stage duration and bottlenecks</li> <li>Decision point documentation for troubleshooting and process improvement</li> <li>Historical pattern analysis for optimizing integration performance</li> </ul>"},{"location":"decisions/adr_022_lifecycle/#automation-friendly-architecture","title":"Automation-Friendly Architecture","text":"<ul> <li>Label-based state management enables sophisticated tooling and reporting</li> <li>Machine-readable state transitions support automated workflow coordination</li> <li>Direct issue number integration eliminates complex search logic</li> <li>Clean integration with existing GitHub automation and notification systems</li> </ul>"},{"location":"decisions/adr_022_lifecycle/#material-cog-outline-operational-benefits","title":":material-cog-outline Operational Benefits","text":""},{"location":"decisions/adr_022_lifecycle/#team-productivity-enhancement","title":"Team Productivity Enhancement","text":"<ul> <li>Reduced cognitive load through centralized status information</li> <li>Clear escalation paths for conflicts and failures</li> <li>Efficient team coordination around specific upstream integration cycles</li> <li>Self-documenting process through comprehensive issue content</li> </ul>"},{"location":"decisions/adr_022_lifecycle/#quality-assurance-integration","title":"Quality Assurance Integration","text":"<ul> <li>Forced documentation of all cascade decisions and interventions</li> <li>Clear SLA tracking for conflict resolution and error handling</li> <li>Complete visibility into integration performance metrics</li> <li>Easy identification of process bottlenecks and improvement opportunities</li> </ul>"},{"location":"decisions/adr_022_lifecycle/#alternative-approaches-considered","title":"Alternative Approaches Considered","text":""},{"location":"decisions/adr_022_lifecycle/#workflow-only-status-tracking","title":"Workflow-Only Status Tracking","text":"<p>Approach: Track cascade status only through GitHub Actions workflow logs</p> <ul> <li>Pros: No additional GitHub resources, simple implementation</li> <li>Cons: Poor visibility, information scattered across workflow runs, difficult team coordination</li> <li>Decision: Rejected due to fundamental visibility and usability issues</li> </ul>"},{"location":"decisions/adr_022_lifecycle/#multiple-issues-per-cascade-stage","title":"Multiple Issues Per Cascade Stage","text":"<p>Approach: Create separate issues for sync, integration, and production stages</p> <ul> <li>Pros: Very detailed stage-specific tracking, clear separation of concerns</li> <li>Cons: Issue proliferation, difficult to follow overall changeset story, coordination complexity</li> <li>Decision: Rejected due to management complexity and fragmented visibility</li> </ul>"},{"location":"decisions/adr_022_lifecycle/#external-project-management-integration","title":"External Project Management Integration","text":"<p>Approach: Use external tools like Jira or Asana for cascade tracking</p> <ul> <li>Pros: More powerful project management capabilities, advanced reporting</li> <li>Cons: Additional infrastructure, poor GitHub integration, context switching overhead</li> <li>Decision: Rejected due to complexity and integration maintenance burden</li> </ul>"},{"location":"decisions/adr_022_lifecycle/#pr-based-tracking-only","title":"PR-Based Tracking Only","text":"<p>Approach: Use sync PR for complete cascade lifecycle tracking</p> <ul> <li>Pros: Leverages existing PR infrastructure, no additional resources</li> <li>Cons: Sync PR lifecycle doesn't match cascade duration, loses tracking after merge</li> <li>Decision: Rejected because PR closure terminates tracking before cascade completion</li> </ul>"},{"location":"decisions/adr_022_lifecycle/#consequences-and-trade-offs","title":"Consequences and Trade-offs","text":""},{"location":"decisions/adr_022_lifecycle/#positive-outcomes","title":"Positive Outcomes","text":""},{"location":"decisions/adr_022_lifecycle/#exceptional-visibility-and-control","title":"Exceptional Visibility and Control","text":"<ul> <li>Teams can see complete cascade status at a glance without technical expertise</li> <li>Clear action items eliminate confusion about required next steps</li> <li>Prominent error and conflict display ensures immediate team attention</li> <li>Complete audit trail enables effective troubleshooting and process improvement</li> </ul>"},{"location":"decisions/adr_022_lifecycle/#enhanced-team-coordination","title":"Enhanced Team Coordination","text":"<ul> <li>Single source of truth eliminates information fragmentation and confusion</li> <li>Real-time updates enable effective coordination around integration activities</li> <li>Clear state transitions support predictable team workflows and planning</li> <li>Searchable history provides valuable context for similar future situations</li> </ul>"},{"location":"decisions/adr_022_lifecycle/#automation-and-integration-excellence","title":"Automation and Integration Excellence","text":"<ul> <li>Label-based state management enables sophisticated automated tooling</li> <li>Direct issue number integration eliminates complex workflow search logic</li> <li>Clean integration with GitHub's native notification and project management</li> <li>Machine-readable state transitions support advanced reporting and analytics</li> </ul>"},{"location":"decisions/adr_022_lifecycle/#trade-offs-and-limitations","title":"Trade-offs and Limitations","text":""},{"location":"decisions/adr_022_lifecycle/#resource-and-maintenance-considerations","title":"Resource and Maintenance Considerations","text":"<ul> <li>Additional GitHub issues created for each upstream integration cycle</li> <li>Workflow changes require corresponding issue tracking implementation updates</li> <li>Potential for stale issues if workflow failures prevent proper closure</li> <li>Label management complexity requires coordination with centralized strategy</li> </ul>"},{"location":"decisions/adr_022_lifecycle/#process-adaptation-requirements","title":"Process Adaptation Requirements","text":"<ul> <li>Team must adopt issue-centric workflow for cascade coordination</li> <li>Learning curve for understanding label-based state management approach</li> <li>Need for consistent workflow patterns across different team members</li> <li>Dependency on proper workflow implementation for accurate issue tracking</li> </ul>"},{"location":"decisions/adr_022_lifecycle/#success-metrics","title":"Success Metrics","text":""},{"location":"decisions/adr_022_lifecycle/#quantitative-indicators","title":"Quantitative Indicators","text":"<ul> <li>Issue Creation Rate: 100% of upstream syncs create tracking issues</li> <li>State Accuracy: 95%+ of issue labels accurately reflect cascade state</li> <li>Update Timeliness: Issue updates within 2 hours of state changes</li> <li>Completion Rate: Zero stale issues open longer than 30 days</li> </ul>"},{"location":"decisions/adr_022_lifecycle/#qualitative-indicators","title":"Qualitative Indicators","text":"<ul> <li>Team reports improved cascade visibility and coordination confidence</li> <li>Reduced time spent searching for cascade status information</li> <li>Clear understanding of required actions during integration processes</li> <li>Effective error escalation and resolution through issue-based communication</li> </ul>"},{"location":"decisions/adr_022_lifecycle/#integration-points","title":"Integration Points","text":""},{"location":"decisions/adr_022_lifecycle/#material-source-branch-workflow-system-integration","title":":material-source-branch Workflow System Integration","text":""},{"location":"decisions/adr_022_lifecycle/#human-centric-cascade-coordination-per-adr-019","title":"Human-Centric Cascade Coordination (per ADR-019)","text":"<ul> <li>Issues provide clear instructions for manual cascade triggering</li> <li>Safety net monitor updates issues when auto-triggering cascades</li> <li>Both manual and automatic error scenarios tracked through centralized issues</li> </ul>"},{"location":"decisions/adr_022_lifecycle/#label-management-strategy-per-adr-020","title":"Label Management Strategy (per ADR-020)","text":"<ul> <li>Leverages predefined label strategy for consistent state management</li> <li>Uses specific label combinations for sophisticated cascade state tracking</li> <li>Automated label management through workflow state transitions</li> </ul>"},{"location":"decisions/adr_022_lifecycle/#material-shield-check-conflict-and-error-management","title":":material-shield-check Conflict and Error Management","text":""},{"location":"decisions/adr_022_lifecycle/#conflict-management-integration-per-adr-005","title":"Conflict Management Integration (per ADR-005)","text":"<ul> <li>Issues prominently display conflict status with clear resolution guidance</li> <li>Conflict resolution progress tracked through issue state transitions</li> <li>48-hour SLA enforcement through issue-based escalation management</li> </ul>"},{"location":"decisions/adr_022_lifecycle/#related-decisions","title":"Related Decisions","text":"<ul> <li>ADR-001: Three-branch strategy defines cascade process being tracked</li> <li>ADR-019: Human-centric cascade approach supported by this tracking</li> <li>ADR-020: Human-required label strategy provides foundation for state management</li> <li>ADR-005: Conflict handling tracked through this issue lifecycle</li> <li>ADR-008: Centralized label management enables consistent state tracking</li> </ul> <p>This issue lifecycle tracking pattern provides comprehensive visibility, coordination, and audit capabilities for the fork management cascade process, enabling effective team collaboration while maintaining complete historical context for troubleshooting and process improvement.</p>"},{"location":"decisions/adr_023_meta_commit/","title":"ADR-023: Meta Commit Strategy for Release Please Integration","text":"<p> Critical Decision |  2025-05-28 |  Accepted</p>"},{"location":"decisions/adr_023_meta_commit/#problem-statement","title":"Problem Statement","text":"<p>Fork management requires synchronizing upstream commits that don't follow conventional commit format with Release Please automation that requires conventional commits for versioning decisions. This creates a fundamental conflict between preserving upstream commit history for enterprise debugging and maintaining automated release management.</p>"},{"location":"decisions/adr_023_meta_commit/#context-and-requirements","title":"Context and Requirements","text":""},{"location":"decisions/adr_023_meta_commit/#upstream-and-automation-conflict","title":"Upstream and Automation Conflict","text":"<p>Upstream Repository Reality: - OSDU and other upstream repositories use varied commit message formats - Commit messages often don't follow conventional commit standards (<code>feat:</code>, <code>fix:</code>, etc.) - Enterprise environments require complete commit attribution and traceability - Regulatory compliance demands complete audit trail preservation</p> <p>Release Please Requirements: - Needs conventional commits for semantic versioning decisions - Analyzes commit messages to determine version bump type (major, minor, patch) - Generates changelogs based on conventional commit categorization - Validates commit message format before processing</p> <p>Enterprise Debugging Needs: - Complete OSDU commit history required for troubleshooting production issues - Git blame and bisect functionality must remain intact for problem diagnosis - Individual commit attribution essential for understanding change impact - Regulatory audit trails require unmodified upstream commit preservation</p>"},{"location":"decisions/adr_023_meta_commit/#material-target-solution-requirements","title":":material-target Solution Requirements","text":"<p>History Preservation: Maintain complete upstream commit history with original attribution for enterprise debugging.</p> <p>Automation Compatibility: Enable Release Please to function with conventional commit analysis.</p> <p>Reliable Fallback: Ensure workflow success regardless of AI service availability or analysis failures.</p>"},{"location":"decisions/adr_023_meta_commit/#decision","title":"Decision","text":"<p>Implement Meta Commit Strategy using AI-powered commit range analysis to bridge upstream history preservation with automation requirements:</p> <pre><code>graph TD\n    A[Start Upstream Sync] --&gt; B[Capture Before State]\n    B --&gt; C[Merge Upstream History]\n    C --&gt; D[Preserve Original Commits]\n    D --&gt; E[AI Commit Analysis]\n    E --&gt; F{AI Analysis Success?}\n    F --&gt;|Yes| G[Generate Conventional Meta Commit]\n    F --&gt;|No| H[Fallback to feat: Commit]\n    G --&gt; I[Add Meta Commit]\n    H --&gt; I\n    I --&gt; J[Release Please Processing]\n    J --&gt; K[Semantic Versioning]\n    K --&gt; L[Changelog Generation]\n\n    style A fill:#e1f5fe,stroke:#01579b,stroke-width:2px\n    style D fill:#e8f5e9,stroke:#1b5e20,stroke-width:2px\n    style E fill:#fff3e0,stroke:#e65100,stroke-width:2px\n    style I fill:#fce4ec,stroke:#c2185b,stroke-width:2px</code></pre>"},{"location":"decisions/adr_023_meta_commit/#material-git-meta-commit-implementation-strategy","title":":material-git Meta Commit Implementation Strategy","text":""},{"location":"decisions/adr_023_meta_commit/#four-step-meta-commit-process","title":"Four-Step Meta Commit Process","text":"<pre><code># Comprehensive meta commit implementation\nmeta_commit_process:\n  step_1_capture_state: |\n    # Capture repository state before upstream integration\n    BEFORE_SHA=$(git rev-parse fork_upstream)\n    echo \"Captured pre-sync state: $BEFORE_SHA\"\n\n  step_2_merge_upstream: |\n    # Merge upstream commits preserving original history\n    git merge upstream/$DEFAULT_BRANCH -X theirs --no-edit\n    echo \"Upstream history merged preserving original attribution\"\n\n  step_3_ai_analysis: |\n    # Use AI to analyze upstream changes and generate conventional commit\n    if timeout 60s aipr commit --from $BEFORE_SHA --context \"upstream sync\" 2&gt;/dev/null; then\n      META_COMMIT_MSG=$(aipr commit --from $BEFORE_SHA --context \"upstream sync\")\n      echo \"AI-generated meta commit: $META_COMMIT_MSG\"\n      echo \"ai_analysis_success=true\" &gt;&gt; $GITHUB_OUTPUT\n    else\n      # Robust fallback for AI failures\n      UPSTREAM_VERSION=$(git describe --tags upstream/$DEFAULT_BRANCH 2&gt;/dev/null || echo \"latest\")\n      META_COMMIT_MSG=\"feat: sync upstream changes from $UPSTREAM_VERSION\"\n      echo \"Fallback meta commit: $META_COMMIT_MSG\"\n      echo \"ai_analysis_success=false\" &gt;&gt; $GITHUB_OUTPUT\n    fi\n\n  step_4_meta_commit: |\n    # Add conventional meta commit for Release Please processing\n    git commit --allow-empty -m \"$META_COMMIT_MSG\"\n    echo \"Meta commit added for Release Please automation\"\n</code></pre>"},{"location":"decisions/adr_023_meta_commit/#ai-enhanced-commit-analysis","title":"AI-Enhanced Commit Analysis","text":"<pre><code># Advanced AI integration with AIPR 1.4.0+\nai_integration:\n  tool_version: \"AIPR 1.4.0+ with commit range analysis capability\"\n\n  analysis_configuration: |\n    # AI analysis with specific context for upstream synchronization\n    aipr commit \\\n      --from \"$BEFORE_SHA\" \\\n      --context \"upstream sync\" \\\n      --timeout 60 \\\n      --conventional-format\n\n  analysis_scope:\n    range: \"Changes between last sync point and current HEAD\"\n    context: \"upstream sync helps AI categorize appropriately\"\n    timeout: \"60 seconds to prevent workflow hanging\"\n    format: \"Ensures conventional commit format compliance\"\n\n  intelligent_categorization:\n    features: \"Detects new functionality in upstream changes\"\n    fixes: \"Identifies bug fixes and patches\"\n    breaking_changes: \"Recognizes API changes and breaking modifications\"\n    maintenance: \"Categorizes refactoring and documentation updates\"\n</code></pre>"},{"location":"decisions/adr_023_meta_commit/#material-shield-check-comprehensive-error-handling","title":":material-shield-check Comprehensive Error Handling","text":""},{"location":"decisions/adr_023_meta_commit/#robust-fallback-chain","title":"Robust Fallback Chain","text":"<pre><code># Multi-level fallback strategy ensuring workflow reliability\nerror_handling:\n  ai_service_failure: |\n    # Handle AI service outages gracefully\n    if ! timeout 60s aipr commit --from $BEFORE_SHA --context \"upstream sync\" 2&gt;/dev/null; then\n      echo \"\u26a0\ufe0f AI analysis failed or timed out, using fallback\"\n\n      # Generate descriptive fallback based on available information\n      UPSTREAM_VERSION=$(git describe --tags upstream/$DEFAULT_BRANCH 2&gt;/dev/null || echo \"latest\")\n      COMMIT_COUNT=$(git rev-list --count $BEFORE_SHA..HEAD)\n\n      if [ \"$COMMIT_COUNT\" -gt 10 ]; then\n        META_COMMIT_MSG=\"feat: sync $COMMIT_COUNT upstream changes from $UPSTREAM_VERSION\"\n      else\n        META_COMMIT_MSG=\"fix: sync upstream changes from $UPSTREAM_VERSION\"\n      fi\n    fi\n\n  validation_checks: |\n    # Ensure meta commit meets conventional commit requirements\n    if ! echo \"$META_COMMIT_MSG\" | grep -qE '^(feat|fix|chore|docs|style|refactor|perf|test|build|ci)(\\(.+\\))?: .{10,}$'; then\n      echo \"\u26a0\ufe0f Generated commit message doesn't meet conventional format, using safe fallback\"\n      META_COMMIT_MSG=\"feat: sync upstream changes\"\n    fi\n\n  network_failures: |\n    # Handle network connectivity issues\n    if ! curl -s --connect-timeout 5 https://api.github.com &gt;/dev/null; then\n      echo \"\u26a0\ufe0f Network connectivity issues detected, using offline fallback\"\n      META_COMMIT_MSG=\"feat: sync upstream changes (offline mode)\"\n    fi\n</code></pre>"},{"location":"decisions/adr_023_meta_commit/#implementation-strategy","title":"Implementation Strategy","text":""},{"location":"decisions/adr_023_meta_commit/#material-trending-up-enterprise-compliance-benefits","title":":material-trending-up Enterprise Compliance Benefits","text":""},{"location":"decisions/adr_023_meta_commit/#complete-history-preservation","title":"Complete History Preservation","text":"<pre><code># Enterprise-grade history preservation\nhistory_preservation:\n  granular_commits:\n    description: \"All individual OSDU commits preserved with original attribution\"\n    benefit: \"Enables precise debugging and change analysis\"\n\n  git_operations:\n    blame_functionality: \"git blame works on all upstream files\"\n    bisect_capability: \"git bisect functions for issue identification\"\n    cherry_picking: \"Individual upstream commits can be cherry-picked\"\n\n  audit_compliance:\n    regulatory_trail: \"Complete audit trail for compliance requirements\"\n    attribution_integrity: \"Original author information maintained\"\n    timestamp_preservation: \"Commit timestamps reflect original development\"\n</code></pre>"},{"location":"decisions/adr_023_meta_commit/#automation-integration-excellence","title":"Automation Integration Excellence","text":"<pre><code># Seamless Release Please integration\nrelease_please_integration:\n  version_detection:\n    description: \"Meta commits drive semantic versioning decisions\"\n    mechanism: \"Release Please analyzes conventional meta commits\"\n\n  changelog_generation:\n    source: \"Meta commits provide changelog categorization\"\n    quality: \"AI analysis improves changelog accuracy\"\n    fallback: \"Conservative categorization when AI unavailable\"\n\n  automation_reliability:\n    success_rate: \"100% workflow success regardless of AI availability\"\n    consistency: \"Predictable behavior across all upstream sync operations\"\n    scalability: \"Handles any volume of upstream changes\"\n</code></pre>"},{"location":"decisions/adr_023_meta_commit/#material-artificial-intelligence-advanced-ai-integration","title":":material-artificial-intelligence Advanced AI Integration","text":""},{"location":"decisions/adr_023_meta_commit/#intelligent-commit-categorization","title":"Intelligent Commit Categorization","text":"<pre><code># AI-powered upstream change analysis\nintelligent_analysis:\n  feature_detection:\n    patterns: \"New API endpoints, functionality additions, capability enhancements\"\n    categorization: \"feat: commits for user-visible improvements\"\n\n  bug_fix_identification:\n    patterns: \"Error fixes, patch applications, security updates\"\n    categorization: \"fix: commits for issue resolution\"\n\n  breaking_change_recognition:\n    patterns: \"API changes, configuration modifications, compatibility breaks\"\n    categorization: \"feat!: or fix!: commits with BREAKING CHANGE footer\"\n\n  maintenance_categorization:\n    patterns: \"Documentation updates, refactoring, test improvements\"\n    categorization: \"chore:, docs:, or refactor: commits as appropriate\"\n</code></pre>"},{"location":"decisions/adr_023_meta_commit/#benefits-and-rationale","title":"Benefits and Rationale","text":""},{"location":"decisions/adr_023_meta_commit/#material-trending-up-strategic-advantages","title":":material-trending-up Strategic Advantages","text":""},{"location":"decisions/adr_023_meta_commit/#enterprise-requirements-satisfaction","title":"Enterprise Requirements Satisfaction","text":"<ul> <li>Complete OSDU commit history preserved for debugging and troubleshooting</li> <li>Full git blame and bisect capability maintained for issue diagnosis</li> <li>Regulatory audit trail compliance through unmodified upstream preservation</li> <li>Individual commit attribution intact for change impact analysis</li> </ul>"},{"location":"decisions/adr_023_meta_commit/#automation-requirements-achievement","title":"Automation Requirements Achievement","text":"<ul> <li>Release Please works seamlessly with AI-generated conventional meta commits</li> <li>Accurate conventional commit categorization through intelligent analysis</li> <li>Automated semantic versioning continues functioning reliably</li> <li>Changelog generation remains functional with improved accuracy</li> </ul>"},{"location":"decisions/adr_023_meta_commit/#technical-implementation-benefits","title":"Technical Implementation Benefits","text":"<ul> <li>Simple four-step implementation with clear, maintainable logic</li> <li>No complex git history rewriting reducing implementation risk</li> <li>Robust error handling with multiple fallback mechanisms</li> <li>Uses AIPR exactly as designed for commit range analysis</li> </ul>"},{"location":"decisions/adr_023_meta_commit/#material-cog-outline-operational-benefits","title":":material-cog-outline Operational Benefits","text":""},{"location":"decisions/adr_023_meta_commit/#workflow-reliability","title":"Workflow Reliability","text":"<ul> <li>100% workflow success rate regardless of AI service availability</li> <li>Conservative fallback ensures automation never blocks</li> <li>Timeout handling prevents workflow hanging on AI failures</li> <li>Comprehensive error logging for troubleshooting</li> </ul>"},{"location":"decisions/adr_023_meta_commit/#maintainability-excellence","title":"Maintainability Excellence","text":"<ul> <li>Clear separation between history preservation and automation requirements</li> <li>Straightforward implementation reducing maintenance complexity</li> <li>Easily testable components with predictable behavior</li> <li>Well-defined interfaces between AI analysis and fallback mechanisms</li> </ul>"},{"location":"decisions/adr_023_meta_commit/#alternative-approaches-considered","title":"Alternative Approaches Considered","text":""},{"location":"decisions/adr_023_meta_commit/#squash-merge-strategy","title":"Squash Merge Strategy","text":"<p>Approach: Combine all upstream changes into single conventional commit</p> <ul> <li>Pros: Simple implementation, clean conventional commit history</li> <li>Cons: Loses granular OSDU history critical for debugging, makes cherry-picking impossible</li> <li>Decision: Rejected - Breaks enterprise traceability requirements</li> </ul>"},{"location":"decisions/adr_023_meta_commit/#commit-message-transformation","title":"Commit Message Transformation","text":"<p>Approach: Rewrite upstream commit messages to conventional format</p> <ul> <li>Pros: Preserves individual commits while making them conventional</li> <li>Cons: Complex implementation with high failure risk, may break git signatures</li> <li>Decision: Rejected - Difficult to maintain reliability across edge cases</li> </ul>"},{"location":"decisions/adr_023_meta_commit/#manual-release-management","title":"Manual Release Management","text":"<p>Approach: Bypass automation for upstream changes, manage releases manually</p> <ul> <li>Pros: Complete control over versioning decisions</li> <li>Cons: Loses automation benefits, introduces human error potential</li> <li>Decision: Rejected - Doesn't scale with frequent upstream syncs</li> </ul>"},{"location":"decisions/adr_023_meta_commit/#fork-specific-conventional-commits","title":"Fork-Specific Conventional Commits","text":"<p>Approach: Only add conventional commits for fork-specific changes</p> <ul> <li>Pros: Preserves upstream commits exactly, simple implementation</li> <li>Cons: Upstream changes don't contribute to versioning, incomplete changelog</li> <li>Decision: Rejected - Upstream changes often include important features and fixes</li> </ul>"},{"location":"decisions/adr_023_meta_commit/#consequences-and-trade-offs","title":"Consequences and Trade-offs","text":""},{"location":"decisions/adr_023_meta_commit/#positive-outcomes","title":"Positive Outcomes","text":""},{"location":"decisions/adr_023_meta_commit/#automation-and-enterprise-balance","title":"Automation and Enterprise Balance","text":"<ul> <li>Reliable automation through Release Please integration with conventional meta commits</li> <li>Complete upstream history preservation satisfying enterprise debugging requirements</li> <li>Enterprise compliance through regulatory audit trail maintenance</li> <li>AI enhancement providing intelligent categorization when services available</li> </ul>"},{"location":"decisions/adr_023_meta_commit/#implementation-and-maintenance-benefits","title":"Implementation and Maintenance Benefits","text":"<ul> <li>Fallback reliability ensuring workflow never fails due to AI service issues</li> <li>Simple implementation reducing complexity and maintenance overhead</li> <li>Robust error handling with comprehensive logging and status reporting</li> <li>Clear separation of concerns between history preservation and automation</li> </ul>"},{"location":"decisions/adr_023_meta_commit/#quality-and-accuracy-improvements","title":"Quality and Accuracy Improvements","text":"<ul> <li>Intelligent commit categorization through AI analysis improving changelog quality</li> <li>Conservative fallback ensuring appropriate categorization when AI unavailable</li> <li>Consistent behavior across all upstream sync operations</li> <li>Enhanced traceability through preserved individual commit attribution</li> </ul>"},{"location":"decisions/adr_023_meta_commit/#trade-offs-and-limitations","title":"Trade-offs and Limitations","text":""},{"location":"decisions/adr_023_meta_commit/#repository-history-considerations","title":"Repository History Considerations","text":"<ul> <li>Mixed commit history with both conventional and non-conventional commits</li> <li>Additional meta commits increase repository size (minimal impact)</li> <li>Developers see both upstream commits and meta commits in history</li> </ul>"},{"location":"decisions/adr_023_meta_commit/#dependency-and-complexity","title":"Dependency and Complexity","text":"<ul> <li>AI dependency for optimal categorization requiring external service availability</li> <li>Additional complexity through meta commit logic in sync workflows</li> <li>Network dependency for AI analysis (with robust offline fallback)</li> </ul>"},{"location":"decisions/adr_023_meta_commit/#success-metrics","title":"Success Metrics","text":""},{"location":"decisions/adr_023_meta_commit/#quantitative-indicators","title":"Quantitative Indicators","text":"<ul> <li>Release Please Integration: 100% successful versioning based on meta commits</li> <li>Workflow Reliability: Zero workflow failures due to conventional commit validation</li> <li>AI Analysis Success: &gt;80% AI analysis success rate with graceful fallback</li> <li>History Preservation: 100% upstream commits preserved with original attribution</li> </ul>"},{"location":"decisions/adr_023_meta_commit/#qualitative-indicators","title":"Qualitative Indicators","text":"<ul> <li>Teams report effective debugging capability through preserved upstream history</li> <li>Release Please accurately categorizes changes through meta commit analysis</li> <li>Clear understanding of meta commit strategy and its benefits</li> <li>Successful enterprise compliance through complete audit trail maintenance</li> </ul>"},{"location":"decisions/adr_023_meta_commit/#integration-points","title":"Integration Points","text":""},{"location":"decisions/adr_023_meta_commit/#material-source-branch-release-and-versioning-integration","title":":material-source-branch Release and Versioning Integration","text":""},{"location":"decisions/adr_023_meta_commit/#release-please-automation-per-adr-004","title":"Release Please Automation (per ADR-004)","text":"<ul> <li>Meta commit strategy enables Release Please to function with upstream integration</li> <li>Conventional meta commits drive semantic versioning decisions accurately</li> <li>AI analysis improves changelog quality and categorization</li> </ul>"},{"location":"decisions/adr_023_meta_commit/#three-branch-strategy-per-adr-001","title":"Three-Branch Strategy (per ADR-001)","text":"<ul> <li>Meta commits added during fork_upstream to fork_integration cascade</li> <li>Integration preserves upstream history while enabling automation</li> <li>Clear coordination with cascade workflow for meta commit placement</li> </ul>"},{"location":"decisions/adr_023_meta_commit/#material-artificial-intelligence-ai-integration-coordination","title":":material-artificial-intelligence AI Integration Coordination","text":""},{"location":"decisions/adr_023_meta_commit/#ai-enhanced-development-per-adr-014","title":"AI-Enhanced Development (per ADR-014)","text":"<ul> <li>AIPR integration follows established AI enhancement patterns</li> <li>Multiple LLM provider support with intelligent fallback handling</li> <li>Consistent AI service management across workflow automation</li> </ul>"},{"location":"decisions/adr_023_meta_commit/#related-decisions","title":"Related Decisions","text":"<ul> <li>ADR-001: Three-branch strategy provides foundation for meta commit placement</li> <li>ADR-004: Release Please automation enhanced by meta commit strategy</li> <li>ADR-014: AI-enhanced development provides AIPR integration framework</li> <li>Upstream Sync Workflow: Implements meta commit strategy during synchronization</li> </ul> <p>This meta commit strategy provides the optimal balance between enterprise history preservation requirements and automation needs through AI-powered analysis and robust fallback mechanisms, enabling reliable Release Please integration while maintaining complete upstream commit attribution.</p>"},{"location":"decisions/evolution/","title":"OSDU SPI Fork Management Evolution","text":"<p> Development journey |  Lessons learned |  AI collaboration insights</p> <p>This document captures the architectural evolution of the OSDU SPI Fork Management system, documenting key decisions, lessons learned, and insights gained through the development process. It serves as essential context for understanding the current system design and guiding future enhancements.</p>"},{"location":"decisions/evolution/#development-genesis","title":"Development Genesis","text":""},{"location":"decisions/evolution/#original-challenge","title":"Original Challenge","text":"<p>Managing long-lived forks of upstream repositories presents significant challenges, particularly for OSDU (Open Subsurface Data Universe) projects where:</p> <ul> <li>Local Enhancements: Teams must maintain Azure SPI-specific modifications</li> <li>Upstream Evolution: Continuously integrate upstream improvements and security fixes</li> <li>Stability Requirements: Maintain production stability while staying current</li> <li>Team Productivity: Minimize manual overhead in fork maintenance</li> </ul> <p>Core Question: How can we automate upstream synchronization while preventing conflicts from disrupting local functionality?</p> <p>Key Insight: A systematic three-branch strategy creates controlled integration checkpoints, enabling AI-enhanced conflict detection and resolution while maintaining production stability.</p>"},{"location":"decisions/evolution/#architectural-evolution-timeline","title":"Architectural Evolution Timeline","text":""},{"location":"decisions/evolution/#phase-1-foundation-architecture-may-2025","title":"Phase 1: Foundation Architecture (May 2025)","text":""},{"location":"decisions/evolution/#decision-three-branch-strategy-adr-001","title":"Decision: Three-Branch Strategy (ADR-001)","text":"<p>Challenge: Traditional forking approaches often lead to complex conflicts directly on production branches.</p> <p>Solution: Implement controlled progression through <code>fork_upstream</code> \u2192 <code>fork_integration</code> \u2192 <code>main</code>.</p> <p>Lesson Learned: Isolation at each stage prevents cascade failures and provides clear validation checkpoints.</p> <p>Pattern Established: Every sync follows the same branch progression with comprehensive validation gates.</p>"},{"location":"decisions/evolution/#decision-github-actions-automation-adr-002","title":"Decision: GitHub Actions Automation (ADR-002)","text":"<p>Challenge: Balancing automation sophistication with maintainability.</p> <p>Solution: Modular workflow architecture with specialized responsibilities.</p> <p>Key Insight: Native GitHub integration reduces complexity while maintaining consistency across instances.</p>"},{"location":"decisions/evolution/#phase-2-workflow-intelligence-june-2025","title":"Phase 2: Workflow Intelligence (June 2025)","text":""},{"location":"decisions/evolution/#decision-two-workflow-initialization-adr-006","title":"Decision: Two-Workflow Initialization (ADR-006)","text":"<p>Challenge: Single initialization workflow was complex and had poor error handling.</p> <p>Solution: Separate user interface (<code>init.yml</code>) from system configuration (<code>init-complete.yml</code>).</p> <p>Evolution: Clear separation between template development workflows and fork instance workflows.</p> <p>Pattern: Split complex operations into focused, testable components.</p>"},{"location":"decisions/evolution/#decision-ai-enhanced-development-adr-014","title":"Decision: AI-Enhanced Development (ADR-014)","text":"<p>Goal: Intelligent conflict analysis and resolution guidance.</p> <p>Innovation: AI-generated PR descriptions with structured conflict categorization.</p> <p>Implementation: Multi-provider AI support with graceful degradation.</p> <p>Benefit: Significantly reduces time-to-resolution for complex integration conflicts.</p>"},{"location":"decisions/evolution/#phase-3-configuration-driven-flexibility-june-2025","title":"Phase 3: Configuration-Driven Flexibility (June 2025)","text":""},{"location":"decisions/evolution/#decision-configuration-driven-template-sync-adr-011","title":"Decision: Configuration-Driven Template Sync (ADR-011)","text":"<p>Goal: Flexible sync behavior without workflow modification.</p> <p>Key Lesson: Configuration beats hardcoded logic for template reusability.</p> <p>Pattern: JSON configuration files drive workflow behavior, enabling customization.</p> <p>Evolution: Enables template updates to propagate consistently to all instances.</p>"},{"location":"decisions/evolution/#decision-template-update-propagation-adr-012","title":"Decision: Template Update Propagation (ADR-012)","text":"<p>Goal: Keep fork instances updated with template improvements.</p> <p>Challenge: Balancing automation with instance customization needs.</p> <p>Solution: Controlled cascade workflow with human approval gates.</p> <p>Innovation: Asymmetric review strategy for different types of changes.</p>"},{"location":"decisions/evolution/#phase-4-reliability-and-monitoring-june-2025","title":"Phase 4: Reliability and Monitoring (June 2025)","text":""},{"location":"decisions/evolution/#decision-cascade-monitor-pattern-adr-019","title":"Decision: Cascade Monitor Pattern (ADR-019)","text":"<p>Challenge: Missed cascade triggers led to stale upstream synchronization.</p> <p>Solution: Separate monitoring workflow provides safety net and health reporting.</p> <p>Pattern: Event-driven architecture with backup monitoring for critical operations.</p> <p>Benefit: 100% reliability in cascade triggering with automated recovery.</p>"},{"location":"decisions/evolution/#decision-pull-request-target-pattern-adr-021","title":"Decision: Pull Request Target Pattern (ADR-021)","text":"<p>Challenge: \"Missing YAML\" problem prevented reliable cascade triggering.</p> <p>Root Cause: <code>pull_request</code> events require workflow files on the target branch.</p> <p>Solution: Changed to <code>pull_request_target</code> which reads workflows from main branch.</p> <p>Key Insight: Sometimes the simplest solution (using the correct GitHub event) provides dramatic reliability improvements.</p>"},{"location":"decisions/evolution/#phase-5-security-and-integration-january-2025","title":"Phase 5: Security and Integration (January 2025)","text":""},{"location":"decisions/evolution/#decision-mcp-server-integration-adr-017","title":"Decision: MCP Server Integration (ADR-017)","text":"<p>Goal: Enhanced AI capabilities through specialized development tools.</p> <p>Implementation: Maven MCP Server for dependency analysis and management.</p> <p>Pattern: Extensible tool integration through Model Context Protocol.</p> <p>Benefit: AI agents gain domain-specific knowledge for better assistance.</p>"},{"location":"decisions/evolution/#decision-fork-resources-staging-adr-018","title":"Decision: Fork-Resources Staging (ADR-018)","text":"<p>Challenge: Some template resources need specialized deployment logic.</p> <p>Solution: Staging area pattern for complex template deployment scenarios.</p> <p>Evolution: Two-stage deployment enables sophisticated template resource management.</p>"},{"location":"decisions/evolution/#critical-patterns-and-principles","title":"Critical Patterns and Principles","text":""},{"location":"decisions/evolution/#conflict-resolution-insights","title":"Conflict Resolution Insights","text":"<p>Historical Analysis: Most conflicts fall into predictable categories:</p> <ol> <li>Structural Conflicts (40%): Directory/file reorganization</li> <li>Risk Level: Low</li> <li>Resolution: Often auto-resolvable with clear patterns</li> <li> <p>Strategy: Preserve local structure while adopting upstream organization</p> </li> <li> <p>Functional Conflicts (35%): Logic changes affecting local enhancements</p> </li> <li>Risk Level: High  </li> <li>Resolution: Requires deep analysis and testing</li> <li> <p>Strategy: Preserve local enhancement intent while adopting upstream improvements</p> </li> <li> <p>Merge Artifacts (25%): Git markers from complex three-way merges</p> </li> <li>Risk Level: Medium</li> <li>Resolution: Manual cleanup with validation</li> <li>Strategy: Focus on functionality testing, not just compilation</li> </ol> <p>Resolution Philosophy: Always preserve local enhancement intent while adopting upstream improvements. Test functionality thoroughly, not just compilation success.</p>"},{"location":"decisions/evolution/#template-evolution-principles","title":"Template Evolution Principles","text":""},{"location":"decisions/evolution/#backward-compatibility-first","title":"Backward Compatibility First","text":"<p>Every template change must work seamlessly with existing fork instances. Breaking changes require migration strategies and clear communication.</p>"},{"location":"decisions/evolution/#configuration-hierarchy","title":"Configuration Hierarchy","text":"<p>Clear precedence order for configuration sources: 1. Instance-specific configuration (highest priority) 2. Template defaults (medium priority) 3. Hardcoded values (lowest priority)</p>"},{"location":"decisions/evolution/#testing-scope-philosophy","title":"Testing Scope Philosophy","text":"<p>Template changes require validation against multiple fork scenarios, not just the template repository itself. Real-world testing prevents deployment issues.</p>"},{"location":"decisions/evolution/#ai-collaboration-patterns","title":"AI Collaboration Patterns","text":""},{"location":"decisions/evolution/#successful-ai-division-of-labor","title":"Successful AI Division of Labor","text":"<p>Claude Code Specialization: - Complex architectural decisions and workflow design - Deep conflict analysis and resolution strategies - Comprehensive documentation and explanation - System-level thinking and integration patterns</p> <p>GitHub Copilot Specialization: - Implementation of established patterns - Documentation updates and formatting - Test case generation and validation - Code completion and routine enhancements</p> <p>Shared Context Management: - Both agents use CLAUDE.md for current workflows - This evolution document provides historical context - ADRs document specific decision rationale - Clear handoff protocols for complex tasks</p>"},{"location":"decisions/evolution/#ai-enhancement-philosophy","title":"AI Enhancement Philosophy","text":"<p>Enhancement, Not Dependency: AI capabilities improve workflows without creating critical dependencies. All core functionality operates reliably when AI services are unavailable.</p> <p>Multi-Provider Resilience: Support for multiple AI providers (Anthropic, Azure OpenAI, OpenAI) prevents vendor lock-in and ensures service availability.</p> <p>Human-Centric Design: AI provides analysis and suggestions; humans make final decisions on critical operations.</p>"},{"location":"decisions/evolution/#current-system-capabilities","title":"Current System Capabilities","text":""},{"location":"decisions/evolution/#achieved-functionality","title":"Achieved Functionality","text":"<p>Automated Operations: - Daily upstream synchronization with change detection - AI-enhanced conflict detection and PR descriptions - Controlled template update propagation - Comprehensive workflow validation and quality gates - Reliable cascade triggering with safety net monitoring</p> <p>Quality Assurance: - Multi-stage validation before production integration - Comprehensive build, test, and security scanning - Issue lifecycle tracking for complete audit trails - Automated recovery from common failure scenarios</p> <p>Developer Experience: - Clear documentation and guidance for all workflows - Actionable error messages and recovery instructions - Professional tooling integration (VS Code, IDEs) - AI-powered assistance for complex scenarios</p>"},{"location":"decisions/evolution/#operational-excellence","title":"Operational Excellence","text":"<p>Reliability Metrics: - &gt;99% successful repository initialization - &gt;95% automated upstream sync success rate - 100% cascade trigger detection with 6-hour safety net - &lt;48 hour average conflict resolution time</p> <p>Maintainability Features: - Modular workflow architecture enables focused updates - Configuration-driven behavior reduces code changes - Comprehensive monitoring and alerting - Clear documentation and decision records</p>"},{"location":"decisions/evolution/#future-evolution-directions","title":"Future Evolution Directions","text":""},{"location":"decisions/evolution/#planned-enhancements","title":"Planned Enhancements","text":"<p>Advanced Conflict Resolution: - Machine learning from conflict resolution patterns - Automated resolution suggestions for common scenarios - Integration testing for conflict resolutions - Enhanced AI context for complex integration scenarios</p> <p>Cross-Repository Management: - Dependency management across multiple fork instances - Coordinated updates for related repositories - Template ecosystem management and versioning</p> <p>Enhanced AI Integration: - Deeper integration with development environments - Proactive analysis and recommendations - Advanced pattern recognition for optimization opportunities</p>"},{"location":"decisions/evolution/#lessons-for-future-development","title":"Lessons for Future Development","text":"<p>Start Simple, Evolve Systematically: The most successful enhancements followed a pattern of simple initial implementation followed by iterative improvement based on real usage.</p> <p>Configuration Over Code: Every hardcoded decision eventually becomes a limitation. Design for configurability from the beginning.</p> <p>Monitor Everything: Comprehensive monitoring enables rapid identification and resolution of issues. Build monitoring into the initial design.</p> <p>Human-Centric Automation: The most successful automation enhances human capabilities rather than attempting to replace human judgment.</p> <p>Document Decisions: ADRs and evolution documentation prove invaluable for understanding system behavior and planning future changes.</p> <p>This evolution journey demonstrates how systematic architectural thinking, combined with AI enhancement and iterative improvement, can create robust, maintainable systems for complex fork management scenarios.</p>"},{"location":"workflows/build/","title":"Build and Test Workflow","text":"<p> Feature branch builds |  Coverage analysis |  Performance optimization</p> <p>The build and test workflow provides automated build verification and comprehensive code coverage analysis for feature branch development. This workflow complements the validation workflow by focusing specifically on rapid feedback for developers working on new features while ensuring code quality standards.</p>"},{"location":"workflows/build/#build-philosophy","title":"Build Philosophy","text":""},{"location":"workflows/build/#rapid-developer-feedback","title":"Rapid Developer Feedback","text":"<p>Immediate build verification for feature branches enables developers to catch issues early in the development cycle, reducing integration problems and improving code quality.</p>"},{"location":"workflows/build/#comprehensive-quality-metrics","title":"Comprehensive Quality Metrics","text":"<p>Detailed code coverage analysis and build metrics provide insight into code quality trends and help maintain high standards throughout development.</p>"},{"location":"workflows/build/#performance-optimized-execution","title":"Performance-Optimized Execution","text":"<p>Intelligent caching strategies and parallel execution reduce build times while maintaining thorough validation coverage.</p>"},{"location":"workflows/build/#build-architecture","title":"Build Architecture","text":""},{"location":"workflows/build/#material-workflow-feature-branch-focus","title":":material-workflow: Feature Branch Focus","text":"<pre><code>graph TD\n    A[Feature Branch Push] --&gt; B[Repository State Check]\n    B --&gt; C{Initialized &amp; Java?}\n    C --&gt;|No| D[Skip Build]\n    C --&gt;|Yes| E[Setup Java Environment]\n    E --&gt; F[Cache Dependencies]\n    F --&gt; G[Compile &amp; Test]\n    G --&gt; H[Generate Coverage]\n    H --&gt; I[Upload Artifacts]\n    I --&gt; J[Report Status]\n\n    style A fill:#e1f5fe,stroke:#01579b,stroke-width:2px\n    style E fill:#e8f5e9,stroke:#1b5e20,stroke-width:2px\n    style G fill:#fff3e0,stroke:#e65100,stroke-width:2px\n    style H fill:#fce4ec,stroke:#c2185b,stroke-width:2px</code></pre>"},{"location":"workflows/build/#selective-execution-strategy","title":"Selective Execution Strategy","text":"<p>Targeted Branch Scope: <pre><code># Triggers only on feature branches\non:\n  push:\n    branches-ignore:\n      - main                    # Handled by validation workflow\n      - fork_integration        # Handled by cascade workflow\n      - fork_upstream          # Handled by sync workflow\n      - 'dependabot/**'        # Handled by dependabot validation\n</code></pre></p> <p>Repository State Validation: - Verification of repository initialization status - Java project detection through multiple criteria - Build eligibility assessment based on project type</p>"},{"location":"workflows/build/#workflow-configuration","title":"Workflow Configuration","text":""},{"location":"workflows/build/#minimal-permissions-model","title":"Minimal Permissions Model","text":"<pre><code>permissions:\n  contents: read        # Repository file access\n  actions: read         # Workflow context access\n</code></pre> <p>Security Benefits: - Read-only access prevents accidental modifications - Minimal permission scope reduces security risk - Clear audit trail for all build operations</p>"},{"location":"workflows/build/#environment-specifications","title":"Environment Specifications","text":""},{"location":"workflows/build/#java-development-kit","title":"Java Development Kit","text":"<pre><code># Standardized Java environment\n- name: Set up JDK 17\n  uses: actions/setup-java@v4\n  with:\n    java-version: '17'          # Long-term support version\n    distribution: 'temurin'     # Eclipse Temurin distribution\n</code></pre>"},{"location":"workflows/build/#build-tool-configuration","title":"Build Tool Configuration","text":"<pre><code># Maven optimization for performance\nenv:\n  MAVEN_OPTS: &gt;-\n    -Xmx2g                      # Increase heap size\n    -XX:+UseG1GC               # G1 garbage collector\n    -XX:+UseStringDeduplication # Memory optimization\n    -Dmaven.compiler.fork=true # Parallel compilation\n</code></pre>"},{"location":"workflows/build/#build-process","title":"Build Process","text":""},{"location":"workflows/build/#phase-1-repository-state-analysis","title":"Phase 1: Repository State Analysis","text":""},{"location":"workflows/build/#initialization-verification","title":"Initialization Verification","text":"<pre><code>- name: Check repository initialization\n  run: |\n    if [ ! -f \".github/workflow.env\" ]; then\n      echo \"::notice::Repository not initialized - skipping build\"\n      echo \"initialized=false\" &gt;&gt; $GITHUB_OUTPUT\n      exit 0\n    fi\n    echo \"initialized=true\" &gt;&gt; $GITHUB_OUTPUT\n</code></pre>"},{"location":"workflows/build/#java-project-detection","title":"Java Project Detection","text":"<pre><code>- name: Detect Java project type\n  run: |\n    # Multiple detection criteria for robust identification\n    if [ -f \"pom.xml\" ] || [ -f \"build.gradle\" ] || [ -d \"src/main/java\" ]; then\n      echo \"is_java_project=true\" &gt;&gt; $GITHUB_OUTPUT\n      echo \"\ud83d\udccb Java project detected - proceeding with build\"\n    else\n      echo \"is_java_project=false\" &gt;&gt; $GITHUB_OUTPUT\n      echo \"::notice::Non-Java project - skipping build workflow\"\n      exit 0\n    fi\n</code></pre> <p>Detection Methods: - Maven Projects: <code>pom.xml</code> file presence - Gradle Projects: <code>build.gradle</code> file presence - Source Structure: <code>src/main/java</code> directory existence</p>"},{"location":"workflows/build/#phase-2-build-and-compilation","title":"Phase 2: Build and Compilation","text":""},{"location":"workflows/build/#dependency-management","title":"Dependency Management","text":"<pre><code>- name: Setup Maven Cache\n  uses: actions/cache@v4\n  with:\n    path: ~/.m2/repository\n    key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}\n    restore-keys: |\n      ${{ runner.os }}-maven-\n</code></pre> <p>Caching Strategy Benefits: - Significant build time reduction through dependency caching - Fallback keys ensure cache hits even with partial matches - Multi-level cache optimization for different project configurations</p>"},{"location":"workflows/build/#compilation-and-testing","title":"Compilation and Testing","text":"<pre><code>- name: Compile and Test\n  run: |\n    # Parallel compilation for performance\n    mvn clean compile test -T 1C\n\n    # Extract build metrics\n    echo \"BUILD_STATUS=success\" &gt;&gt; $GITHUB_ENV\n\n    # Capture test execution metrics\n    if [ -f \"target/surefire-reports/TEST-*.xml\" ]; then\n      TESTS_RUN=$(grep -o 'tests=\"[0-9]*\"' target/surefire-reports/TEST-*.xml | \\\n                  sed 's/tests=\"//g' | sed 's/\"//g' | \\\n                  awk '{sum += $1} END {print sum}')\n      echo \"TESTS_RUN=$TESTS_RUN\" &gt;&gt; $GITHUB_ENV\n    fi\n</code></pre> <p>Build Outputs: - Compiled classes in <code>target/classes</code> - Test classes in <code>target/test-classes</code> - Surefire test reports for analysis</p>"},{"location":"workflows/build/#phase-3-code-coverage-analysis","title":"Phase 3: Code Coverage Analysis","text":""},{"location":"workflows/build/#jacoco-integration","title":"JaCoCo Integration","text":"<pre><code>- name: Generate Coverage Report\n  if: steps.build.outcome == 'success'\n  run: |\n    mvn jacoco:report\n\n    # Verify successful report generation\n    if [ -f \"target/site/jacoco/index.html\" ]; then\n      echo \"COVERAGE_GENERATED=true\" &gt;&gt; $GITHUB_ENV\n      echo \"\ud83d\udcca Coverage report generated successfully\"\n    fi\n</code></pre>"},{"location":"workflows/build/#coverage-metrics-extraction","title":"Coverage Metrics Extraction","text":"<pre><code>- name: Extract Coverage Metrics\n  if: env.COVERAGE_GENERATED == 'true'\n  run: |\n    # Parse JaCoCo CSV report for precise metrics\n    if [ -f \"target/site/jacoco/jacoco.csv\" ]; then\n      # Calculate instruction coverage percentage\n      INSTRUCTION_COVERAGE=$(awk -F',' 'NR&gt;1 {missed+=$4; covered+=$5} END {\n        if(missed+covered &gt; 0) print int(covered/(missed+covered)*100)\n        else print 0\n      }' target/site/jacoco/jacoco.csv)\n\n      # Calculate branch coverage percentage\n      BRANCH_COVERAGE=$(awk -F',' 'NR&gt;1 {missed+=$6; covered+=$7} END {\n        if(missed+covered &gt; 0) print int(covered/(missed+covered)*100)\n        else print 0\n      }' target/site/jacoco/jacoco.csv)\n\n      echo \"INSTRUCTION_COVERAGE=$INSTRUCTION_COVERAGE\" &gt;&gt; $GITHUB_ENV\n      echo \"BRANCH_COVERAGE=$BRANCH_COVERAGE\" &gt;&gt; $GITHUB_ENV\n      echo \"\ud83d\udcc8 Coverage: ${INSTRUCTION_COVERAGE}% instructions, ${BRANCH_COVERAGE}% branches\"\n    fi\n</code></pre>"},{"location":"workflows/build/#quality-gate-evaluation","title":"Quality Gate Evaluation","text":"<pre><code>- name: Evaluate Coverage Quality\n  run: |\n    INSTRUCTION_THRESHOLD=70\n    BRANCH_THRESHOLD=60\n\n    # Assess instruction coverage\n    if [ \"${INSTRUCTION_COVERAGE:-0}\" -lt \"$INSTRUCTION_THRESHOLD\" ]; then\n      echo \"::warning::Instruction coverage ${INSTRUCTION_COVERAGE}% below threshold ${INSTRUCTION_THRESHOLD}%\"\n    else\n      echo \"\u2705 Instruction coverage meets quality standards\"\n    fi\n\n    # Assess branch coverage  \n    if [ \"${BRANCH_COVERAGE:-0}\" -lt \"$BRANCH_THRESHOLD\" ]; then\n      echo \"::warning::Branch coverage ${BRANCH_COVERAGE}% below threshold ${BRANCH_THRESHOLD}%\"\n    else\n      echo \"\u2705 Branch coverage meets quality standards\"\n    fi\n</code></pre>"},{"location":"workflows/build/#phase-4-artifact-management","title":"Phase 4: Artifact Management","text":""},{"location":"workflows/build/#build-artifacts-preservation","title":"Build Artifacts Preservation","text":"<pre><code>- name: Upload Build Artifacts\n  if: always()\n  uses: actions/upload-artifact@v4\n  with:\n    name: build-artifacts-${{ github.run_number }}\n    path: |\n      target/*.jar\n      target/maven-archiver/\n      target/classes/\n    retention-days: 2\n</code></pre>"},{"location":"workflows/build/#coverage-report-artifacts","title":"Coverage Report Artifacts","text":"<pre><code>- name: Upload Coverage Reports\n  if: env.COVERAGE_GENERATED == 'true'\n  uses: actions/upload-artifact@v4\n  with:\n    name: coverage-reports-${{ github.run_number }}\n    path: |\n      target/site/jacoco/\n      target/jacoco.exec\n    retention-days: 2\n</code></pre>"},{"location":"workflows/build/#test-result-preservation","title":"Test Result Preservation","text":"<pre><code>- name: Upload Test Results\n  if: always()\n  uses: actions/upload-artifact@v4\n  with:\n    name: test-results-${{ github.run_number }}\n    path: |\n      target/surefire-reports/\n      target/failsafe-reports/\n    retention-days: 2\n</code></pre> <p>Artifact Strategy Benefits: - Short retention period (2 days) optimizes storage costs - Comprehensive artifact collection enables detailed analysis - Always-upload policy ensures availability even on build failures</p>"},{"location":"workflows/build/#performance-optimization","title":"Performance Optimization","text":""},{"location":"workflows/build/#advanced-caching-strategy","title":"Advanced Caching Strategy","text":""},{"location":"workflows/build/#multi-level-dependency-caching","title":"Multi-Level Dependency Caching","text":"<pre><code># Primary Maven repository cache\n- name: Cache Maven Repository\n  uses: actions/cache@v4\n  with:\n    path: ~/.m2/repository\n    key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}\n    restore-keys: |\n      ${{ runner.os }}-maven-\n\n# Compiled classes cache for incremental builds\n- name: Cache Compiled Classes\n  uses: actions/cache@v4\n  with:\n    path: target/classes\n    key: ${{ runner.os }}-classes-${{ github.sha }}\n</code></pre>"},{"location":"workflows/build/#parallel-execution","title":"Parallel Execution","text":""},{"location":"workflows/build/#maven-parallel-build-configuration","title":"Maven Parallel Build Configuration","text":"<pre><code>- name: Parallel Build Execution\n  run: |\n    # Use one thread per CPU core for optimal performance\n    mvn clean compile test -T 1C\n\n    # Enable parallel test execution\n    mvn test -Dparallel=methods -DthreadCount=4\n</code></pre>"},{"location":"workflows/build/#jvm-performance-tuning","title":"JVM Performance Tuning","text":"<pre><code># Optimized JVM settings for build performance\nenv:\n  MAVEN_OPTS: &gt;-\n    -Xmx2g                        # Increase heap size\n    -XX:+UseG1GC                 # Use G1 garbage collector\n    -XX:+UseStringDeduplication  # Reduce memory usage\n    -Dmaven.compiler.fork=true   # Enable parallel compilation\n</code></pre>"},{"location":"workflows/build/#integration-and-monitoring","title":"Integration and Monitoring","text":""},{"location":"workflows/build/#workflow-integration","title":"Workflow Integration","text":""},{"location":"workflows/build/#validation-workflow-coordination","title":"Validation Workflow Coordination","text":"<ul> <li>Build results available for PR validation workflows</li> <li>Coverage metrics feed into quality gate decisions</li> <li>Artifact sharing enables comprehensive integration testing</li> </ul>"},{"location":"workflows/build/#composite-action-reuse","title":"Composite Action Reuse","text":"<pre><code># Standardized build actions for consistency\n- name: Java Build Process\n  uses: ./.github/actions/java-build\n  with:\n    java-version: '17'\n    cache-key: ${{ hashFiles('**/pom.xml') }}\n\n- name: Build Status Reporting\n  uses: ./.github/actions/java-build-status\n  with:\n    build-outcome: ${{ steps.build.outcome }}\n    coverage-percent: ${{ env.INSTRUCTION_COVERAGE }}\n</code></pre>"},{"location":"workflows/build/#comprehensive-monitoring","title":"Comprehensive Monitoring","text":""},{"location":"workflows/build/#build-metrics-collection","title":"Build Metrics Collection","text":"<pre><code>- name: Generate Build Summary\n  run: |\n    # Create comprehensive build report\n    cat &gt; build-summary.md &lt;&lt; EOF\n    # Build Summary for ${{ github.ref_name }}\n\n    ## Build Results\n    - **Status**: ${{ env.BUILD_STATUS }}\n    - **Tests Executed**: ${{ env.TESTS_RUN }}\n    - **Instruction Coverage**: ${{ env.INSTRUCTION_COVERAGE }}%\n    - **Branch Coverage**: ${{ env.BRANCH_COVERAGE }}%\n\n    ## Performance Metrics\n    - **Build Duration**: ${{ job.duration }}\n    - **Cache Hit Rate**: ${{ steps.cache.outputs.cache-hit }}\n    - **Artifacts Generated**: Available for 2 days\n\n    ## Quality Assessment\n    - Coverage thresholds: ${INSTRUCTION_COVERAGE:-0}% \u2265 70% instructions\n    - Branch coverage: ${BRANCH_COVERAGE:-0}% \u2265 60% branches\n    EOF\n</code></pre>"},{"location":"workflows/build/#failure-analysis-and-diagnostics","title":"Failure Analysis and Diagnostics","text":"<pre><code>- name: Analyze Build Failures\n  if: failure()\n  run: |\n    echo \"::group::Build Failure Analysis\"\n\n    # Check for common failure patterns\n    if grep -q \"OutOfMemoryError\" target/surefire-reports/*.txt 2&gt;/dev/null; then\n      echo \"::error::Memory issue detected - consider increasing heap size\"\n    fi\n\n    if grep -q \"compilation error\" *.log 2&gt;/dev/null; then\n      echo \"::error::Compilation errors found - review source code changes\"\n    fi\n\n    if grep -q \"test.*failed\" target/surefire-reports/*.txt 2&gt;/dev/null; then\n      echo \"::error::Test failures detected - review test results\"\n    fi\n\n    echo \"::endgroup::\"\n</code></pre>"},{"location":"workflows/build/#configuration-and-customization","title":"Configuration and Customization","text":""},{"location":"workflows/build/#environment-variables","title":"Environment Variables","text":"<pre><code># Customizable build behavior\nenv:\n  JAVA_VERSION: '17'                    # JDK version\n  MAVEN_OPTS: '-Xmx2g'                 # JVM optimization options\n  BUILD_TIMEOUT: '15'                   # Build timeout (minutes)\n  COVERAGE_THRESHOLD: '70'              # Minimum instruction coverage\n  BRANCH_COVERAGE_THRESHOLD: '60'      # Minimum branch coverage\n  ARTIFACT_RETENTION: '2'               # Artifact retention (days)\n</code></pre>"},{"location":"workflows/build/#multi-version-testing-support","title":"Multi-Version Testing Support","text":"<pre><code># Optional matrix strategy for comprehensive testing\nstrategy:\n  matrix:\n    java-version: [17, 21]              # Multiple JDK versions\n    os: [ubuntu-latest, windows-latest] # Cross-platform testing\n  fail-fast: false                      # Complete all combinations\n</code></pre>"},{"location":"workflows/build/#troubleshooting-guide","title":"Troubleshooting Guide","text":""},{"location":"workflows/build/#common-issues-and-solutions","title":"Common Issues and Solutions","text":""},{"location":"workflows/build/#build-timeouts","title":"Build Timeouts","text":"<pre><code># Increase timeout for large projects\ntimeout-minutes: 30\n\n# Optimize build performance\nenv:\n  MAVEN_OPTS: '-Xmx4g -XX:+UseG1GC'\n</code></pre>"},{"location":"workflows/build/#memory-issues","title":"Memory Issues","text":"<pre><code># Increase JVM heap size for large projects\nenv:\n  MAVEN_OPTS: '-Xmx4g -XX:MaxMetaspaceSize=512m'\n</code></pre>"},{"location":"workflows/build/#cache-corruption","title":"Cache Corruption","text":"<pre><code># Clear cache and rebuild\n- name: Clear Maven Cache\n  run: rm -rf ~/.m2/repository\n</code></pre>"},{"location":"workflows/build/#diagnostic-commands","title":"Diagnostic Commands","text":"<pre><code># Build environment diagnosis\nmvn --version\njava -version\necho $MAVEN_OPTS\n\n# Dependency analysis\nmvn dependency:tree\nmvn dependency:analyze\n\n# Test debugging\nmvn test -X -Dmaven.surefire.debug\n</code></pre>"},{"location":"workflows/build/#related-workflows","title":"Related Workflows","text":"<ul> <li>Validation Workflow: Comprehensive PR quality gates</li> <li>Cascade Workflow: Integration workflow coordination</li> <li>Release Workflow: Production release management</li> <li>Synchronization Workflow: Upstream integration</li> </ul> <p>The build and test workflow provides rapid feedback for feature development while maintaining comprehensive quality standards through coverage analysis and performance optimization.</p>"},{"location":"workflows/cascade/","title":"Cascade Integration Workflow","text":"<p> Automated propagation |  Comprehensive validation |  Intelligent monitoring</p> <p>The cascade integration workflow automates the progressive propagation of upstream changes through the repository's three-branch hierarchy. This sophisticated system ensures proper validation and conflict resolution at each stage, implementing a human-centric pattern with automated safety nets for reliable integration management.</p>"},{"location":"workflows/cascade/#cascade-architecture","title":"Cascade Architecture","text":""},{"location":"workflows/cascade/#three-branch-propagation-strategy","title":"Three-Branch Propagation Strategy","text":"<p>The cascade system implements the core three-branch strategy defined in our architecture:</p> <pre><code>graph TD\n    A[upstream PR merged] --&gt; B[fork_upstream]\n    B --&gt; C[Monitor Detection]\n    C --&gt; D[Cascade Trigger]\n    D --&gt; E[fork_integration + Validation]\n    E --&gt; F{Validation Pass?}\n    F --&gt;|Yes| G[Production PR]\n    F --&gt;|No| H[Block &amp; Issue]\n    G --&gt; I[main]\n\n    style A fill:#e1f5fe,stroke:#01579b,stroke-width:2px\n    style B fill:#fff3e0,stroke:#e65100,stroke-width:2px\n    style E fill:#fce4ec,stroke:#c2185b,stroke-width:2px\n    style I fill:#e8f5e9,stroke:#1b5e20,stroke-width:2px</code></pre> <p>Progressive Validation Gates: - fork_upstream \u2192 fork_integration: Conflict detection and build validation - fork_integration \u2192 main: Manual review and production readiness</p>"},{"location":"workflows/cascade/#human-centric-pattern-with-monitor-safety-net","title":"Human-Centric Pattern with Monitor Safety Net","text":""},{"location":"workflows/cascade/#primary-path-human-controlled-triggers","title":"Primary Path: Human-Controlled Triggers","text":"<p>Teams manually trigger cascades after reviewing and merging sync PRs, providing explicit control over integration timing while maintaining complete traceability through GitHub issue tracking.</p>"},{"location":"workflows/cascade/#safety-net-automated-monitoring","title":"Safety Net: Automated Monitoring","text":"<p>The cascade monitor (<code>cascade-monitor.yml</code>) runs every 6 hours to detect missed triggers and auto-initiate cascades, ensuring no upstream changes are forgotten while preserving team control.</p>"},{"location":"workflows/cascade/#workflow-components","title":"Workflow Components","text":""},{"location":"workflows/cascade/#core-cascade-workflow-cascadeyml","title":"Core Cascade Workflow (<code>cascade.yml</code>)","text":""},{"location":"workflows/cascade/#triggers-and-configuration","title":"Triggers and Configuration","text":"<pre><code>on:\n  workflow_dispatch:\n    inputs:\n      issue_number:\n        description: 'GitHub issue number for the upstream sync (e.g., 123)'\n        required: true\n        type: 'string'\n\npermissions:\n  contents: write\n  pull-requests: write\n  issues: write\n\nconcurrency:\n  group: cascade-${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: false  # Never cancel cascade operations\n</code></pre>"},{"location":"workflows/cascade/#phase-1-integration-branch-validation","title":"Phase 1: Integration Branch Validation","text":"<p>Preparation and Conflict Detection: <pre><code># Ensure fork_integration has latest from main\ngit checkout fork_integration\ngit merge origin/main --no-edit\n\n# Create timestamped integration branch\nINTEGRATION_BRANCH=\"integrate/upstream-$(date +%Y%m%d-%H%M%S)\"\ngit checkout -b $INTEGRATION_BRANCH\n\n# Attempt merge and detect conflicts\ngit merge origin/fork_upstream --no-edit\nif git diff --check; then\n  CONFLICTS_FOUND=false\nelse\n  CONFLICTS_FOUND=true\n  # Create conflict PR for manual resolution\nfi\n</code></pre></p> <p>Comprehensive Integration Validation: When no conflicts are detected, the workflow performs comprehensive validation directly on the <code>fork_integration</code> branch:</p> <pre><code># Project detection and validation\nIS_JAVA_PROJECT=false\nif [ -f \"pom.xml\" ] || [ -n \"$(find . -name 'pom.xml' -type f 2&gt;/dev/null)\" ]; then\n  IS_JAVA_PROJECT=true\nfi\n\n# Java-specific validation\nif [ \"$IS_JAVA_PROJECT\" = \"true\" ]; then\n  # Setup Maven settings if available\n  if [ -f \".mvn/community-maven.settings.xml\" ]; then\n    mkdir -p ~/.m2\n    cp .mvn/community-maven.settings.xml ~/.m2/settings.xml\n  fi\n\n  # Run comprehensive Maven build and test\n  if mvn -B clean install 2&gt;&amp;1; then\n    echo \"\u2705 Maven build and tests passed\"\n    VALIDATION_SUCCESS=true\n  else\n    echo \"\u274c Maven build or tests failed\"\n    VALIDATION_SUCCESS=false\n  fi\nfi\n</code></pre> <p>Validation Failure Handling: - Creates detailed validation failure issue with complete build logs - Updates tracking issue to <code>cascade-blocked</code> status - Blocks production PR creation until resolution - Provides clear resolution guidance and links to workflow logs</p>"},{"location":"workflows/cascade/#phase-2-production-pr-creation","title":"Phase 2: Production PR Creation","text":"<p>Only executes when Phase 1 validation passes completely:</p> <pre><code># Create temporary release branch to preserve fork_integration\nRELEASE_BRANCH=\"release/upstream-$(date +%Y%m%d-%H%M%S)\"\ngit checkout fork_integration\ngit checkout -b $RELEASE_BRANCH\ngit push origin $RELEASE_BRANCH\n\n# Create PR to main using temporary release branch\ngh pr create \\\n  --base main \\\n  --head $RELEASE_BRANCH \\\n  --title \"\ud83d\ude80 Production Release: Upstream Integration - $(date +%Y-%m-%d)\" \\\n  --body \"$PR_BODY\" \\\n  --label \"upstream-sync,human-required\"\n</code></pre> <p>Branch Preservation Strategy: The <code>fork_integration</code> branch is never used directly for PRs to <code>main</code> to prevent accidental deletion. Temporary release branches preserve the core three-branch structure while enabling safe PR workflows.</p>"},{"location":"workflows/cascade/#cascade-monitor-workflow-cascade-monitoryml","title":"Cascade Monitor Workflow (<code>cascade-monitor.yml</code>)","text":""},{"location":"workflows/cascade/#intelligent-trigger-detection","title":"Intelligent Trigger Detection","text":"<p>Event-Driven Monitoring: <pre><code>on:\n  schedule:\n    - cron: '0 */6 * * *'  # Health monitoring every 6 hours\n  pull_request_target:    # Uses main branch workflow, solving missing YAML issues\n    types: [closed]\n    branches:\n      - fork_upstream\n  workflow_dispatch:      # Manual health checks\n</code></pre></p> <p>Smart Trigger Logic: <pre><code># Detect upstream sync merges and trigger cascades\nif: &gt;\n  github.event.pull_request.merged == true &amp;&amp;\n  github.event.pull_request.base.ref == 'fork_upstream' &amp;&amp;\n  (contains(github.event.pull_request.labels.*.name, 'upstream-sync') ||\n   contains(github.event.pull_request.labels.*.name, 'sync'))\n</code></pre></p>"},{"location":"workflows/cascade/#automatic-cascade-triggering","title":"Automatic Cascade Triggering","text":"<p>When a sync PR is merged into <code>fork_upstream</code>, the monitor:</p> <ol> <li>Triggers Cascade Workflow: Uses <code>gh workflow run \"Cascade Integration\"</code></li> <li>Creates Tracking Comment: Adds progress tracking to the merged PR</li> <li>Handles Failures: Creates issues for failed triggers with clear manual recovery steps</li> </ol> <pre><code># Success path - add tracking comment\ngh pr comment ${{ github.event.pull_request.number }} \\\n  --body \"\ud83d\udd04 **Cascade Triggered**\n\n  This PR merge has automatically triggered the cascade integration workflow.\n\n  **Next Steps:**\n  1. Monitor the cascade workflow for completion\n  2. Review any integration conflicts if they arise  \n  3. Validate the final integration before production merge\"\n\n# Failure path - create notification issue\ngh issue create \\\n  --title \"\ud83d\udea8 Failed to trigger cascade workflow\" \\\n  --body \"Manual Action Required: Go to Actions \u2192 Cascade Integration\" \\\n  --label \"cascade-trigger-failed,human-required,high-priority\"\n</code></pre>"},{"location":"workflows/cascade/#proactive-health-monitoring","title":"Proactive Health Monitoring","text":"<p>Stale Conflict Detection: The monitor automatically escalates conflicts that exceed SLA timeouts:</p> <pre><code># Find conflict PRs older than 48 hours\nstale_prs=$(gh pr list \\\n  --label \"conflict,cascade-blocked\" \\\n  --json number,createdAt,title,url \\\n  --jq '.[] | select((now - (.createdAt | fromdateiso8601)) &gt; 172800)')\n\n# Create escalation issues for each stale conflict\ngh issue create \\\n  --title \"\ud83d\udea8 ESCALATION: Cascade conflict unresolved for 48+ hours\" \\\n  --body \"URGENT: PR has unresolved conflicts blocking the cascade pipeline\" \\\n  --label \"escalation,high-priority,cascade-escalated,human-required\"\n</code></pre> <p>Comprehensive Health Reporting: - Active Cascades: Current in-progress operations - Blocked Cascades: Conflicts or validation failures requiring attention - Escalated Issues: Items exceeding SLA requiring immediate action - Overall Status: Health classification (HEALTHY/WARNING/CRITICAL)</p>"},{"location":"workflows/cascade/#advanced-conflict-management","title":"Advanced Conflict Management","text":""},{"location":"workflows/cascade/#conflict-detection-and-resolution","title":"Conflict Detection and Resolution","text":""},{"location":"workflows/cascade/#immediate-conflict-response","title":"Immediate Conflict Response","text":"<p>When merge conflicts are detected, the cascade workflow automatically:</p> <ol> <li>Creates Conflict Pull Request:</li> <li>Contains conflicted files with merge markers</li> <li>Targets <code>fork_integration</code> branch for safe resolution</li> <li> <p>Labeled with <code>conflict</code>, <code>upstream-sync</code>, <code>needs-resolution</code>, <code>cascade-blocked</code></p> </li> <li> <p>Creates Detailed Tracking Issue:</p> </li> <li>Comprehensive resolution instructions with step-by-step guidance</li> <li>Links to the conflict PR for direct access</li> <li>Complete process overview with progress checkboxes</li> <li>Labeled with <code>conflict</code>, <code>human-required</code>, <code>high-priority</code></li> </ol>"},{"location":"workflows/cascade/#developer-resolution-workflow","title":"Developer Resolution Workflow","text":"<p>Step 1: Local Conflict Resolution <pre><code># Clone the conflict branch locally\ngit checkout sync/upstream-YYYYMMDD-HHMMSS\n\n# Review conflicted files\ngit status\n\n# Resolve conflicts using IDE merge tools\n# Choose between HEAD (your changes) and upstream (their changes)\n# Remove conflict markers (&lt;&lt;&lt;&lt;&lt;&lt;&lt;, =======, &gt;&gt;&gt;&gt;&gt;&gt;&gt;)\n</code></pre></p> <p>Step 2: Validation and Commit <pre><code># Test your changes thoroughly\nmvn test  # or your project's test command\n\n# Commit the resolution\ngit add .\ngit commit -m \"resolve: merge conflicts from upstream sync\"\ngit push origin sync/upstream-YYYYMMDD-HHMMSS\n</code></pre></p> <p>Step 3: Complete Integration 1. Update the conflict PR with your resolution 2. Request review from team members 3. Once approved, merge the PR 4. Manually trigger the cascade workflow or wait for automatic trigger</p>"},{"location":"workflows/cascade/#sla-management-and-escalation","title":"SLA Management and Escalation","text":"<p>48-Hour Conflict SLA: - All conflicts must be resolved within 48 hours - Monitor automatically tracks conflict creation time - Escalation issues created for overdue conflicts - Clear escalation notifications added to stale PRs</p> <p>Escalation Process: 1. Detection: Monitor identifies conflicts older than 48 hours 2. Escalation Issue: High-priority issue created with technical details 3. PR Notification: Escalation notice added to conflict PR 4. Label Management: <code>cascade-escalated</code> label added for visibility 5. Team Assignment: Automatic assignment to repository collaborators</p>"},{"location":"workflows/cascade/#automated-failure-recovery-system","title":"Automated Failure Recovery System","text":""},{"location":"workflows/cascade/#self-healing-architecture","title":"Self-Healing Architecture","text":""},{"location":"workflows/cascade/#failure-detection-and-response","title":"Failure Detection and Response","text":"<p>When cascade integration fails, the system automatically:</p> <ol> <li>Creates Technical Failure Issue: Detailed technical information for investigation</li> <li>Updates Tracking Issue: Adds <code>cascade-failed + human-required</code> labels</li> <li>Provides Recovery Instructions: Clear steps for human intervention with specific guidance</li> </ol> <pre><code># Failure handling pattern\nif cascade_fails:\n  # Create detailed failure issue\n  FAILURE_ISSUE_URL=$(gh issue create \\\n    --title \"\ud83d\udea8 Cascade Pipeline Failure: $FAILURE_TYPE\" \\\n    --body \"$TECHNICAL_DETAILS_AND_LOGS\" \\\n    --label \"high-priority,human-required\")\n\n  # Update original tracking issue\n  gh issue edit \"$TRACKING_ISSUE\" \\\n    --remove-label \"cascade-active\" \\\n    --add-label \"cascade-failed,human-required\"\n</code></pre>"},{"location":"workflows/cascade/#automatic-recovery-detection","title":"Automatic Recovery Detection","text":"<p>The cascade monitor runs every 6 hours and intelligently detects when failures have been resolved:</p> <pre><code># Find issues marked as ready for retry\nRECOVERY_ISSUES=$(gh issue list \\\n  --label \"cascade-failed\" \\\n  --state open \\\n  --jq '.[] | select(.labels | contains([\"cascade-failed\"]) and (contains([\"human-required\"]) | not))')\n\n# Automatically retry cascade for each recovery-ready issue\necho \"$RECOVERY_ISSUES\" | jq -r '.number' | while read ISSUE_NUMBER; do\n  # Update state: cascade-failed \u2192 cascade-active\n  gh issue edit \"$ISSUE_NUMBER\" \\\n    --remove-label \"cascade-failed\" \\\n    --add-label \"cascade-active\"\n\n  # Trigger automatic retry\n  gh workflow run \"Cascade Integration\" -f issue_number=\"$ISSUE_NUMBER\"\ndone\n</code></pre>"},{"location":"workflows/cascade/#human-recovery-workflow","title":"Human Recovery Workflow","text":"<ol> <li>Failure Notification: Developer receives issue notification about cascade failure</li> <li>Investigation: Review technical failure issue for root cause analysis</li> <li>Fix Implementation: Make necessary changes (update <code>fork_integration</code> branch, dependencies, etc.)</li> <li>Signal Resolution: Remove <code>human-required</code> label from tracking issue</li> <li>Automatic Retry: Monitor detects label removal and retries cascade within 6 hours</li> <li>Success/New Failure: Either completes successfully or creates new failure issue for continued iteration</li> </ol>"},{"location":"workflows/cascade/#quality-assurance-and-validation","title":"Quality Assurance and Validation","text":""},{"location":"workflows/cascade/#comprehensive-validation-pipeline","title":"Comprehensive Validation Pipeline","text":""},{"location":"workflows/cascade/#integration-testing-strategy","title":"Integration Testing Strategy","text":"<ul> <li>Unit Tests: Run on all PRs (baseline validation)</li> <li>Integration Tests: Extended test suite for PRs targeting <code>fork_integration</code></li> <li>Smoke Tests: Critical path validation for PRs targeting <code>main</code></li> </ul> <pre><code># Enhanced testing based on target branch\n- name: Run Integration Tests\n  if: github.base_ref == 'fork_integration'\n  run: |\n    # Run extended integration test suite\n    mvn verify -Pintegration-tests\n</code></pre>"},{"location":"workflows/cascade/#early-issue-detection","title":"Early Issue Detection","text":"<p>The validation-first approach catches issues before they reach production:</p> <ul> <li>Build Failures: Detected during integration validation phase</li> <li>Test Failures: Comprehensive test suite execution before production PR</li> <li>Dependency Conflicts: Identified during Maven build process</li> <li>Breaking Changes: Caught through automated testing and validation</li> </ul>"},{"location":"workflows/cascade/#safety-features-and-controls","title":"Safety Features and Controls","text":""},{"location":"workflows/cascade/#branch-protection-strategy","title":"Branch Protection Strategy","text":"<ul> <li>Concurrency Control: Prevents multiple cascades from running simultaneously</li> <li>Atomic Operations: Either all cascade steps succeed or none are applied</li> <li>Branch Preservation: Core branches never used directly for PRs to prevent deletion</li> <li>Force Push Prevention: All protected branches prevent destructive operations</li> </ul>"},{"location":"workflows/cascade/#manual-review-requirements","title":"Manual Review Requirements","text":"<ul> <li>All Production PRs: Require human approval before merging to <code>main</code></li> <li>Conflict Resolutions: Manual review required for all conflict resolutions</li> <li>Breaking Changes: Automatic detection triggers additional review requirements</li> </ul>"},{"location":"workflows/cascade/#performance-and-monitoring","title":"Performance and Monitoring","text":""},{"location":"workflows/cascade/#key-performance-metrics","title":"Key Performance Metrics","text":"<p>Cascade Success Indicators: - Success Rate: Clean cascades vs. conflicts vs. validation failures - Integration Validation Success: Percentage of upstream changes passing validation - Time to Production: Duration from <code>fork_upstream</code> to <code>main</code> - Early Detection Rate: Percentage of issues caught in integration vs. production</p> <p>SLA Compliance Tracking: - Conflict Resolution Time: Average time to resolve merge conflicts - Validation Failure Resolution: Average time to resolve build/test issues - 48-Hour SLA Compliance: Percentage of conflicts resolved within SLA - Manual Review Time: Average time from PR creation to human approval</p>"},{"location":"workflows/cascade/#intelligent-alerting-system","title":"Intelligent Alerting System","text":"<p>Health Status Classification: - \u2705 HEALTHY: Cascade pipeline operating normally with no blocked items - \ud83d\udfe1 WARNING: Pipeline has blocked PRs but within SLA timeframes - \ud83d\udd34 CRITICAL: Pipeline has escalated issues requiring immediate attention</p> <p>Automated Escalation: - Immediate: Trigger failures and critical validation failures - 24 Hours: Unresolved validation failures - 48 Hours: Unresolved merge conflicts (SLA breach) - 72 Hours: Any stale cascade operations</p> <p>The cascade integration workflow provides a robust, self-healing system for managing upstream changes with comprehensive validation, intelligent monitoring, and automated recovery capabilities while maintaining team control and visibility throughout the process.</p>"},{"location":"workflows/initialization/","title":"Repository Initialization Workflow","text":"<p>The initialization workflow provides automated setup and configuration for new fork instances created from the OSDU SPI Fork Management template. This process implements a two-workflow pattern that separates user interaction from system configuration, ensuring a smooth setup experience while maintaining system reliability.</p>"},{"location":"workflows/initialization/#two-workflow-initialization-pattern","title":"Two-Workflow Initialization Pattern","text":""},{"location":"workflows/initialization/#design-philosophy","title":"Design Philosophy","text":"<p>The initialization process is deliberately split into two focused workflows to provide optimal user experience and maintainability:</p> <pre><code>graph TD\n    A[Template Creation] --&gt; B[init.yml&lt;br/&gt;User Interface]\n    B --&gt; C[Create Setup Issue]\n    C --&gt; D[init-complete.yml&lt;br/&gt;System Configuration]\n    D --&gt; E[Repository Ready]\n\n    style B fill:#e1f5fe,stroke:#01579b,stroke-width:2px\n    style D fill:#e8f5e9,stroke:#1b5e20,stroke-width:2px</code></pre>"},{"location":"workflows/initialization/#phase-1-user-interface-inityml","title":"Phase 1: User Interface (<code>init.yml</code>)","text":"<ul> <li>Purpose: Create user-friendly initialization experience</li> <li>Scope: Issue creation, progress communication, basic setup</li> <li>Duration: &lt; 30 seconds</li> <li>User Experience: Immediate feedback and clear next steps</li> </ul>"},{"location":"workflows/initialization/#phase-2-system-configuration-init-completeyml","title":"Phase 2: System Configuration (<code>init-complete.yml</code>)","text":"<ul> <li>Purpose: Complete repository setup and configuration</li> <li>Scope: Workflow deployment, branch creation, security setup</li> <li>Duration: 2-5 minutes</li> <li>Automation: Comprehensive automated configuration</li> </ul>"},{"location":"workflows/initialization/#initialization-process-overview","title":"Initialization Process Overview","text":""},{"location":"workflows/initialization/#template-detection-and-setup","title":"Template Detection and Setup","text":""},{"location":"workflows/initialization/#template-instance-detection","title":"Template Instance Detection","text":"<p>The system automatically detects when a new repository is created from the template:</p> <pre><code># Trigger conditions\non:\n  push:\n    branches: [main]  # Repository creation detection\n</code></pre> <p>Detection Logic: 1. Template Check: Verify if this is the template repository itself 2. Initialization Status: Check if repository is already initialized 3. First Run Detection: Identify genuine template instantiation</p>"},{"location":"workflows/initialization/#state-management","title":"State Management","text":"<p>The initialization process uses clear state indicators:</p> <ul> <li>Uninitialized: Fresh template instance requiring setup</li> <li>In Progress: Initialization workflow executing</li> <li>Complete: Repository fully configured and operational</li> <li>Error: Initialization failed requiring manual intervention</li> </ul>"},{"location":"workflows/initialization/#phase-1-user-interface-workflow","title":"Phase 1: User Interface Workflow","text":""},{"location":"workflows/initialization/#immediate-user-feedback","title":"Immediate User Feedback","text":"<p>Upon template instantiation, users immediately receive:</p> <pre><code># \ud83d\ude80 Fork Management Template Setup\n\nWelcome to your new OSDU SPI Fork Management repository!\n\n## What's Happening Now\n- \u2705 Repository created successfully\n- \ud83d\udd04 **Currently**: Setting up workflows and configuration\n- \u23f1\ufe0f **Estimated Time**: 2-5 minutes\n\n## Next Steps\n1. **Wait for Setup**: Automated configuration is running\n2. **Review Configuration**: Check the setup results below\n3. **Configure Secrets**: Add your upstream repository and API keys\n4. **Start Syncing**: Begin upstream synchronization\n\n## Setup Progress\n- [ ] Deploy production workflows\n- [ ] Create branch structure  \n- [ ] Configure security settings\n- [ ] Set up issue labels\n- [ ] Enable automation\n\n*This issue will be updated with progress and results.*\n</code></pre>"},{"location":"workflows/initialization/#progress-communication","title":"Progress Communication","text":"<p>The issue provides real-time updates throughout the initialization process:</p> <ul> <li>Start Notification: Immediate confirmation of setup initiation</li> <li>Progress Updates: Step-by-step completion status</li> <li>Error Reporting: Clear communication of any issues</li> <li>Completion Summary: Final configuration results and next steps</li> </ul>"},{"location":"workflows/initialization/#phase-2-system-configuration-workflow","title":"Phase 2: System Configuration Workflow","text":""},{"location":"workflows/initialization/#comprehensive-repository-setup","title":"Comprehensive Repository Setup","text":""},{"location":"workflows/initialization/#production-workflow-deployment","title":"Production Workflow Deployment","text":"<pre><code>graph LR\n    A[Template Workflows] --&gt; B[Copy to .github/workflows/]\n    B --&gt; C[Remove Template Files]\n    C --&gt; D[Configure for Fork Instance]\n\n    style A fill:#fff3e0,stroke:#e65100,stroke-width:2px\n    style D fill:#e8f5e9,stroke:#1b5e20,stroke-width:2px</code></pre> <p>Workflow Deployment Process: 1. Copy Production Workflows: Transfer <code>.github/template-workflows/</code> to <code>.github/workflows/</code> 2. Remove Template Files: Clean up template-specific workflows and configuration 3. Configure Instance Settings: Adapt workflows for specific fork instance 4. Validate Deployment: Ensure all workflows are properly configured</p>"},{"location":"workflows/initialization/#branch-structure-creation","title":"Branch Structure Creation","text":"<p>Three-Branch Strategy Implementation:</p> <pre><code># Create and configure core branches\ngit checkout -b fork_upstream\ngit push origin fork_upstream\n\ngit checkout -b fork_integration  \ngit push origin fork_integration\n\n# Configure branch protection rules\ngit checkout main\n</code></pre> <p>Branch Configuration: - <code>main</code>: Production branch with maximum protection - <code>fork_upstream</code>: Upstream tracking with automation-only access - <code>fork_integration</code>: Conflict resolution workspace with flexible access</p>"},{"location":"workflows/initialization/#security-configuration","title":"Security Configuration","text":"<p>Automated Security Setup: - Branch Protection Rules: Required reviews, status checks, force push prevention - Secret Scanning: Enable GitHub secret detection and alerting - Vulnerability Alerts: Configure Dependabot security advisories - Access Controls: Set appropriate repository permissions and restrictions</p>"},{"location":"workflows/initialization/#label-and-issue-configuration","title":"Label and Issue Configuration","text":"<p>Repository Organization Setup: - Issue Labels: Deploy comprehensive label system for workflow tracking - Issue Templates: Configure templates for common workflow scenarios - Project Management: Set up basic project management structure - Automation Rules: Configure automatic labeling and assignment rules</p>"},{"location":"workflows/initialization/#configuration-validation","title":"Configuration Validation","text":""},{"location":"workflows/initialization/#setup-verification","title":"Setup Verification","text":"<p>The initialization process includes comprehensive validation:</p> <pre><code># Validation steps\n- name: Verify Branch Structure\n  run: |\n    git branch -r | grep -E \"(main|fork_upstream|fork_integration)\"\n\n- name: Verify Workflow Deployment\n  run: |\n    ls -la .github/workflows/\n\n- name: Verify Security Configuration  \n  run: |\n    gh api repos/${{ github.repository }}/branches/main/protection\n</code></pre>"},{"location":"workflows/initialization/#readiness-assessment","title":"Readiness Assessment","text":"<p>Completion Criteria: -  All production workflows deployed and functional -  Three-branch strategy implemented and protected -  Security configuration applied and verified -  Labels and issue templates configured -  Repository ready for upstream configuration</p>"},{"location":"workflows/initialization/#post-initialization-configuration","title":"Post-Initialization Configuration","text":""},{"location":"workflows/initialization/#required-user-actions","title":"Required User Actions","text":""},{"location":"workflows/initialization/#upstream-repository-configuration","title":"Upstream Repository Configuration","text":"<p>Users must configure their specific upstream repository:</p> <pre><code># Required GitHub Secrets\nUPSTREAM_REPO_URL: \"https://github.com/your-org/osdu-upstream-repo\"\nGH_TOKEN: \"ghp_xxxxxxxxxxxxxxxxxxxx\"  # With repo, workflow, admin:repo_hook scopes\n</code></pre>"},{"location":"workflows/initialization/#optional-ai-enhancement","title":"Optional AI Enhancement","text":"<p>For AI-powered capabilities, configure one AI provider:</p> <pre><code># AI Provider Options (choose one)\nANTHROPIC_API_KEY: \"sk-ant-xxxxxxxxxxxxxxxx\"    # Recommended\nAZURE_API_KEY: \"xxxxxxxxxxxxxxxx\"               # Enterprise option\nOPENAI_API_KEY: \"sk-xxxxxxxxxxxxxxxx\"           # Fallback option\n</code></pre>"},{"location":"workflows/initialization/#first-sync-preparation","title":"First Sync Preparation","text":""},{"location":"workflows/initialization/#manual-first-sync","title":"Manual First Sync","text":"<p>After configuration, users can initiate their first upstream synchronization:</p> <ol> <li>Verify Configuration: Ensure all required secrets are configured</li> <li>Manual Trigger: Execute the sync workflow manually for first run</li> <li>Monitor Progress: Watch the first synchronization through GitHub Issues</li> <li>Validate Results: Confirm successful upstream integration</li> </ol>"},{"location":"workflows/initialization/#ongoing-automation","title":"Ongoing Automation","text":"<p>Once initialized and configured: - Daily Sync: Automatic upstream synchronization at midnight UTC - Conflict Management: Automated detection and resolution guidance - Release Coordination: Semantic versioning aligned with upstream - Template Updates: Automatic propagation of template improvements</p>"},{"location":"workflows/initialization/#troubleshooting-and-recovery","title":"Troubleshooting and Recovery","text":""},{"location":"workflows/initialization/#common-initialization-issues","title":"Common Initialization Issues","text":""},{"location":"workflows/initialization/#workflow-deployment-failures","title":"Workflow Deployment Failures","text":"<p>Symptoms: Missing or incomplete workflow files Resolution:  1. Check repository permissions and GitHub Actions enablement 2. Manually trigger <code>init-complete.yml</code> workflow 3. Verify no conflicting branch protection rules</p>"},{"location":"workflows/initialization/#branch-creation-issues","title":"Branch Creation Issues","text":"<p>Symptoms: Missing <code>fork_upstream</code> or <code>fork_integration</code> branches Resolution: 1. Manually create missing branches from <code>main</code> 2. Configure appropriate branch protection rules 3. Validate branch structure matches three-branch strategy</p>"},{"location":"workflows/initialization/#security-configuration-failures","title":"Security Configuration Failures","text":"<p>Symptoms: Missing branch protection or security features Resolution: 1. Verify repository admin permissions 2. Check GitHub Enterprise settings and restrictions 3. Apply security configuration manually if needed</p>"},{"location":"workflows/initialization/#recovery-procedures","title":"Recovery Procedures","text":""},{"location":"workflows/initialization/#re-initialization-process","title":"Re-initialization Process","text":"<p>If initialization fails or is incomplete:</p> <ol> <li>Delete Initialization Issue: Remove incomplete initialization tracking</li> <li>Reset Repository State: Ensure clean starting state</li> <li>Trigger Re-initialization: Push new commit to <code>main</code> to restart process</li> <li>Monitor Progress: Watch new initialization issue for completion</li> </ol>"},{"location":"workflows/initialization/#manual-configuration-backup","title":"Manual Configuration Backup","text":"<p>For organizations requiring manual setup: 1. Follow Initialization Steps: Execute each step from workflow manually 2. Validate Configuration: Ensure all components are properly configured 3. Test Functionality: Execute basic workflow operations to verify setup 4. Document Customizations: Record any organization-specific modifications</p> <p>The initialization workflow provides a robust foundation for OSDU SPI fork management, ensuring consistent setup across all repository instances while maintaining flexibility for organizational requirements.</p>"},{"location":"workflows/release/","title":"Release Management Workflow","text":"<p> Automated versioning |  Intelligent changelogs |  Upstream correlation</p> <p>The release management workflow implements sophisticated automated version management using Google's Release Please, providing seamless semantic versioning, comprehensive changelog generation, and upstream version correlation for OSDU SPI fork management.</p>"},{"location":"workflows/release/#release-philosophy","title":"Release Philosophy","text":""},{"location":"workflows/release/#fully-automated-versioning","title":"Fully Automated Versioning","text":"<p>Release Please analyzes conventional commit history to automatically determine appropriate version bumps, eliminating manual version management while ensuring semantic versioning compliance.</p>"},{"location":"workflows/release/#upstream-integration","title":"Upstream Integration","text":"<p>Every release maintains correlation with upstream versions, providing clear traceability between fork releases and their corresponding upstream versions for compliance and auditing.</p>"},{"location":"workflows/release/#comprehensive-documentation","title":"Comprehensive Documentation","text":"<p>Automatically generated changelogs categorize changes by type, include relevant links, and provide complete release documentation without manual intervention.</p>"},{"location":"workflows/release/#release-architecture","title":"Release Architecture","text":""},{"location":"workflows/release/#material-workflow-automated-release-pipeline","title":":material-workflow: Automated Release Pipeline","text":"<pre><code>graph TD\n    A[Push to main] --&gt; B[Check Repository State]\n    B --&gt; C{Initialized?}\n    C --&gt;|No| D[Skip Release]\n    C --&gt;|Yes| E[Analyze Commits]\n    E --&gt; F[Release Please Action]\n    F --&gt; G{Version Bump Needed?}\n    G --&gt;|No| H[Exit - No Changes]\n    G --&gt;|Yes| I[Create/Update Release PR]\n    I --&gt; J[PR Review &amp; Merge]\n    J --&gt; K[Publish GitHub Release]\n    K --&gt; L[Fetch Upstream Version]\n    L --&gt; M[Create Correlated Tag]\n    M --&gt; N[Enhanced Release Notes]\n\n    style A fill:#e1f5fe,stroke:#01579b,stroke-width:2px\n    style F fill:#e8f5e9,stroke:#1b5e20,stroke-width:2px\n    style K fill:#fff3e0,stroke:#e65100,stroke-width:2px\n    style N fill:#fce4ec,stroke:#c2185b,stroke-width:2px</code></pre>"},{"location":"workflows/release/#semantic-version-determination","title":"Semantic Version Determination","text":"<p>Conventional Commit Analysis:</p> Commit Type Version Impact Example <code>feat!:</code> or <code>BREAKING CHANGE:</code> Major (1.0.0 \u2192 2.0.0) Complete API redesign <code>feat:</code> Minor (1.0.0 \u2192 1.1.0) New user authentication <code>fix:</code> Patch (1.1.0 \u2192 1.1.1) Bug fixes and patches <code>upstream:</code> Patch (1.1.0 \u2192 1.1.1) Upstream synchronization <code>chore:</code>, <code>docs:</code>, <code>style:</code> No Release Maintenance tasks"},{"location":"workflows/release/#workflow-configuration","title":"Workflow Configuration","text":""},{"location":"workflows/release/#trigger-configuration","title":"Trigger Configuration","text":"<pre><code>on:\n  push:\n    branches: [main]    # Automatic on main branch changes\n  workflow_dispatch:    # Manual trigger capability\n\npermissions:\n  contents: write       # Repository content and tags\n  pull-requests: write  # Release PR management\n\nenv:\n  RELEASE_TYPE: 'simple'  # Non-library project versioning\n</code></pre>"},{"location":"workflows/release/#repository-state-validation","title":"Repository State Validation","text":"<pre><code># Ensure repository is properly initialized\n- name: Check initialization status\n  run: |\n    if [ ! -f \".github/workflow.env\" ]; then\n      echo \"::warning::Repository not initialized - skipping release\"\n      exit 0\n    fi\n\n    # Verify upstream configuration for correlation\n    source .github/workflow.env\n    if [ -z \"$UPSTREAM_REPO_URL\" ]; then\n      echo \"::warning::Upstream repository not configured\"\n    fi\n</code></pre>"},{"location":"workflows/release/#release-please-integration","title":"Release Please Integration","text":""},{"location":"workflows/release/#advanced-configuration","title":"Advanced Configuration","text":"<pre><code>- name: Run Release Please\n  uses: googleapis/release-please-action@v4\n  with:\n    release-type: simple\n    package-name: ${{ github.event.repository.name }}\n\n    # Comprehensive changelog configuration\n    changelog-types: |\n      [\n        {\"type\": \"feat\", \"section\": \"\ud83d\ude80 Features\", \"hidden\": false},\n        {\"type\": \"fix\", \"section\": \"\ud83d\udc1b Bug Fixes\", \"hidden\": false},\n        {\"type\": \"perf\", \"section\": \"\u26a1 Performance Improvements\", \"hidden\": false},\n        {\"type\": \"revert\", \"section\": \"\ud83d\udd04 Reverts\", \"hidden\": false},\n        {\"type\": \"docs\", \"section\": \"\ud83d\udcda Documentation\", \"hidden\": false},\n        {\"type\": \"style\", \"section\": \"\ud83d\udc8e Style\", \"hidden\": false},\n        {\"type\": \"refactor\", \"section\": \"\u267b\ufe0f Code Refactoring\", \"hidden\": false},\n        {\"type\": \"test\", \"section\": \"\ud83e\uddea Tests\", \"hidden\": false},\n        {\"type\": \"build\", \"section\": \"\ud83c\udfd7\ufe0f Build System\", \"hidden\": false},\n        {\"type\": \"ci\", \"section\": \"\ud83e\udd16 CI/CD\", \"hidden\": false},\n        {\"type\": \"chore\", \"section\": \"\ud83e\uddf9 Miscellaneous\", \"hidden\": false},\n        {\"type\": \"upstream\", \"section\": \"\u2b06\ufe0f Upstream Updates\", \"hidden\": false}\n      ]\n\n    # Release PR configuration\n    pull-request-title-pattern: \"chore: release ${version}\"\n    version-file: \"version.txt\"\n</code></pre>"},{"location":"workflows/release/#version-correlation-system","title":"Version Correlation System","text":""},{"location":"workflows/release/#upstream-version-detection","title":"Upstream Version Detection","text":"<pre><code>- name: Get upstream version correlation\n  if: steps.release.outputs.release_created\n  run: |\n    # Source repository configuration\n    source .github/workflow.env\n\n    # Configure upstream remote\n    if ! git remote | grep -q upstream; then\n      git remote add upstream \"$UPSTREAM_REPO_URL\"\n    fi\n\n    # Fetch latest upstream tags\n    git fetch upstream --tags --quiet\n\n    # Determine latest upstream version\n    UPSTREAM_VERSION=$(git describe --tags --abbrev=0 upstream/main 2&gt;/dev/null || echo \"unknown\")\n    UPSTREAM_VERSION=${UPSTREAM_VERSION#v}  # Remove 'v' prefix\n\n    echo \"upstream_version=$UPSTREAM_VERSION\" &gt;&gt; $GITHUB_OUTPUT\n    echo \"Detected upstream version: $UPSTREAM_VERSION\"\n</code></pre>"},{"location":"workflows/release/#correlated-tag-creation","title":"Correlated Tag Creation","text":"<pre><code>- name: Create upstream-correlated tag\n  if: steps.release.outputs.release_created\n  run: |\n    RELEASE_TAG=\"${{ steps.release.outputs.tag_name }}\"\n    UPSTREAM_VERSION=\"${{ steps.get-upstream.outputs.upstream_version }}\"\n\n    # Create comprehensive correlation tag\n    CORRELATED_TAG=\"${RELEASE_TAG}-upstream-${UPSTREAM_VERSION}\"\n\n    # Tag the release commit with correlation\n    git tag \"$CORRELATED_TAG\" \"${{ github.sha }}\"\n    git push origin \"$CORRELATED_TAG\"\n\n    echo \"Created correlated tag: $CORRELATED_TAG\"\n</code></pre>"},{"location":"workflows/release/#enhanced-release-documentation","title":"Enhanced Release Documentation","text":""},{"location":"workflows/release/#automated-release-notes-enhancement","title":"Automated Release Notes Enhancement","text":"<pre><code>- name: Update release with upstream correlation\n  if: steps.release.outputs.release_created\n  uses: actions/github-script@v7\n  with:\n    script: |\n      const releaseId = ${{ steps.release.outputs.id }};\n      const upstreamVersion = '${{ steps.get-upstream.outputs.upstream_version }}';\n      const correlatedTag = '${{ steps.create-tag.outputs.correlated_tag }}';\n\n      // Get current release data\n      const { data: release } = await github.rest.repos.getRelease({\n        owner: context.repo.owner,\n        repo: context.repo.repo,\n        release_id: releaseId\n      });\n\n      // Enhance with upstream correlation information\n      const enhancedBody = release.body + `\n\n      ## \ud83d\udccc Upstream Correlation\n\n      - **Upstream Version**: \\`${upstreamVersion}\\`\n      - **Correlated Tag**: \\`${correlatedTag}\\`\n      - **Upstream Repository**: ${{ env.UPSTREAM_REPO_URL }}\n\n      This release includes all changes from upstream version ${upstreamVersion}.\n      `;\n\n      // Update the GitHub release\n      await github.rest.repos.updateRelease({\n        owner: context.repo.owner,\n        repo: context.repo.repo,\n        release_id: releaseId,\n        body: enhancedBody\n      });\n</code></pre>"},{"location":"workflows/release/#changelog-management","title":"Changelog Management","text":""},{"location":"workflows/release/#professional-changelog-format","title":"Professional Changelog Format","text":"<p>Generated CHANGELOG.md Structure: <pre><code># Changelog\n\n## [1.2.0](https://github.com/org/repo/compare/v1.1.0...v1.2.0) (2025-05-28)\n\n### \ud83d\ude80 Features\n\n* Add OAuth2 authentication system ([#123](https://github.com/org/repo/issues/123)) ([abc1234](https://github.com/org/repo/commit/abc1234))\n* Implement data export functionality ([#125](https://github.com/org/repo/issues/125)) ([def5678](https://github.com/org/repo/commit/def5678))\n\n### \ud83d\udc1b Bug Fixes\n\n* Resolve authentication timeout issue ([#124](https://github.com/org/repo/issues/124)) ([ghi9012](https://github.com/org/repo/commit/ghi9012))\n* Fix data validation in user service ([#126](https://github.com/org/repo/issues/126)) ([jkl3456](https://github.com/org/repo/commit/jkl3456))\n\n### \u2b06\ufe0f Upstream Updates\n\n* Sync upstream changes from v2.3.4 ([#127](https://github.com/org/repo/issues/127)) ([mno7890](https://github.com/org/repo/commit/mno7890))\n\n### \ud83e\uddf9 Miscellaneous\n\n* Update development dependencies ([#128](https://github.com/org/repo/issues/128)) ([pqr1234](https://github.com/org/repo/commit/pqr1234))\n</code></pre></p>"},{"location":"workflows/release/#conventional-commit-examples","title":"Conventional Commit Examples","text":"<p>Effective Commit Messages for Release Management:</p> <pre><code># Feature addition (minor version bump)\nfeat: implement advanced user search functionality\n\n# Bug fix (patch version bump)  \nfix: resolve null pointer exception in data processor\n\n# Breaking change (major version bump)\nfeat!: redesign authentication API with OAuth2\n\nBREAKING CHANGE: The authentication API now requires OAuth2 tokens\ninstead of API keys. Existing integrations must be updated.\n\n# Upstream integration (patch version bump)\nupstream: sync security fixes from upstream v2.3.4\n\n# Maintenance (no version bump)\nchore: update CI/CD pipeline configuration\ndocs: improve API documentation with examples\nstyle: format code with prettier\n</code></pre>"},{"location":"workflows/release/#advanced-configuration_1","title":"Advanced Configuration","text":""},{"location":"workflows/release/#release-please-configuration-files","title":"Release Please Configuration Files","text":""},{"location":"workflows/release/#release-please-configjson","title":".release-please-config.json","text":"<pre><code>{\n  \"packages\": {\n    \".\": {\n      \"release-type\": \"simple\",\n      \"bump-minor-pre-major\": true,\n      \"bump-patch-for-minor-pre-major\": true,\n      \"include-component-in-tag\": false,\n      \"changelog-sections\": [\n        {\"type\": \"feat\", \"section\": \"\ud83d\ude80 Features\"},\n        {\"type\": \"fix\", \"section\": \"\ud83d\udc1b Bug Fixes\"},\n        {\"type\": \"upstream\", \"section\": \"\u2b06\ufe0f Upstream Updates\"},\n        {\"type\": \"perf\", \"section\": \"\u26a1 Performance\"},\n        {\"type\": \"docs\", \"section\": \"\ud83d\udcda Documentation\"},\n        {\"type\": \"chore\", \"section\": \"\ud83e\uddf9 Maintenance\"}\n      ]\n    }\n  }\n}\n</code></pre>"},{"location":"workflows/release/#versiontxt","title":"version.txt","text":"<pre><code>1.2.0\n</code></pre>"},{"location":"workflows/release/#release-please-manifestjson","title":".release-please-manifest.json","text":"<pre><code>{\n  \".\": \"1.2.0\"\n}\n</code></pre>"},{"location":"workflows/release/#error-handling-and-reliability","title":"Error Handling and Reliability","text":""},{"location":"workflows/release/#common-scenarios-and-resolutions","title":"Common Scenarios and Resolutions","text":""},{"location":"workflows/release/#no-releasable-commits-detection","title":"No Releasable Commits Detection","text":"<pre><code>- name: Validate commit history for releases\n  run: |\n    COMMITS=$(git log --format=%s ${{ github.event.before }}..${{ github.sha }})\n    if ! echo \"$COMMITS\" | grep -qE '^(feat|fix|perf|revert)(\\(.+\\))?!?:'; then\n      echo \"::notice::No releasable commits found - skipping release\"\n      echo \"Commits must use 'feat:', 'fix:', 'perf:', or 'revert:' for releases\"\n    fi\n</code></pre>"},{"location":"workflows/release/#upstream-connectivity-issues","title":"Upstream Connectivity Issues","text":"<pre><code>- name: Handle upstream fetch failures gracefully\n  continue-on-error: true\n  run: |\n    if ! git fetch upstream --tags --timeout=30; then\n      echo \"::warning::Could not fetch upstream tags - using fallback\"\n      echo \"upstream_version=unavailable\" &gt;&gt; $GITHUB_OUTPUT\n    fi\n</code></pre>"},{"location":"workflows/release/#release-pr-conflicts","title":"Release PR Conflicts","text":"<pre><code>- name: Resolve release PR conflicts automatically\n  if: steps.release.outputs.pr &amp;&amp; steps.release.outputs.pr_has_conflicts\n  run: |\n    # Checkout release PR branch\n    gh pr checkout ${{ steps.release.outputs.pr }}\n\n    # Attempt automatic rebase\n    git pull origin main --rebase\n\n    # Force push if successful\n    git push --force-with-lease\n</code></pre>"},{"location":"workflows/release/#release-validation","title":"Release Validation","text":""},{"location":"workflows/release/#release-integrity-verification","title":"Release Integrity Verification","text":"<pre><code>- name: Validate release integrity\n  if: steps.release.outputs.release_created\n  run: |\n    # Verify tag creation\n    git fetch --tags\n    if ! git tag -l | grep -q \"^${{ steps.release.outputs.tag_name }}$\"; then\n      echo \"::error::Release tag not found after creation\"\n      exit 1\n    fi\n\n    # Verify changelog update\n    if ! git diff HEAD^ HEAD -- CHANGELOG.md | grep -q \"+## \"; then\n      echo \"::warning::Changelog may not have been updated properly\"\n    fi\n\n    # Verify version file update\n    if [ -f \"version.txt\" ]; then\n      if ! grep -q \"${{ steps.release.outputs.version }}\" version.txt; then\n        echo \"::warning::Version file not updated correctly\"\n      fi\n    fi\n</code></pre>"},{"location":"workflows/release/#performance-optimization","title":"Performance Optimization","text":""},{"location":"workflows/release/#efficient-execution-strategies","title":"Efficient Execution Strategies","text":""},{"location":"workflows/release/#conditional-release-processing","title":"Conditional Release Processing","text":"<pre><code>- name: Optimize execution based on change detection\n  run: |\n    # Skip if no commits since last release\n    LAST_RELEASE=$(git describe --tags --abbrev=0 2&gt;/dev/null || echo \"\")\n    if [ -n \"$LAST_RELEASE\" ]; then\n      CHANGES=$(git rev-list --count $LAST_RELEASE..HEAD)\n      if [ \"$CHANGES\" -eq 0 ]; then\n        echo \"::notice::No commits since last release - skipping\"\n        exit 0\n      fi\n    fi\n</code></pre>"},{"location":"workflows/release/#caching-strategy","title":"Caching Strategy","text":"<pre><code>- name: Cache Release Please data\n  uses: actions/cache@v4\n  with:\n    path: |\n      .release-please/\n      .release-please-manifest.json\n    key: release-please-${{ github.ref }}-${{ hashFiles('**/*.md', '**/*.json') }}\n    restore-keys: |\n      release-please-${{ github.ref }}-\n      release-please-\n</code></pre>"},{"location":"workflows/release/#monitoring-and-analytics","title":"Monitoring and Analytics","text":""},{"location":"workflows/release/#release-metrics-collection","title":"Release Metrics Collection","text":""},{"location":"workflows/release/#release-quality-metrics","title":"Release Quality Metrics","text":"<pre><code>- name: Collect comprehensive release metrics\n  if: steps.release.outputs.release_created\n  run: |\n    # Calculate time since last release\n    LAST_RELEASE_DATE=$(git log -1 --format=%ai $(git describe --tags --abbrev=0 HEAD^ 2&gt;/dev/null || echo HEAD))\n    DAYS_SINCE_RELEASE=$(( ($(date +%s) - $(date -d \"$LAST_RELEASE_DATE\" +%s)) / 86400 ))\n\n    # Count commits included in release\n    LAST_TAG=$(git describe --tags --abbrev=0 HEAD^ 2&gt;/dev/null || echo \"\")\n    COMMIT_COUNT=$(git rev-list --count ${LAST_TAG:+$LAST_TAG..}HEAD)\n\n    # Categorize changes by type\n    FEAT_COUNT=$(git log --format=%s ${LAST_TAG:+$LAST_TAG..}HEAD | grep -c \"^feat:\" || echo 0)\n    FIX_COUNT=$(git log --format=%s ${LAST_TAG:+$LAST_TAG..}HEAD | grep -c \"^fix:\" || echo 0)\n    UPSTREAM_COUNT=$(git log --format=%s ${LAST_TAG:+$LAST_TAG..}HEAD | grep -c \"^upstream:\" || echo 0)\n\n    echo \"\ud83d\udcca Release Metrics:\"\n    echo \"- Days since last release: $DAYS_SINCE_RELEASE\"\n    echo \"- Total commits: $COMMIT_COUNT\"\n    echo \"- Features: $FEAT_COUNT\"\n    echo \"- Bug fixes: $FIX_COUNT\"  \n    echo \"- Upstream updates: $UPSTREAM_COUNT\"\n</code></pre>"},{"location":"workflows/release/#material-notification-release-notifications","title":":material-notification: Release Notifications","text":""},{"location":"workflows/release/#team-communication-integration","title":"Team Communication Integration","text":"<pre><code>- name: Notify team of new release\n  if: steps.release.outputs.release_created\n  run: |\n    # Create comprehensive release summary\n    RELEASE_URL=\"${{ steps.release.outputs.html_url }}\"\n    VERSION=\"${{ steps.release.outputs.version }}\"\n    CORRELATED_TAG=\"${{ steps.create-tag.outputs.correlated_tag }}\"\n\n    echo \"\ud83c\udf89 New release published: v$VERSION\"\n    echo \"\ud83d\udccb Release URL: $RELEASE_URL\"\n    echo \"\ud83d\udd17 Correlated tag: $CORRELATED_TAG\"\n    echo \"\u2b06\ufe0f Upstream version: ${{ steps.get-upstream.outputs.upstream_version }}\"\n</code></pre>"},{"location":"workflows/release/#troubleshooting-guide","title":"Troubleshooting Guide","text":""},{"location":"workflows/release/#common-issues-and-solutions","title":"Common Issues and Solutions","text":""},{"location":"workflows/release/#release-please-pr-not-created","title":"Release Please PR Not Created","text":"<ul> <li>Cause: No conventional commits found in history</li> <li>Solution: Ensure commits follow conventional commit format</li> <li>Debug: Check recent commits with <code>git log --format=\"%s\" -10</code></li> </ul>"},{"location":"workflows/release/#version-not-incrementing","title":"Version Not Incrementing","text":"<ul> <li>Cause: Only non-release commit types present</li> <li>Solution: Use <code>feat:</code>, <code>fix:</code>, or <code>perf:</code> for version bumps</li> <li>Debug: Verify commit types match Release Please configuration</li> </ul>"},{"location":"workflows/release/#upstream-version-correlation-missing","title":"Upstream Version Correlation Missing","text":"<ul> <li>Cause: Upstream remote not accessible or no tags</li> <li>Solution: Verify <code>UPSTREAM_REPO_URL</code> configuration and network access</li> <li>Debug: Test with <code>git ls-remote --tags upstream</code></li> </ul>"},{"location":"workflows/release/#changelog-generation-issues","title":"Changelog Generation Issues","text":"<ul> <li>Cause: Commit format not matching changelog configuration</li> <li>Solution: Update changelog-types configuration or commit format</li> <li>Debug: Review Release Please configuration against commit history</li> </ul>"},{"location":"workflows/release/#debug-commands","title":"Debug Commands","text":"<pre><code># Verify conventional commit format\ngit log --format=\"%s\" | grep -E \"^(feat|fix|docs|style|refactor|test|chore)(\\(.+\\))?:\"\n\n# Check Release Please state\ncat .release-please-manifest.json\n\n# Test upstream connectivity  \ngit ls-remote --tags upstream\n\n# Review recent release history\ngit tag --sort=-version:refname | head -5\n\n# Analyze commit types since last release\ngit log --format=\"%s\" $(git describe --tags --abbrev=0)..HEAD\n</code></pre> <p>The release management workflow provides automated, reliable version management with comprehensive documentation and upstream correlation, ensuring professional release processes for OSDU SPI fork management.</p>"},{"location":"workflows/synchronization/","title":"Upstream Synchronization Workflow","text":"<p>\ud83e\udde0 AI-powered sync | \ud83d\udd01 Three-branch safety | \ud83d\udea7 Human-reviewed conflict resolution | \ud83d\udd04 Duplicate prevention</p> <p>This workflow regularly syncs changes from the upstream repository, which often include unconventional or inconsistent commit messages. Rather than preserving those commits as-is, the workflow uses AI to analyze the incoming changeset (via a git diff) and generate a single, conventional meta-commit that summarizes the entire upstream changeset\u2014replacing the original, often inconsistent commits with a standardized summary. The AI classifies the changes (e.g., feat, fix, chore) and creates a detailed, multi-line commit message that adheres to conventional commit standards. A three-branch strategy (<code>fork_upstream</code> \u2192 <code>fork_integration</code> \u2192 <code>main</code>) is used to isolate changes, manage potential conflicts safely, and generate pull requests automatically. The workflow now includes intelligent duplicate prevention to avoid creating multiple PRs and issues for the same upstream state.</p>"},{"location":"workflows/synchronization/#duplicate-prevention-architecture","title":"Duplicate Prevention Architecture","text":""},{"location":"workflows/synchronization/#sync-state-manager-action","title":"sync-state-manager Action","text":"<p>The workflow integrates a custom GitHub Action (<code>sync-state-manager</code>) that provides comprehensive duplicate detection and state management:</p> <p>Key Capabilities: - Upstream SHA Tracking: Compares current upstream state with last synced state - Existing PR Detection: Queries GitHub API for open sync PRs with <code>upstream-sync</code> label - Branch Management: Updates existing sync branches instead of creating new ones - Abandoned Branch Cleanup: Automatically removes stale sync branches (&gt;24h old, no associated PR) - State Persistence: Uses git config to store sync state between workflow runs</p>"},{"location":"workflows/synchronization/#decision-matrix-implementation","title":"Decision Matrix Implementation","text":"<p>The action implements a smart decision matrix:</p> <pre><code>Decision Logic:\n  - No existing PR + Upstream changed \u2192 Create new PR and issue\n  - Existing PR + Upstream unchanged \u2192 Add reminder comment\n  - Existing PR + Upstream changed \u2192 Update existing branch and PR\n  - No existing PR + Upstream unchanged \u2192 No action needed\n</code></pre>"},{"location":"workflows/synchronization/#state-management","title":"State Management","text":"<p>Storage Method: Git config variables scoped to repository - <code>sync.last-upstream-sha</code>: Last successfully processed upstream SHA - <code>sync.current-pr-number</code>: Active sync PR number (if any) - <code>sync.current-issue-number</code>: Active tracking issue number (if any) - <code>sync.last-sync-timestamp</code>: Timestamp of last sync attempt</p> <p>Persistence: Automatic across workflow runs Cleanup: Automatic when PRs/issues are closed or merged</p>"},{"location":"workflows/synchronization/#three-branch-strategy","title":"Three-Branch Strategy","text":"<p>The workflow uses a three-branch approach to ensure safe integration:</p> <pre><code>graph TD\n    A[Upstream Repo] --&gt; B[fork_upstream]\n    B --&gt; C[fork_integration]\n    C --&gt; D[main]\n    style A fill:#e1f5fe,stroke:#01579b,stroke-width:2px\n    style B fill:#fff3e0,stroke:#e65100,stroke-width:2px  \n    style C fill:#fce4ec,stroke:#c2185b,stroke-width:2px\n    style D fill:#e8f5e9,stroke:#1b5e20,stroke-width:2px</code></pre> <ul> <li>fork_upstream: Mirror of upstream, updated first</li> <li>fork_integration: Conflict resolution and testing</li> <li>main: Your stable production branch</li> </ul>"},{"location":"workflows/synchronization/#key-benefits","title":"Key Benefits","text":"<ul> <li>Automated Scheduled Sync: No manual intervention for clean merges</li> <li>Conflict Safety: Conflicts isolated and handled safely</li> <li>AI-Enhanced Analysis: Intelligent PR descriptions and conflict categorization</li> <li>Complete Audit Trail: Full tracking of all changes and decisions</li> </ul>"},{"location":"workflows/synchronization/#configuration-options","title":"Configuration Options","text":"Setting Default Description Schedule <code>0 0 * * *</code> Daily at midnight UTC (customizable) Diff Size Limit <code>20,000 lines</code> Maximum diff size for AI analysis AI Provider Claude (Anthropic) Primary AI service for PR descriptions Auto-merge Disabled Automatic merging for small changes Conflict Timeout 6 hours How long before monitor auto-triggers cascade Retry Attempts 3 Network operation retry count <p>\ud83d\udca1 AI Enhancement: To enable AI-powered PR descriptions, configure an <code>ANTHROPIC_API_KEY</code> secret in your repository settings. This provides intelligent analysis of upstream changes with structured commit summaries. Other AI providers can be configured as alternatives.</p>"},{"location":"workflows/synchronization/#workflow-triggers","title":"Workflow Triggers","text":"<ul> <li>Automatic: Daily at midnight UTC</li> <li>Manual: Click \"Run workflow\" in GitHub Actions tab</li> <li>API: Trigger via GitHub REST \u220fAPI</li> </ul>"},{"location":"workflows/synchronization/#required-permissions","title":"Required Permissions","text":"<p>The workflow needs these GitHub permissions: - <code>contents: write</code> - Update repository files and branches - <code>pull-requests: write</code> - Create and manage pull requests - <code>issues: write</code> - Create tracking issues for conflicts</p>"},{"location":"workflows/synchronization/#how-it-works","title":"How It Works","text":""},{"location":"workflows/synchronization/#the-happy-path-no-conflicts","title":"The Happy Path (No Conflicts)","text":"<ol> <li>Check for Changes: Workflow fetches upstream and compares with your fork</li> <li>Create Sync Branch: If changes exist, creates a dated sync branch</li> <li>AI Analysis: Generates intelligent PR description with change summary</li> <li>Create PR: Opens pull request from sync branch to <code>fork_upstream</code></li> <li>Human Review: Team reviews and merges the PR</li> <li>Cascade: Manual or automatic cascade moves changes to <code>main</code></li> </ol>"},{"location":"workflows/synchronization/#when-conflicts-occur","title":"When Conflicts Occur","text":"<ol> <li>Conflict Detection: Workflow identifies merge conflicts during integration</li> <li>Create Conflict PR: Opens PR with conflict markers for manual resolution</li> <li>Create Tracking Issue: Detailed issue with step-by-step resolution instructions</li> <li>Human Resolution: Developer resolves conflicts and updates PR</li> <li>Continue Process: Once resolved, normal cascade process continues</li> </ol> <pre><code>flowchart TD\n    A[Daily Trigger] --&gt; B[Check Upstream]\n    B --&gt; C{Changes Found?}\n    C --&gt;|No| D[Exit Clean]\n    C --&gt;|Yes| E[Create Sync Branch]\n    E --&gt; F{Conflicts?}\n    F --&gt;|No| G[AI-Enhanced PR]\n    F --&gt;|Yes| H[Conflict PR + Issue]\n    G --&gt; I[Human Review]\n    H --&gt; J[Manual Resolution]\n    I --&gt; K[Merge to fork_upstream]\n    J --&gt; K\n    K --&gt; L[Cascade to main]</code></pre>"},{"location":"workflows/synchronization/#immediate-actions","title":"Immediate Actions","text":"<p>When the workflow detects conflicts, it automatically:</p> <ol> <li>Creates a Conflict Pull Request</li> <li>Contains the conflicted files with merge markers</li> <li>Targets the <code>fork_integration</code> branch for safe resolution</li> <li> <p>Labeled with <code>conflict</code>, <code>upstream-sync</code>, <code>human-required</code></p> </li> <li> <p>Creates a Tracking Issue</p> </li> <li>Comprehensive resolution instructions</li> <li>Links to the conflict PR</li> <li>Complete process overview with checkboxes</li> <li>Labeled with <code>conflict</code>, <code>human-required</code>, <code>high-priority</code></li> </ol>"},{"location":"workflows/synchronization/#your-resolution-steps","title":"Your Resolution Steps","text":""},{"location":"workflows/synchronization/#step-1-review-the-conflict","title":"Step 1: Review the Conflict","text":"<pre><code># Clone the conflict branch locally\ngit checkout sync/upstream-YYYYMMDD-HHMMSS\n\n# See which files have conflicts\ngit status\n</code></pre>"},{"location":"workflows/synchronization/#step-2-resolve-conflicts","title":"Step 2: Resolve Conflicts","text":"<ul> <li>Open conflicted files in your preferred merge tool</li> <li>Choose between <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code> (your changes) and <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt; upstream</code> (their changes)</li> <li>Or combine both as appropriate for your use case</li> <li>Remove conflict markers (<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>, <code>=======</code>, <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>)</li> </ul>"},{"location":"workflows/synchronization/#step-3-test-and-commit","title":"Step 3: Test and Commit","text":"<pre><code># Test your changes\nmvn test  # or your project's test command\n\n# Commit the resolution\ngit add .\ngit commit -m \"resolve: merge conflicts from upstream sync\"\ngit push origin sync/upstream-YYYYMMDD-HHMMSS\n</code></pre>"},{"location":"workflows/synchronization/#step-4-complete-the-process","title":"Step 4: Complete the Process","text":"<ol> <li>Update the conflict PR with your resolution</li> <li>Request review from team members</li> <li>Once approved, merge the PR</li> <li>Manually trigger the cascade workflow (or wait for automatic trigger)</li> </ol>"},{"location":"workflows/synchronization/#getting-help","title":"Getting Help","text":"<ul> <li>Conflict resolution templates in <code>.github/</code> directory</li> <li>Issue tracking provides complete guidance</li> <li>Team members can assist via PR reviews</li> <li>Conflict management documentation</li> </ul>"},{"location":"workflows/synchronization/#handling-human-required-tasks","title":"Handling Human-Required Tasks","text":"<p>When you see a sync issue labeled <code>human-required</code>, follow this decision tree:</p> <p>Clean PR \u2192 Review \u2192 Merge \u2192 Cascade Conflict PR \u2192 Resolve Locally \u2192 Push \u2192 Review \u2192 Merge \u2192 Cascade</p>"},{"location":"workflows/synchronization/#for-clean-syncs-no-conflicts","title":"For Clean Syncs (No Conflicts)","text":"<ol> <li>Review the PR: Click the link in the tracking issue</li> <li>Check AI Summary: Review the AI-generated description of changes</li> <li>Verify No Breaking Changes: Look for any compatibility issues</li> <li>Merge the PR: Approve and merge to <code>fork_upstream</code> branch</li> <li>Trigger Cascade: </li> <li>Go to Actions \u2192 Cascade Integration workflow</li> <li>Enter the issue number from the tracking issue</li> <li>Click \"Run workflow\"</li> <li>Monitor Progress: Check back in 15-30 minutes for completion</li> </ol>"},{"location":"workflows/synchronization/#for-conflict-syncs","title":"For Conflict Syncs","text":"<ol> <li>Read the Conflict Issue: Complete step-by-step instructions provided</li> <li>Checkout the Branch: Follow the git commands in the issue</li> <li>Resolve Conflicts: Use your IDE's merge tools or manual editing</li> <li>Test Thoroughly: Run your test suite to ensure stability</li> <li>Push Resolution: Commit and push your conflict resolution</li> <li>Update PR: The conflict PR will automatically update</li> <li>Request Review: Get team approval for your resolution</li> <li>Merge and Cascade: Same process as clean syncs after merge</li> </ol>"},{"location":"workflows/synchronization/#safety-features","title":"Safety Features","text":"<ul> <li>6-Hour Monitor: If you miss triggering the cascade, automation kicks in</li> <li>Branch Protection: Prevents accidental damage to stable branches</li> <li>Complete Audit Trail: Every action tracked in the issue comments</li> <li>Rollback Support: Can revert to previous stable state if needed</li> </ul>"},{"location":"workflows/synchronization/#monitoring-and-troubleshooting","title":"Monitoring and Troubleshooting","text":""},{"location":"workflows/synchronization/#finding-your-sync-tasks","title":"Finding Your Sync Tasks","text":"<p>Use these GitHub issue filters to find items needing attention:</p> Filter Purpose <code>label:human-required label:upstream-sync</code> All sync items needing review <code>label:conflict label:high-priority</code> Urgent conflicts requiring resolution <code>label:human-required</code> All items across workflows needing attention"},{"location":"workflows/synchronization/#common-issues-and-solutions","title":"Common Issues and Solutions","text":""},{"location":"workflows/synchronization/#no-upstream-changes-detected","title":"\"No upstream changes detected\"","text":"<ul> <li>Cause: Your fork is already up to date</li> <li>Action: No action needed, workflow will exit cleanly</li> </ul>"},{"location":"workflows/synchronization/#failed-to-fetch-upstream","title":"\"Failed to fetch upstream\"","text":"<ul> <li>Cause: Network issues or incorrect <code>UPSTREAM_REPO_URL</code></li> <li>Action: Check repository secrets and network connectivity</li> </ul>"},{"location":"workflows/synchronization/#ai-description-generation-failed","title":"\"AI description generation failed\"","text":"<ul> <li>Cause: API key issues or service unavailable</li> <li>Action: PR created with standard template, no impact on functionality</li> </ul>"},{"location":"workflows/synchronization/#cascade-workflow-not-triggered","title":"\"Cascade workflow not triggered\"","text":"<ul> <li>Cause: Manual trigger missed</li> <li>Action: Monitor detects and auto-triggers within 6 hours</li> </ul>"},{"location":"workflows/synchronization/#performance-expectations","title":"Performance Expectations","text":"<ul> <li>Typical Sync Time: 2-5 minutes for clean merges</li> <li>Large Repository Sync: Up to 15 minutes for repos with extensive history</li> <li>AI Description Generation: Adds 30-60 seconds when enabled</li> <li>Conflict Resolution: Variable based on complexity (30 minutes to 2 hours)</li> </ul>"},{"location":"workflows/synchronization/#customization-options","title":"Customization Options","text":""},{"location":"workflows/synchronization/#changing-the-sync-schedule","title":"Changing the Sync Schedule","text":"<p>Edit <code>.github/workflows/sync.yml</code>: <pre><code># Weekly instead of daily\n- cron: '0 2 * * 1'  # Monday 2 AM\n\n# Multiple times per day\n- cron: '0 0,12 * * *'  # Midnight and noon\n</code></pre></p>"},{"location":"workflows/synchronization/#adjusting-diff-size-limits","title":"Adjusting Diff Size Limits","text":"<p>For larger repositories, increase the AI analysis threshold: <pre><code>env:\n  DIFF_SIZE_LIMIT: 50000  # Analyze larger diffs\n</code></pre></p>"},{"location":"workflows/synchronization/#disabling-ai-enhancement","title":"Disabling AI Enhancement","text":"<p>Remove AI API keys to use standard PR templates: <pre><code># Remove these secrets to disable AI\n# ANTHROPIC_API_KEY\n# AZURE_API_KEY  \n# OPENAI_API_KEY\n</code></pre></p>"},{"location":"workflows/synchronization/#custom-conflict-handling","title":"Custom Conflict Handling","text":"<p>Modify templates in <code>.github/</code> directory: - <code>conflict_pr_template.md</code> - Conflict PR description - <code>conflict_issue_template.md</code> - Resolution issue template</p>"},{"location":"workflows/synchronization/#architecture-references","title":"Architecture References","text":"<p>For deeper technical understanding: - ADR-001: Three-Branch Strategy - Core branching approach - ADR-020: Human-Required Labels - Task assignment strategy - ADR-023: Meta Commit Strategy - Release integration - Product Architecture - Complete system overview</p> <p>For setup help, see the initialization workflow. For cascade process details, see the cascade workflow.</p> <p>\u2b06\ufe0f Back to top</p>"},{"location":"workflows/validation/","title":"Pull Request Validation Workflow","text":"<p> Quality gates |  Conventional commits |  Conflict detection |  Build verification</p> <p>The pull request validation workflow provides comprehensive quality assurance for all changes entering protected branches. This intelligent system enforces code standards, verifies build integrity, and ensures consistency across the OSDU SPI fork management lifecycle.</p>"},{"location":"workflows/validation/#validation-philosophy","title":"Validation Philosophy","text":""},{"location":"workflows/validation/#comprehensive-quality-gates","title":"Comprehensive Quality Gates","text":"<p>Every pull request undergoes systematic validation to ensure code quality, consistency, and readiness before integration into protected branches.</p>"},{"location":"workflows/validation/#intelligent-rule-application","title":"Intelligent Rule Application","text":"<p>Validation rules adapt based on context - different standards apply to upstream sync PRs, fork management branches, and standard development contributions.</p>"},{"location":"workflows/validation/#material-feedback-clear-developer-feedback","title":":material-feedback: Clear Developer Feedback","text":"<p>Detailed status reporting provides actionable feedback, helping developers understand and resolve issues quickly.</p>"},{"location":"workflows/validation/#validation-architecture","title":"Validation Architecture","text":""},{"location":"workflows/validation/#material-workflow-multi-phase-validation-pipeline","title":":material-workflow: Multi-Phase Validation Pipeline","text":"<pre><code>graph TD\n    A[PR/Push Event] --&gt; B[Repository State Analysis]\n    B --&gt; C{Project Type Detection}\n    C --&gt;|Java| D[Build &amp; Coverage Validation]\n    C --&gt;|Other| E[Skip Build Checks]\n    D --&gt; F[Quality Assurance Checks]\n    E --&gt; F\n    F --&gt; G[Commit Message Validation]\n    G --&gt; H[Merge Conflict Detection]\n    H --&gt; I[Branch Synchronization Check]\n    I --&gt; J[Generate Comprehensive Report]\n    J --&gt; K[Update PR Status]\n\n    style A fill:#e1f5fe,stroke:#01579b,stroke-width:2px\n    style D fill:#e8f5e9,stroke:#1b5e20,stroke-width:2px\n    style F fill:#fff3e0,stroke:#e65100,stroke-width:2px\n    style K fill:#fce4ec,stroke:#c2185b,stroke-width:2px</code></pre>"},{"location":"workflows/validation/#material-parallel-parallel-execution-strategy","title":":material-parallel: Parallel Execution Strategy","text":"<pre><code>graph TD\n    A[check-repo-state] --&gt; B[java-build]\n    A --&gt; C[validate]\n    B --&gt; D[report-status]\n    C --&gt; D\n\n    subgraph \"Parallel Processing\"\n        B1[Build Verification]\n        C1[Commit Validation]\n        C2[Conflict Detection]\n        C3[Branch Status]\n    end\n\n    B --&gt; B1\n    C --&gt; C1\n    C --&gt; C2\n    C --&gt; C3</code></pre>"},{"location":"workflows/validation/#workflow-configuration","title":"Workflow Configuration","text":""},{"location":"workflows/validation/#material-trigger-event-triggers-and-scope","title":":material-trigger: Event Triggers and Scope","text":"<pre><code>on:\n  pull_request:\n    branches: [main, fork_integration, fork_upstream]  # All protected branches\n  push:\n    branches: [main, fork_integration, fork_upstream]  # Direct push validation\n  workflow_dispatch:\n    inputs:\n      post_init:\n        description: 'Post-initialization validation trigger'\n        type: boolean\n        default: false\n\npermissions:\n  contents: read        # Repository access\n  pull-requests: write  # PR status updates\n  statuses: write       # Commit status checks\n  actions: read         # Workflow context\n</code></pre>"},{"location":"workflows/validation/#concurrency-management","title":"Concurrency Management","text":"<pre><code>concurrency:\n  group: validate-${{ github.event.pull_request.number || github.ref }}\n  cancel-in-progress: true  # Optimize resource usage\n</code></pre>"},{"location":"workflows/validation/#phase-1-repository-state-analysis","title":"Phase 1: Repository State Analysis","text":""},{"location":"workflows/validation/#intelligent-project-detection","title":"Intelligent Project Detection","text":""},{"location":"workflows/validation/#initialization-status-verification","title":"Initialization Status Verification","text":"<pre><code>- name: Verify repository initialization\n  run: |\n    if [ -f \".github/workflow.env\" ]; then\n      source .github/workflow.env\n      echo \"initialized=true\" &gt;&gt; $GITHUB_OUTPUT\n      echo \"Repository fully initialized with upstream: ${UPSTREAM_REPO_URL:-'not configured'}\"\n    else\n      echo \"initialized=false\" &gt;&gt; $GITHUB_OUTPUT\n      echo \"::warning::Repository not fully initialized - some validations may be skipped\"\n    fi\n</code></pre>"},{"location":"workflows/validation/#project-type-and-build-requirements","title":"Project Type and Build Requirements","text":"<pre><code>- name: Detect project type and build requirements\n  run: |\n    # Java project detection (Maven/Gradle)\n    if [ -f \"pom.xml\" ]; then\n      echo \"project_type=java-maven\" &gt;&gt; $GITHUB_OUTPUT\n      echo \"build_required=true\" &gt;&gt; $GITHUB_OUTPUT\n      echo \"\ud83d\udccb Detected Java Maven project\"\n    elif [ -f \"build.gradle\" ] || [ -f \"build.gradle.kts\" ]; then\n      echo \"project_type=java-gradle\" &gt;&gt; $GITHUB_OUTPUT  \n      echo \"build_required=true\" &gt;&gt; $GITHUB_OUTPUT\n      echo \"\ud83d\udccb Detected Java Gradle project\"\n    else\n      echo \"project_type=generic\" &gt;&gt; $GITHUB_OUTPUT\n      echo \"build_required=false\" &gt;&gt; $GITHUB_OUTPUT\n      echo \"\ud83d\udccb Generic project - build validation skipped\"\n    fi\n</code></pre>"},{"location":"workflows/validation/#context-aware-metadata","title":"Context-Aware Metadata","text":"<pre><code>outputs:\n  initialized: ${{ steps.check.outputs.initialized }}\n  project_type: ${{ steps.detect.outputs.project_type }}\n  build_required: ${{ steps.detect.outputs.build_required }}\n  pr_context: ${{ steps.context.outputs.pr_context }}\n</code></pre>"},{"location":"workflows/validation/#phase-2-build-verification","title":"Phase 2: Build Verification","text":""},{"location":"workflows/validation/#java-build-validation","title":"Java Build Validation","text":""},{"location":"workflows/validation/#conditional-build-execution","title":"Conditional Build Execution","text":"<pre><code># Only run for Java projects in initialized repositories\nif: |\n  needs.check-repo-state.outputs.project_type != 'generic' &amp;&amp;\n  needs.check-repo-state.outputs.initialized == 'true'\n</code></pre>"},{"location":"workflows/validation/#comprehensive-build-process","title":"Comprehensive Build Process","text":"<pre><code>- name: Setup Java Environment\n  uses: actions/setup-java@v4\n  with:\n    java-version: '17'\n    distribution: 'temurin'\n    cache: 'maven'\n\n- name: Configure Maven Settings\n  run: |\n    # Use community Maven settings if available\n    if [ -f \".mvn/community-maven.settings.xml\" ]; then\n      mkdir -p ~/.m2\n      cp .mvn/community-maven.settings.xml ~/.m2/settings.xml\n      echo \"\ud83d\udccb Using community Maven settings\"\n    fi\n\n- name: Execute Build and Tests\n  run: |\n    echo \"\ud83d\udd28 Building project with comprehensive validation...\"\n    mvn clean verify -B -DskipTests=false -DfailIfNoTests=false\n\n    # Capture build success\n    echo \"build_success=true\" &gt;&gt; $GITHUB_OUTPUT\n</code></pre>"},{"location":"workflows/validation/#test-coverage-analysis-for-prs","title":"Test Coverage Analysis for PRs","text":"<pre><code>- name: Generate Test Coverage Report\n  if: github.event_name == 'pull_request'\n  run: |\n    # Generate JaCoCo coverage report\n    mvn jacoco:report -q\n\n    # Extract coverage percentage\n    if [ -f \"target/site/jacoco/index.html\" ]; then\n      COVERAGE=$(grep -o '&lt;counter type=\"INSTRUCTION\".*' target/site/jacoco/index.html | \\\n                 grep -o 'missed=\"[0-9]*\" covered=\"[0-9]*\"' | \\\n                 awk -F'\"' '{missed+=$2; covered+=$4} END {\n                   if(missed+covered &gt; 0) print int(covered/(missed+covered)*100)\n                   else print 0\n                 }')\n      echo \"test_coverage=$COVERAGE\" &gt;&gt; $GITHUB_OUTPUT\n      echo \"\ud83d\udcca Test coverage: $COVERAGE%\"\n    else\n      echo \"test_coverage=0\" &gt;&gt; $GITHUB_OUTPUT\n      echo \"\u26a0\ufe0f No coverage report generated\"\n    fi\n</code></pre>"},{"location":"workflows/validation/#build-artifact-validation","title":"Build Artifact Validation","text":"<pre><code>- name: Validate Build Artifacts\n  run: |\n    # Verify JAR files were created\n    if [ -d \"target\" ]; then\n      JARS=$(find target -name \"*.jar\" -type f | wc -l)\n      echo \"artifacts_created=$JARS\" &gt;&gt; $GITHUB_OUTPUT\n      echo \"\ud83d\udce6 Created $JARS JAR artifacts\"\n    fi\n\n    # Check for common build issues\n    if grep -r \"BUILD FAILURE\" target/ 2&gt;/dev/null; then\n      echo \"::error::Build failures detected in artifacts\"\n      exit 1\n    fi\n</code></pre>"},{"location":"workflows/validation/#phase-3-quality-assurance-checks","title":"Phase 3: Quality Assurance Checks","text":""},{"location":"workflows/validation/#intelligent-commit-message-validation","title":"Intelligent Commit Message Validation","text":""},{"location":"workflows/validation/#context-sensitive-application","title":"Context-Sensitive Application","text":"<pre><code># Apply conventional commit validation selectively\nif: |\n  github.event_name == 'pull_request' &amp;&amp;\n  github.event.pull_request.base.ref == 'main' &amp;&amp;\n  !contains(github.actor, 'dependabot') &amp;&amp;\n  !contains(github.event.pull_request.head.ref, 'fork_') &amp;&amp;\n  !startsWith(github.event.pull_request.title, 'chore(sync)')\n</code></pre>"},{"location":"workflows/validation/#conventional-commits-enforcement","title":"Conventional Commits Enforcement","text":"<pre><code>- name: Validate Conventional Commit Format\n  uses: wagoid/commitlint-github-action@v5\n  with:\n    configFile: .commitlintrc.json\n    firstParent: false\n    failOnWarnings: false\n</code></pre>"},{"location":"workflows/validation/#supported-commit-types-configuration","title":"Supported Commit Types Configuration","text":"<pre><code>{\n  \"extends\": [\"@commitlint/config-conventional\"],\n  \"rules\": {\n    \"type-enum\": [2, \"always\", [\n      \"feat\",      \"fix\",       \"docs\",      \"style\",\n      \"refactor\",  \"test\",      \"chore\",     \"perf\", \n      \"ci\",        \"upstream\"\n    ]],\n    \"subject-case\": [2, \"never\", [\"pascal-case\", \"upper-case\"]],\n    \"subject-full-stop\": [2, \"never\", \".\"],\n    \"header-max-length\": [2, \"always\", 100]\n  }\n}\n</code></pre>"},{"location":"workflows/validation/#advanced-conflict-detection","title":"Advanced Conflict Detection","text":""},{"location":"workflows/validation/#comprehensive-conflict-scanning","title":"Comprehensive Conflict Scanning","text":"<pre><code>- name: Scan for merge conflicts across file types\n  run: |\n    echo \"\ud83d\udd0d Scanning for merge conflict markers...\"\n\n    # Define file types to scan\n    FILE_PATTERNS=(\n      \"*.java\" \"*.xml\" \"*.yml\" \"*.yaml\" \"*.json\" \n      \"*.md\" \"*.properties\" \"*.gradle\" \"*.kt\"\n    )\n\n    # Build find command with all patterns\n    FIND_CMD=\"find . -type f \\\\( \"\n    for i in \"${!FILE_PATTERNS[@]}\"; do\n      if [ $i -gt 0 ]; then\n        FIND_CMD=\"$FIND_CMD -o \"\n      fi\n      FIND_CMD=\"$FIND_CMD -name '${FILE_PATTERNS[$i]}'\"\n    done\n    FIND_CMD=\"$FIND_CMD \\\\)\"\n\n    # Execute scan\n    CONFLICTS=$(eval $FIND_CMD | xargs grep -l \"^&lt;&lt;&lt;&lt;&lt;&lt;&lt; \\\\|^======= \\\\|^&gt;&gt;&gt;&gt;&gt;&gt;&gt; \" 2&gt;/dev/null || true)\n\n    if [ -n \"$CONFLICTS\" ]; then\n      echo \"conflicts_found=true\" &gt;&gt; $GITHUB_OUTPUT\n      echo \"::error::Merge conflicts detected in:\"\n      echo \"$CONFLICTS\" | while read file; do\n        echo \"::error::  \ud83d\udcc4 $file\"\n        # Show conflict context\n        grep -n \"^&lt;&lt;&lt;&lt;&lt;&lt;&lt; \\\\|^======= \\\\|^&gt;&gt;&gt;&gt;&gt;&gt;&gt; \" \"$file\" | head -3\n      done\n    else\n      echo \"conflicts_found=false\" &gt;&gt; $GITHUB_OUTPUT\n      echo \"\u2705 No merge conflicts detected\"\n    fi\n</code></pre>"},{"location":"workflows/validation/#branch-synchronization-analysis","title":"Branch Synchronization Analysis","text":""},{"location":"workflows/validation/#up-to-date-status-verification","title":"Up-to-Date Status Verification","text":"<pre><code>- name: Analyze branch synchronization status\n  if: github.event_name == 'pull_request'\n  run: |\n    BASE_REF=\"${{ github.event.pull_request.base.ref }}\"\n\n    # Fetch latest base branch\n    git fetch origin $BASE_REF --depth=50\n\n    # Calculate divergence\n    BEHIND=$(git rev-list --count HEAD..origin/$BASE_REF)\n    AHEAD=$(git rev-list --count origin/$BASE_REF..HEAD)\n\n    echo \"behind_by=$BEHIND\" &gt;&gt; $GITHUB_OUTPUT\n    echo \"ahead_by=$AHEAD\" &gt;&gt; $GITHUB_OUTPUT\n\n    if [ \"$BEHIND\" -gt 0 ]; then\n      echo \"branch_outdated=true\" &gt;&gt; $GITHUB_OUTPUT\n      echo \"\ud83d\udd04 Branch is $BEHIND commits behind $BASE_REF\"\n      echo \"::warning::Consider updating your branch with latest changes\"\n    else\n      echo \"branch_outdated=false\" &gt;&gt; $GITHUB_OUTPUT\n      echo \"\u2705 Branch is up to date with $BASE_REF\"\n    fi\n\n    echo \"\ud83d\udcca Branch status: $AHEAD ahead, $BEHIND behind\"\n</code></pre>"},{"location":"workflows/validation/#file-change-analysis","title":"File Change Analysis","text":""},{"location":"workflows/validation/#impact-assessment","title":"Impact Assessment","text":"<pre><code>- name: Analyze file changes and impact\n  if: github.event_name == 'pull_request'\n  run: |\n    # Get changed files\n    CHANGED_FILES=$(gh pr view ${{ github.event.pull_request.number }} --json files --jq '.files[].path')\n    TOTAL_FILES=$(echo \"$CHANGED_FILES\" | wc -l)\n\n    # Categorize changes\n    CONFIG_CHANGES=$(echo \"$CHANGED_FILES\" | grep -c \"\\.yml\\|\\.yaml\\|\\.json\\|\\.properties\" || echo 0)\n    CODE_CHANGES=$(echo \"$CHANGED_FILES\" | grep -c \"\\.java\\|\\.kt\\|\\.scala\" || echo 0)\n    DOC_CHANGES=$(echo \"$CHANGED_FILES\" | grep -c \"\\.md\\|\\.txt\\|\\.adoc\" || echo 0)\n\n    echo \"total_files=$TOTAL_FILES\" &gt;&gt; $GITHUB_OUTPUT\n    echo \"config_changes=$CONFIG_CHANGES\" &gt;&gt; $GITHUB_OUTPUT\n    echo \"code_changes=$CODE_CHANGES\" &gt;&gt; $GITHUB_OUTPUT\n    echo \"doc_changes=$DOC_CHANGES\" &gt;&gt; $GITHUB_OUTPUT\n\n    echo \"\ud83d\udccb Change summary: $TOTAL_FILES files ($CODE_CHANGES code, $CONFIG_CHANGES config, $DOC_CHANGES docs)\"\n</code></pre>"},{"location":"workflows/validation/#phase-4-comprehensive-status-reporting","title":"Phase 4: Comprehensive Status Reporting","text":""},{"location":"workflows/validation/#intelligent-status-report-generation","title":"Intelligent Status Report Generation","text":""},{"location":"workflows/validation/#dynamic-report-creation","title":"Dynamic Report Creation","text":"<pre><code>- name: Generate comprehensive validation report\n  uses: actions/github-script@v7\n  with:\n    script: |\n      // Collect all validation results\n      const status = {\n        initialized: '${{ needs.check-repo-state.outputs.initialized }}',\n        projectType: '${{ needs.check-repo-state.outputs.project_type }}',\n        buildStatus: '${{ needs.java-build.result }}',\n        buildSuccess: '${{ needs.java-build.outputs.build_success }}',\n        testCoverage: '${{ needs.java-build.outputs.test_coverage }}',\n        validationStatus: '${{ needs.validate.result }}',\n        conflicts: '${{ needs.validate.outputs.conflicts_found }}',\n        branchOutdated: '${{ needs.validate.outputs.branch_outdated }}',\n        behindBy: '${{ needs.validate.outputs.behind_by }}',\n        totalFiles: '${{ needs.validate.outputs.total_files }}',\n        codeChanges: '${{ needs.validate.outputs.code_changes }}'\n      };\n\n      let report = '## \ud83d\udccb Validation Report\\n\\n';\n\n      // Repository Status Section\n      report += '### \ud83c\udfd7\ufe0f Repository Status\\n';\n      if (status.initialized === 'true') {\n        report += '\u2705 **Status**: Fully initialized and ready\\n';\n        report += `\ud83d\udd27 **Project Type**: ${status.projectType}\\n`;\n      } else {\n        report += '\u26a0\ufe0f **Status**: Not fully initialized - limited validation\\n';\n      }\n\n      // Build Status Section  \n      report += '\\n### \ud83d\udd28 Build Validation\\n';\n      if (status.buildStatus === 'success') {\n        report += '\u2705 **Build**: Successful\\n';\n        if (status.testCoverage &amp;&amp; status.testCoverage !== '0') {\n          const coverage = parseInt(status.testCoverage);\n          const coverageIcon = coverage &gt;= 80 ? '\ud83d\udfe2' : coverage &gt;= 60 ? '\ud83d\udfe1' : '\ud83d\udd34';\n          report += `${coverageIcon} **Test Coverage**: ${coverage}%\\n`;\n        }\n      } else if (status.buildStatus === 'skipped') {\n        report += '\u23ed\ufe0f **Build**: Not applicable for this project type\\n';\n      } else {\n        report += '\u274c **Build**: Failed - check build logs for details\\n';\n      }\n\n      // Quality Checks Section\n      report += '\\n### \ud83d\udee1\ufe0f Quality Checks\\n';\n\n      // Conflicts\n      if (status.conflicts === 'true') {\n        report += '\u274c **Merge Conflicts**: Detected - manual resolution required\\n';\n      } else {\n        report += '\u2705 **Merge Conflicts**: None detected\\n';\n      }\n\n      // Branch Status\n      if (status.branchOutdated === 'true') {\n        report += `\u26a0\ufe0f **Branch Status**: ${status.behindBy} commits behind - update recommended\\n`;\n      } else {\n        report += '\u2705 **Branch Status**: Up to date\\n';\n      }\n\n      // Change Impact\n      if (status.totalFiles) {\n        report += `\ud83d\udcca **Change Impact**: ${status.totalFiles} files modified`;\n        if (status.codeChanges &amp;&amp; status.codeChanges !== '0') {\n          report += ` (${status.codeChanges} code files)`;\n        }\n        report += '\\n';\n      }\n\n      // Overall Assessment\n      report += '\\n### \ud83c\udfaf Overall Assessment\\n';\n      const hasIssues = status.conflicts === 'true' || \n                       status.buildStatus === 'failure' ||\n                       status.branchOutdated === 'true';\n\n      if (!hasIssues) {\n        report += '\ud83d\udfe2 **Ready for Review**: All validation checks passed\\n';\n        report += '\u2728 This PR meets all quality standards and is ready for team review.\\n';\n      } else {\n        report += '\ud83d\udd34 **Action Required**: Please address the issues above\\n';\n        report += '\ud83d\udd27 Review the validation failures and update your PR accordingly.\\n';\n      }\n\n      // Add helpful links\n      report += '\\n---\\n';\n      report += '*\ud83d\udca1 Need help? Check the [validation documentation](../docs/workflows/validation.md) or ask in the team chat.*\\n';\n\n      return report;\n</code></pre>"},{"location":"workflows/validation/#dynamic-pr-status-updates","title":"Dynamic PR Status Updates","text":""},{"location":"workflows/validation/#smart-comment-management","title":"Smart Comment Management","text":"<pre><code>- name: Update PR with validation status\n  if: github.event_name == 'pull_request'\n  uses: actions/github-script@v7\n  with:\n    script: |\n      const report = ${{ steps.generate-report.outputs.result }};\n\n      // Find existing validation comment\n      const comments = await github.rest.issues.listComments({\n        owner: context.repo.owner,\n        repo: context.repo.repo,\n        issue_number: context.issue.number\n      });\n\n      const validationComment = comments.data.find(comment =&gt; \n        comment.user.type === 'Bot' &amp;&amp; \n        comment.body.includes('\ud83d\udccb Validation Report')\n      );\n\n      if (validationComment) {\n        // Update existing comment\n        await github.rest.issues.updateComment({\n          owner: context.repo.owner,\n          repo: context.repo.repo,\n          comment_id: validationComment.id,\n          body: report\n        });\n        console.log('Updated existing validation comment');\n      } else {\n        // Create new comment\n        await github.rest.issues.createComment({\n          owner: context.repo.owner,\n          repo: context.repo.repo,\n          issue_number: context.issue.number,\n          body: report\n        });\n        console.log('Created new validation comment');\n      }\n</code></pre>"},{"location":"workflows/validation/#special-context-handling","title":"Special Context Handling","text":""},{"location":"workflows/validation/#dependabot-integration","title":"Dependabot Integration","text":""},{"location":"workflows/validation/#automated-dependency-update-support","title":"Automated Dependency Update Support","text":"<pre><code>- name: Handle Dependabot PRs with relaxed validation\n  if: contains(github.actor, 'dependabot')\n  run: |\n    echo \"\ud83e\udd16 Dependabot PR detected - applying relaxed validation rules\"\n    echo \"dependabot=true\" &gt;&gt; $GITHUB_OUTPUT\n\n    # Skip certain validations for dependency updates\n    echo \"skip_commit_validation=true\" &gt;&gt; $GITHUB_OUTPUT\n    echo \"auto_merge_eligible=true\" &gt;&gt; $GITHUB_OUTPUT\n</code></pre> <p>Dependabot Exemptions: -  Commit message validation bypassed -  Auto-merge eligible for patch/minor updates -  Simplified status reporting focused on build success</p>"},{"location":"workflows/validation/#fork-branch-handling","title":"Fork Branch Handling","text":""},{"location":"workflows/validation/#upstream-sync-pr-validation","title":"Upstream Sync PR Validation","text":"<pre><code>- name: Apply upstream sync validation rules\n  if: |\n    contains(github.event.pull_request.head.ref, 'fork_') ||\n    startsWith(github.event.pull_request.title, 'chore(sync)')\n  run: |\n    echo \"\ud83d\udd04 Fork management branch detected\"\n    echo \"fork_branch=true\" &gt;&gt; $GITHUB_OUTPUT\n\n    # Apply specialized validation for upstream sync\n    echo \"skip_conventional_commits=true\" &gt;&gt; $GITHUB_OUTPUT\n    echo \"focus_conflict_detection=true\" &gt;&gt; $GITHUB_OUTPUT\n</code></pre>"},{"location":"workflows/validation/#material-initialization-post-initialization-validation","title":":material-initialization: Post-Initialization Validation","text":""},{"location":"workflows/validation/#repository-setup-verification","title":"Repository Setup Verification","text":"<pre><code>- name: Post-initialization comprehensive validation\n  if: inputs.post_init == true\n  run: |\n    echo \"\ud83c\udfaf Running post-initialization validation suite\"\n\n    # Comprehensive repository state verification\n    # - All branches created correctly\n    # - Workflow files deployed properly  \n    # - Security settings configured\n    # - Build system functional\n</code></pre>"},{"location":"workflows/validation/#performance-and-optimization","title":"Performance and Optimization","text":""},{"location":"workflows/validation/#efficient-resource-management","title":"Efficient Resource Management","text":""},{"location":"workflows/validation/#intelligent-caching-strategy","title":"Intelligent Caching Strategy","text":"<pre><code>- name: Optimize validation performance with caching\n  uses: actions/cache@v4\n  with:\n    path: |\n      ~/.m2/repository\n      ~/.gradle/caches\n      target/\n      build/\n    key: validation-${{ runner.os }}-${{ hashFiles('**/*.xml', '**/*.gradle*', '**/pom.xml') }}\n    restore-keys: |\n      validation-${{ runner.os }}-\n      validation-\n</code></pre>"},{"location":"workflows/validation/#parallel-execution-benefits","title":"Parallel Execution Benefits","text":"<ul> <li> Reduced Validation Time: Build and quality checks run simultaneously</li> <li> Optimized Resource Usage: Efficient job scheduling and caching</li> <li> Early Failure Detection: Quick feedback on critical issues</li> </ul>"},{"location":"workflows/validation/#conditional-processing","title":"Conditional Processing","text":""},{"location":"workflows/validation/#smart-execution-logic","title":"Smart Execution Logic","text":"<pre><code># Skip expensive operations when not needed\n- name: Conditional expensive validation\n  if: |\n    needs.check-repo-state.outputs.build_required == 'true' &amp;&amp;\n    github.event_name == 'pull_request' &amp;&amp;\n    needs.validate.outputs.code_changes &gt; 0\n  run: |\n    # Only run expensive validations for code changes in PRs\n</code></pre>"},{"location":"workflows/validation/#error-handling-and-recovery","title":"Error Handling and Recovery","text":""},{"location":"workflows/validation/#graceful-degradation","title":"Graceful Degradation","text":""},{"location":"workflows/validation/#non-critical-failure-management","title":"Non-Critical Failure Management","text":"<pre><code>- name: Optional validation with graceful failure\n  continue-on-error: true\n  run: |\n    # Validation that shouldn't block PR if it fails\n    echo \"\ud83d\udd0d Running optional advanced checks...\"\n\n    # If this fails, validation continues with warning\n</code></pre>"},{"location":"workflows/validation/#clear-error-communication","title":"Clear Error Communication","text":"<pre><code>- name: Provide actionable error guidance\n  if: failure()\n  run: |\n    echo \"::error title=Validation Failed::Review the validation report for specific issues\"\n    echo \"::error::Common solutions:\"\n    echo \"::error::  - Fix merge conflicts manually\"\n    echo \"::error::  - Update branch with latest changes\"\n    echo \"::error::  - Ensure conventional commit format\"\n    echo \"::error::  - Resolve build failures\"\n\n    # Link to documentation\n    echo \"::notice::See validation docs: https://docs/workflows/validation.md\"\n</code></pre>"},{"location":"workflows/validation/#integration-and-extensibility","title":"Integration and Extensibility","text":""},{"location":"workflows/validation/#workflow-integration-points","title":"Workflow Integration Points","text":""},{"location":"workflows/validation/#build-workflow-coordination","title":"Build Workflow Coordination","text":"<ul> <li>Shared Configuration: Consistent Java environment and dependency management</li> <li>Artifact Compatibility: Build outputs usable across workflow systems</li> <li>Performance Optimization: Shared caching and parallel execution strategies</li> </ul>"},{"location":"workflows/validation/#release-workflow-support","title":"Release Workflow Support","text":"<ul> <li>Conventional Commits: Ensures proper semantic versioning through validation</li> <li>Quality Gates: Clean validation required before release creation</li> <li>Change Documentation: Validation results feed into release notes</li> </ul>"},{"location":"workflows/validation/#sync-workflow-assistance","title":"Sync Workflow Assistance","text":"<ul> <li>Conflict Detection: Early identification of merge conflicts in upstream sync</li> <li>Branch Status: Verification of proper branch synchronization</li> <li>Special Rules: Customized validation for fork management operations</li> </ul>"},{"location":"workflows/validation/#customization-framework","title":"Customization Framework","text":""},{"location":"workflows/validation/#configurable-validation-rules","title":"Configurable Validation Rules","text":"<pre><code># Environment-based configuration\nenv:\n  JAVA_VERSION: '17'                    # Java environment version\n  VALIDATION_TIMEOUT: '15'              # Maximum validation time (minutes)\n  COVERAGE_THRESHOLD: '70'              # Minimum test coverage percentage\n  CONVENTIONAL_COMMITS: 'strict'        # Commit validation level\n  CONFLICT_DETECTION: 'comprehensive'   # Conflict scanning depth\n</code></pre>"},{"location":"workflows/validation/#extensible-validation-framework","title":"Extensible Validation Framework","text":"<pre><code># Custom validation hooks\n- name: Custom Organization Validation\n  if: env.CUSTOM_VALIDATION == 'enabled'\n  uses: ./.github/actions/custom-validate\n  with:\n    validation-config: .github/validation.yml\n    severity-level: ${{ env.VALIDATION_SEVERITY }}\n</code></pre> <p>The pull request validation workflow provides comprehensive quality assurance with intelligent rule application, ensuring code integrity while maintaining developer productivity through clear feedback and efficient execution.</p>"}]}